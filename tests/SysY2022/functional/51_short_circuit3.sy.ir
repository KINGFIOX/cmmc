internal func @getint() -> i32 { NoMemoryRead NoMemoryWrite };
internal func @getch() -> i32 { NoMemoryRead NoMemoryWrite };
internal func @getarray() -> i32 { NoMemoryRead };
internal func @getfloat() -> f32 { NoMemoryRead NoMemoryWrite };
internal func @getfarray() -> i32 { NoMemoryRead };
internal func @putint() -> void { NoMemoryRead NoMemoryWrite };
internal func @putch() -> void { NoMemoryRead NoMemoryWrite };
internal func @putarray() -> void { NoMemoryWrite };
internal func @putfloat() -> void { NoMemoryRead NoMemoryWrite };
internal func @putfarray() -> void { NoMemoryWrite };
internal func @starttime() -> void { NoMemoryRead NoMemoryWrite };
internal func @stoptime() -> void { NoMemoryRead NoMemoryWrite };
internal i32* @a;
internal i32* @b;
internal i32* @d;
internal func @set_a(i32 %val) -> i32 {
^entry:
    i32* %val1 = alloc i32;
    store i32* %val1 with i32 %val;
    i32 %0 = load i32* %val1;
    store i32* @a with i32 %0;
    i32 %1 = load i32* @a;
    ret i32 %1;
}
internal func @set_b(i32 %val) -> i32 {
^entry:
    i32* %val1 = alloc i32;
    store i32* %val1 with i32 %val;
    i32 %0 = load i32* %val1;
    store i32* @b with i32 %0;
    i32 %1 = load i32* @b;
    ret i32 %1;
}
internal func @set_d(i32 %val) -> i32 {
^entry:
    i32* %val1 = alloc i32;
    store i32* %val1 with i32 %val;
    i32 %0 = load i32* %val1;
    store i32* @d with i32 %0;
    i32 %1 = load i32* @d;
    ret i32 %1;
}
func @main() -> i32 { Entry } {
^entry:
    i32* %i4 = alloc i32;
    i32* %i3 = alloc i32;
    i32* %i2 = alloc i32;
    i32* %i1 = alloc i32;
    i32* %i0 = alloc i32;
    i32* %c = alloc i32;
    store i32* @a with i32 2;
    store i32* @b with i32 3;
    i32 %0 = call (i32) -> i32 @set_a(i32 0);
    i1 %1 = scmp neq i32 %0, i32 0;
    cbr i1 %1(prob = 0.5), ^b, ^b1;
^b:
    i32 %2 = call (i32) -> i32 @set_b(i32 1);
    i1 %3 = scmp neq i32 %2, i32 0;
    ubr ^b1;
^b1:
    i1 %4 = phi [^b, i1 %3] [^entry, i1 false];
    i32 %5 = zext i1 %4 to i32;
    i1 %6 = scmp neq i32 %5, i32 0;
    cbr i1 %6(prob = 0.5), ^if.then, ^b2;
^if.then:
    ubr ^b2;
^b2:
    i32 %7 = load i32* @a;
    call (i32) -> void @putint(i32 %7);
    call (i32) -> void @putch(i32 32);
    i32 %8 = load i32* @b;
    call (i32) -> void @putint(i32 %8);
    call (i32) -> void @putch(i32 32);
    store i32* @a with i32 2;
    store i32* @b with i32 3;
    i32 %9 = call (i32) -> i32 @set_a(i32 0);
    i1 %10 = scmp neq i32 %9, i32 0;
    cbr i1 %10(prob = 0.5), ^b3, ^b4;
^b3:
    i32 %11 = call (i32) -> i32 @set_b(i32 1);
    i1 %12 = scmp neq i32 %11, i32 0;
    ubr ^b4;
^b4:
    i1 %13 = phi [^b3, i1 %12] [^b2, i1 false];
    i32 %14 = zext i1 %13 to i32;
    i1 %15 = scmp neq i32 %14, i32 0;
    cbr i1 %15(prob = 0.5), ^if.then1, ^b5;
^if.then1:
    ubr ^b5;
^b5:
    i32 %16 = load i32* @a;
    call (i32) -> void @putint(i32 %16);
    call (i32) -> void @putch(i32 32);
    i32 %17 = load i32* @b;
    call (i32) -> void @putint(i32 %17);
    call (i32) -> void @putch(i32 10);
    store i32* %c with i32 1;
    store i32* @d with i32 2;
    i1 %18 = scmp ge i32 1, i32 1;
    i32 %19 = zext i1 %18 to i32;
    i1 %20 = scmp neq i32 %19, i32 0;
    cbr i1 %20(prob = 0.5), ^b6, ^b7;
^b6:
    i32 %21 = call (i32) -> i32 @set_d(i32 3);
    i1 %22 = scmp neq i32 %21, i32 0;
    ubr ^b7;
^b7:
    i1 %23 = phi [^b6, i1 %22] [^b5, i1 false];
    i32 %24 = zext i1 %23 to i32;
    i1 %25 = scmp neq i32 %24, i32 0;
    cbr i1 %25(prob = 0.5), ^if.then2, ^b8;
^if.then2:
    ubr ^b8;
^b8:
    i32 %26 = load i32* @d;
    call (i32) -> void @putint(i32 %26);
    call (i32) -> void @putch(i32 32);
    i1 %27 = scmp le i32 1, i32 1;
    i32 %28 = zext i1 %27 to i32;
    i1 %29 = scmp neq i32 %28, i32 0;
    cbr i1 %29(prob = 0.5), ^b10, ^b9;
^b9:
    i32 %30 = call (i32) -> i32 @set_d(i32 4);
    i1 %31 = scmp neq i32 %30, i32 0;
    ubr ^b10;
^b10:
    i1 %32 = phi [^b9, i1 %31] [^b8, i1 true];
    i32 %33 = zext i1 %32 to i32;
    i1 %34 = scmp neq i32 %33, i32 0;
    cbr i1 %34(prob = 0.5), ^if.then3, ^b11;
^if.then3:
    ubr ^b11;
^b11:
    i32 %35 = load i32* @d;
    call (i32) -> void @putint(i32 %35);
    call (i32) -> void @putch(i32 10);
    i1 %36 = scmp ge i32 16, i32 0;
    i32 %37 = zext i1 %36 to i32;
    i1 %38 = scmp neq i32 %37, i32 0;
    cbr i1 %38(prob = 0.5), ^if.then4, ^b12;
^if.then4:
    call (i32) -> void @putch(i32 65);
    ubr ^b12;
^b12:
    i1 %39 = scmp neq i32 18, i32 18;
    i32 %40 = zext i1 %39 to i32;
    i1 %41 = scmp neq i32 %40, i32 0;
    cbr i1 %41(prob = 0.5), ^if.then5, ^b13;
^if.then5:
    call (i32) -> void @putch(i32 66);
    ubr ^b13;
^b13:
    i1 %42 = scmp lt i32 1, i32 8;
    i32 %43 = zext i1 %42 to i32;
    i1 %44 = scmp neq i32 %43, i32 1;
    i32 %45 = zext i1 %44 to i32;
    i1 %46 = scmp neq i32 %45, i32 0;
    cbr i1 %46(prob = 0.5), ^if.then6, ^b14;
^if.then6:
    call (i32) -> void @putch(i32 67);
    ubr ^b14;
^b14:
    i1 %47 = scmp gt i32 3, i32 4;
    i32 %48 = zext i1 %47 to i32;
    i1 %49 = scmp eq i32 %48, i32 0;
    i32 %50 = zext i1 %49 to i32;
    i1 %51 = scmp neq i32 %50, i32 0;
    cbr i1 %51(prob = 0.5), ^if.then7, ^b15;
^if.then7:
    call (i32) -> void @putch(i32 68);
    ubr ^b15;
^b15:
    i1 %52 = scmp le i32 102, i32 63;
    i32 %53 = zext i1 %52 to i32;
    i1 %54 = scmp eq i32 1, i32 %53;
    i32 %55 = zext i1 %54 to i32;
    i1 %56 = scmp neq i32 %55, i32 0;
    cbr i1 %56(prob = 0.5), ^if.then8, ^b16;
^if.then8:
    call (i32) -> void @putch(i32 69);
    ubr ^b16;
^b16:
    i1 %57 = scmp neq i32 0, i32 0;
    i1 %58 = xor i1 %57, i1 true;
    i32 %59 = zext i1 %58 to i32;
    i32 %60 = neg i32 %59;
    i1 %61 = scmp eq i32 -1, i32 %60;
    i32 %62 = zext i1 %61 to i32;
    i1 %63 = scmp neq i32 %62, i32 0;
    cbr i1 %63(prob = 0.5), ^if.then9, ^b17;
^if.then9:
    call (i32) -> void @putch(i32 70);
    ubr ^b17;
^b17:
    call (i32) -> void @putch(i32 10);
    store i32* %i0 with i32 0;
    store i32* %i1 with i32 1;
    store i32* %i2 with i32 2;
    store i32* %i3 with i32 3;
    store i32* %i4 with i32 4;
    ubr ^while.header;
^while.header:
    i32 %64 = load i32* %i0;
    i1 %65 = scmp neq i32 %64, i32 0;
    cbr i1 %65(prob = 0.5), ^b18, ^b19;
^b18:
    i32 %66 = load i32* %i1;
    i1 %67 = scmp neq i32 %66, i32 0;
    ubr ^b19;
^b19:
    i1 %68 = phi [^b18, i1 %67] [^while.header, i1 false];
    i32 %69 = zext i1 %68 to i32;
    i1 %70 = scmp neq i32 %69, i32 0;
    cbr i1 %70(prob = 0.97), ^while.body, ^b20;
^while.body:
    call (i32) -> void @putch(i32 32);
    ubr ^while.header;
^b20:
    i32 %71 = load i32* %i0;
    i1 %72 = scmp neq i32 %71, i32 0;
    cbr i1 %72(prob = 0.5), ^b22, ^b21;
^b21:
    i32 %73 = load i32* %i1;
    i1 %74 = scmp neq i32 %73, i32 0;
    ubr ^b22;
^b22:
    i1 %75 = phi [^b21, i1 %74] [^b20, i1 true];
    i32 %76 = zext i1 %75 to i32;
    i1 %77 = scmp neq i32 %76, i32 0;
    cbr i1 %77(prob = 0.5), ^if.then10, ^b23;
^if.then10:
    call (i32) -> void @putch(i32 67);
    ubr ^b23;
^b23:
    i32 %78 = load i32* %i0;
    i32 %79 = load i32* %i1;
    i1 %80 = scmp ge i32 %78, i32 %79;
    i32 %81 = zext i1 %80 to i32;
    i1 %82 = scmp neq i32 %81, i32 0;
    cbr i1 %82(prob = 0.5), ^b25, ^b24;
^b24:
    i32 %83 = load i32* %i1;
    i32 %84 = load i32* %i0;
    i1 %85 = scmp le i32 %83, i32 %84;
    i32 %86 = zext i1 %85 to i32;
    i1 %87 = scmp neq i32 %86, i32 0;
    ubr ^b25;
^b25:
    i1 %88 = phi [^b24, i1 %87] [^b23, i1 true];
    i32 %89 = zext i1 %88 to i32;
    i1 %90 = scmp neq i32 %89, i32 0;
    cbr i1 %90(prob = 0.5), ^if.then11, ^b26;
^if.then11:
    call (i32) -> void @putch(i32 72);
    ubr ^b26;
^b26:
    i32 %91 = load i32* %i2;
    i32 %92 = load i32* %i1;
    i1 %93 = scmp ge i32 %91, i32 %92;
    i32 %94 = zext i1 %93 to i32;
    i1 %95 = scmp neq i32 %94, i32 0;
    cbr i1 %95(prob = 0.5), ^b27, ^b28;
^b27:
    i32 %96 = load i32* %i4;
    i32 %97 = load i32* %i3;
    i1 %98 = scmp neq i32 %96, i32 %97;
    i32 %99 = zext i1 %98 to i32;
    i1 %100 = scmp neq i32 %99, i32 0;
    ubr ^b28;
^b28:
    i1 %101 = phi [^b27, i1 %100] [^b26, i1 false];
    i32 %102 = zext i1 %101 to i32;
    i1 %103 = scmp neq i32 %102, i32 0;
    cbr i1 %103(prob = 0.5), ^if.then12, ^b29;
^if.then12:
    call (i32) -> void @putch(i32 73);
    ubr ^b29;
^b29:
    i32 %104 = load i32* %i0;
    i32 %105 = load i32* %i1;
    i1 %106 = scmp neq i32 %105, i32 0;
    i1 %107 = xor i1 %106, i1 true;
    i32 %108 = zext i1 %107 to i32;
    i1 %109 = scmp eq i32 %104, i32 %108;
    i32 %110 = zext i1 %109 to i32;
    i1 %111 = scmp neq i32 %110, i32 0;
    cbr i1 %111(prob = 0.5), ^b30, ^b31;
^b30:
    i32 %112 = load i32* %i3;
    i32 %113 = load i32* %i3;
    i1 %114 = scmp lt i32 %112, i32 %113;
    i32 %115 = zext i1 %114 to i32;
    i1 %116 = scmp neq i32 %115, i32 0;
    ubr ^b31;
^b31:
    i1 %117 = phi [^b30, i1 %116] [^b29, i1 false];
    i32 %118 = zext i1 %117 to i32;
    i1 %119 = scmp neq i32 %118, i32 0;
    cbr i1 %119(prob = 0.5), ^b33, ^b32;
^b32:
    i32 %120 = load i32* %i4;
    i32 %121 = load i32* %i4;
    i1 %122 = scmp ge i32 %120, i32 %121;
    i32 %123 = zext i1 %122 to i32;
    i1 %124 = scmp neq i32 %123, i32 0;
    ubr ^b33;
^b33:
    i1 %125 = phi [^b32, i1 %124] [^b31, i1 true];
    i32 %126 = zext i1 %125 to i32;
    i1 %127 = scmp neq i32 %126, i32 0;
    cbr i1 %127(prob = 0.5), ^if.then13, ^b34;
^if.then13:
    call (i32) -> void @putch(i32 74);
    ubr ^b34;
^b34:
    i32 %128 = load i32* %i0;
    i32 %129 = load i32* %i1;
    i1 %130 = scmp neq i32 %129, i32 0;
    i1 %131 = xor i1 %130, i1 true;
    i32 %132 = zext i1 %131 to i32;
    i1 %133 = scmp eq i32 %128, i32 %132;
    i32 %134 = zext i1 %133 to i32;
    i1 %135 = scmp neq i32 %134, i32 0;
    cbr i1 %135(prob = 0.5), ^b35, ^b36;
^b35:
    i1 %136 = phi [^b38, i1 %151] [^b34, i1 true];
    i32 %137 = zext i1 %136 to i32;
    i1 %138 = scmp neq i32 %137, i32 0;
    cbr i1 %138(prob = 0.5), ^if.then14, ^b39;
^b36:
    i32 %139 = load i32* %i3;
    i32 %140 = load i32* %i3;
    i1 %141 = scmp lt i32 %139, i32 %140;
    i32 %142 = zext i1 %141 to i32;
    i1 %143 = scmp neq i32 %142, i32 0;
    cbr i1 %143(prob = 0.5), ^b37, ^b38;
^if.then14:
    call (i32) -> void @putch(i32 75);
    ubr ^b39;
^b37:
    i32 %144 = load i32* %i4;
    i32 %145 = load i32* %i4;
    i1 %146 = scmp ge i32 %144, i32 %145;
    i32 %147 = zext i1 %146 to i32;
    i1 %148 = scmp neq i32 %147, i32 0;
    ubr ^b38;
^b38:
    i1 %149 = phi [^b37, i1 %148] [^b36, i1 false];
    i32 %150 = zext i1 %149 to i32;
    i1 %151 = scmp neq i32 %150, i32 0;
    ubr ^b35;
^b39:
    call (i32) -> void @putch(i32 10);
    ret i32 0;
}
