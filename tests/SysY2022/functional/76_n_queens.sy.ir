internal func @getint() -> i32 { NoMemoryRead NoMemoryWrite };
internal func @putint() -> void { NoMemoryRead NoMemoryWrite };
internal func @putch() -> void { NoMemoryRead NoMemoryWrite };
internal [50 * i32]* @ans, align 8 { Flexible };
internal [50 * i32]* @row, align 8 { Flexible };
internal [50 * i32]* @line1, align 8 { Flexible };
internal [100 * i32]* @line2, align 8 { Flexible };
internal func @f(i32 %step, i32* %0, i32* %1) -> void {
  ^entry:
    [50 * i32]* %2 = ptrcast [50 * i32]* @ans to [50 * i32]*;
    i32* %3 = getelementptr &([50 * i32]* %2)[i64 0][i32 %step];
    i32 %4 = add i32 %step, i32 1;
    [50 * i32]* %5 = ptrcast [50 * i32]* @row to [50 * i32]*;
    [50 * i32]* %6 = ptrcast [50 * i32]* @line1 to [50 * i32]*;
    [100 * i32]* %7 = ptrcast [100 * i32]* @line2 to [100 * i32]*;
    ubr ^while.header;
  ^while.header:
    i32 %8 = phi [^entry, i32 1] [^b1, i32 %14];
    i32 %9 = load i32* %1;
    i1 %10 = icmp sle i32 %8, i32 %9;
    cbr i1 %10(prob = 0.97), ^while.body, ^b;
  ^while.body:
    i32* %11 = getelementptr &([50 * i32]* %5)[i64 0][i32 %8];
    i32 %12 = load i32* %11;
    i1 %13 = icmp neq i32 %12, i32 1;
    cbr i1 %13(prob = 0.5), ^b2, ^b1;
  ^b:
    ret;
  ^b1:
    i32 %14 = add i32 %8, i32 1;
    ubr ^while.header;
  ^b2:
    i32 %15 = add i32 %step, i32 %8;
    i32* %16 = getelementptr &([50 * i32]* %6)[i64 0][i32 %15];
    i32 %17 = load i32* %16;
    i1 %18 = icmp eq i32 %17, i32 0;
    cbr i1 %18(prob = 0.5), ^b3, ^b1;
  ^b3:
    i32 %19 = add i32 %step, i32 %9;
    i32 %20 = sub i32 %19, i32 %8;
    i32* %21 = getelementptr &([100 * i32]* %7)[i64 0][i32 %20];
    i32 %22 = load i32* %21;
    i1 %23 = icmp eq i32 %22, i32 0;
    cbr i1 %23(prob = 0.5), ^if.then, ^b1;
  ^if.then:
    store i32* %3 with i32 %8;
    i1 %24 = icmp eq i32 %step, i32 %9;
    cbr i1 %24(prob = 0.5), ^entry1, ^indirect;
  ^entry1:
    i32 %25 = load i32* %0;
    i32 %26 = add i32 %25, i32 1;
    store i32* %0 with i32 %26;
    ubr ^while.header1;
  ^indirect:
    i32 %27 = load i32* %1;
    ubr ^b4;
  ^b4:
    i32 %28 = phi [^indirect, i32 %27] [^while.header1, i32 %37];
    i32 %29 = add i32 %step, i32 %28;
    i32 %30 = sub i32 %29, i32 %8;
    i32* %31 = getelementptr &([100 * i32]* %7)[i64 0][i32 %30];
    store i32* %11 with i32 1;
    store i32* %16 with i32 1;
    store i32* %31 with i32 1;
    call (i32, i32*, i32*) -> void @f(i32 %4, i32* %0, i32* %1);
    store i32* %11 with i32 0;
    store i32* %16 with i32 0;
    i32 %32 = load i32* %1;
    i32 %33 = add i32 %step, i32 %32;
    i32 %34 = sub i32 %33, i32 %8;
    i32* %35 = getelementptr &([100 * i32]* %7)[i64 0][i32 %34];
    store i32* %35 with i32 0;
    ubr ^b1;
  ^while.header1:
    i32 %36 = phi [^entry1, i32 1] [^if.else, i32 %42];
    i32 %37 = load i32* %1;
    i1 %38 = icmp sle i32 %36, i32 %37;
    cbr i1 %38(prob = 0.97), ^while.body1, ^b4;
  ^while.body1:
    i32* %39 = getelementptr &([50 * i32]* %2)[i64 0][i32 %36];
    i32 %40 = load i32* %39;
    call (i32) -> void @putint(i32 %40);
    i1 %41 = icmp eq i32 %36, i32 %37;
    cbr i1 %41(prob = 0.5), ^if.then1, ^if.else;
  ^if.then1:
    call (i32) -> void @putch(i32 10);
    ubr ^indirect;
  ^if.else:
    call (i32) -> void @putch(i32 32);
    i32 %42 = add i32 %36, i32 1;
    ubr ^while.header1;
}
func @main() -> i32 { NoRecurse Entry } {
  ^entry:
    i32* %n = alloc i32, align 8;
    i32* %sum = alloc i32, align 8;
    store i32* %sum with i32 0;
    i32 %0 = call () -> i32 @getint();
    i1 %1 = icmp sgt i32 %0, i32 0;
    cbr i1 %1(prob = 0.97), ^while.body, ^b;
  ^while.body:
    i32 %2 = phi [^entry, i32 %0] [^while.body, i32 %4];
    i32 %3 = call () -> i32 @getint();
    store i32* %n with i32 %3;
    call (i32, i32*, i32*) -> void @f(i32 1, i32* %sum, i32* %n);
    i32 %4 = add i32 %2, i32 -1;
    i1 %5 = icmp sgt i32 %4, i32 0;
    cbr i1 %5(prob = 0.97), ^while.body, ^indirect;
  ^b:
    i32 %6 = phi [^entry, i32 0] [^indirect, i32 %7];
    ret i32 %6;
  ^indirect:
    i32 %7 = load i32* %sum;
    ubr ^b;
}
