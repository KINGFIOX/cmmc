internal func @getint() -> i32 { NoMemoryRead NoMemoryWrite };
internal func @putint() -> void { NoMemoryRead NoMemoryWrite };
internal func @putch() -> void { NoMemoryRead NoMemoryWrite };
internal [50 * i32]* @ans;
internal [50 * i32]* @row;
internal [50 * i32]* @line1;
internal [100 * i32]* @line2;
internal func @f(i32 %step, i32* %0, i32* %1) -> void {
  ^entry:
    [50 * i32]* %2 = ptrcast [50 * i32]* @ans to [50 * i32]*;
    i32* %3 = getelementptr &([50 * i32]* %2)[i64 0][i32 %step];
    i32 %4 = add i32 %step, i32 1;
    i32 %5 = load i32* %1;
    [50 * i32]* %6 = ptrcast [50 * i32]* @row to [50 * i32]*;
    [50 * i32]* %7 = ptrcast [50 * i32]* @line1 to [50 * i32]*;
    [100 * i32]* %8 = ptrcast [100 * i32]* @line2 to [100 * i32]*;
    ubr ^while.header;
  ^while.header:
    i32 %9 = phi [^entry, i32 %5] [^indirect, i32 %28] [^b5, i32 %39];
    i32 %10 = phi [^entry, i32 1] [^indirect, i32 %27] [^b5, i32 %43];
    i1 %11 = icmp sge i32 %9, i32 %10;
    cbr i1 %11(prob = 0.97), ^while.body, ^b;
  ^while.body:
    i32* %12 = getelementptr &([50 * i32]* %6)[i64 0][i32 %10];
    i32 %13 = load i32* %12;
    i1 %14 = icmp neq i32 %13, i32 1;
    cbr i1 %14(prob = 0.5), ^b1, ^b2;
  ^b:
    ret;
  ^b1:
    i32 %15 = add i32 %step, i32 %10;
    i32* %16 = getelementptr &([50 * i32]* %7)[i64 0][i32 %15];
    i32 %17 = load i32* %16;
    i1 %18 = icmp eq i32 %17, i32 0;
    ubr ^b2;
  ^b2:
    i1 %19 = phi [^while.body, i1 false] [^b1, i1 %18];
    cbr i1 %19(prob = 0.5), ^b3, ^b4;
  ^b3:
    i32 %20 = load i32* %1;
    i32 %21 = add i32 %step, i32 %20;
    i32 %22 = sub i32 %21, i32 %10;
    i32* %23 = getelementptr &([100 * i32]* %8)[i64 0][i32 %22];
    i32 %24 = load i32* %23;
    i1 %25 = icmp eq i32 %24, i32 0;
    ubr ^b4;
  ^b4:
    i1 %26 = phi [^b2, i1 false] [^b3, i1 %25];
    cbr i1 %26(prob = 0.5), ^if.then, ^indirect;
  ^indirect:
    i32 %27 = add i32 %10, i32 1;
    i32 %28 = load i32* %1;
    ubr ^while.header;
  ^if.then:
    store i32* %3 with i32 %10;
    i32 %29 = load i32* %1;
    i1 %30 = icmp eq i32 %step, i32 %29;
    cbr i1 %30(prob = 0.5), ^entry1, ^b5;
  ^entry1:
    i32 %31 = load i32* %0;
    i32 %32 = add i32 %31, i32 1;
    store i32* %0 with i32 %32;
    ubr ^while.header1;
  ^b5:
    i32 %33 = phi [^if.then, i32 %29] [^while.header1, i32 %45] [^if.then1, i32 %50];
    i32 %34 = add i32 %step, i32 %33;
    i32 %35 = sub i32 %34, i32 %10;
    i32* %36 = getelementptr &([100 * i32]* %8)[i64 0][i32 %35];
    i32 %37 = add i32 %step, i32 %10;
    i32* %38 = getelementptr &([50 * i32]* %7)[i64 0][i32 %37];
    store i32* %12 with i32 1;
    store i32* %38 with i32 1;
    store i32* %36 with i32 1;
    call (i32, i32*, i32*) -> void @f(i32 %4, i32* %0, i32* %1);
    store i32* %12 with i32 0;
    store i32* %38 with i32 0;
    i32 %39 = load i32* %1;
    i32 %40 = add i32 %step, i32 %39;
    i32 %41 = sub i32 %40, i32 %10;
    i32* %42 = getelementptr &([100 * i32]* %8)[i64 0][i32 %41];
    store i32* %42 with i32 0;
    i32 %43 = add i32 %10, i32 1;
    ubr ^while.header;
  ^while.header1:
    i32 %44 = phi [^entry1, i32 1] [^if.else, i32 %51];
    i32 %45 = load i32* %1;
    i1 %46 = icmp sle i32 %44, i32 %45;
    cbr i1 %46(prob = 0.97), ^while.body1, ^b5;
  ^while.body1:
    i32* %47 = getelementptr &([50 * i32]* %2)[i64 0][i32 %44];
    i32 %48 = load i32* %47;
    call (i32) -> void @putint(i32 %48);
    i1 %49 = icmp eq i32 %44, i32 %45;
    cbr i1 %49(prob = 0.5), ^if.then1, ^if.else;
  ^if.then1:
    call (i32) -> void @putch(i32 10);
    i32 %50 = load i32* %1;
    ubr ^b5;
  ^if.else:
    call (i32) -> void @putch(i32 32);
    i32 %51 = add i32 %44, i32 1;
    ubr ^while.header1;
}
func @main() -> i32 { NoRecurse Entry } {
  ^entry:
    i32* %n = alloc i32;
    i32* %sum = alloc i32;
    store i32* %sum with i32 0;
    i32 %0 = call () -> i32 @getint();
    i1 %1 = icmp sgt i32 %0, i32 0;
    cbr i1 %1(prob = 0.97), ^while.body, ^b;
  ^while.body:
    i32 %2 = phi [^entry, i32 %0] [^while.body, i32 %4];
    i32 %3 = call () -> i32 @getint();
    store i32* %n with i32 %3;
    call (i32, i32*, i32*) -> void @f(i32 1, i32* %sum, i32* %n);
    i32 %4 = add i32 %2, i32 -1;
    i1 %5 = icmp sgt i32 %4, i32 0;
    cbr i1 %5(prob = 0.97), ^while.body, ^indirect;
  ^b:
    i32 %6 = phi [^entry, i32 0] [^indirect, i32 %7];
    ret i32 %6;
  ^indirect:
    i32 %7 = load i32* %sum;
    ubr ^b;
}
