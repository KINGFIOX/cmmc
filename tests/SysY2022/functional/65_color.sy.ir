internal func @getint() -> i32 { NoMemoryRead NoMemoryWrite };
internal func @getch() -> i32 { NoMemoryRead NoMemoryWrite };
internal func @getarray() -> i32 { NoMemoryRead };
internal func @getfloat() -> f32 { NoMemoryRead NoMemoryWrite };
internal func @getfarray() -> i32 { NoMemoryRead };
internal func @putint() -> void { NoMemoryRead NoMemoryWrite };
internal func @putch() -> void { NoMemoryRead NoMemoryWrite };
internal func @putarray() -> void { NoMemoryWrite };
internal func @putfloat() -> void { NoMemoryRead NoMemoryWrite };
internal func @putfarray() -> void { NoMemoryWrite };
internal func @starttime() -> void { NoMemoryRead NoMemoryWrite };
internal func @stoptime() -> void { NoMemoryRead NoMemoryWrite };
internal i32* @maxn { ReadOnly } = 18;
internal i32* @mod { ReadOnly } = 1000000007;
internal [18 * [18 * [18 * [18 * [18 * [7 * i32]]]]]]* @dp;
internal [200 * i32]* @list;
internal func @equal(i32 %a, i32 %b) -> i32 {
^entry:
    i32* %b1 = alloc i32;
    i32* %a1 = alloc i32;
    store i32* %a1 with i32 %a;
    store i32* %b1 with i32 %b;
    i32 %0 = load i32* %a1;
    i32 %1 = load i32* %b1;
    i1 %2 = scmp eq i32 %0, i32 %1;
    i32 %3 = zext i1 %2 to i32;
    i1 %4 = scmp neq i32 %3, i32 0;
    cbr i1 %4(prob = 0.5), ^if.then, ^b2;
^if.then:
    ret i32 1;
^b2:
    ret i32 0;
}
internal func @dfs(i32 %a, i32 %b, i32 %c, i32 %d, i32 %e, i32 %last) -> i32 {
^entry:
    i32* %ans = alloc i32;
    i32* %last1 = alloc i32;
    i32* %e1 = alloc i32;
    i32* %d1 = alloc i32;
    i32* %c1 = alloc i32;
    i32* %b1 = alloc i32;
    i32* %a1 = alloc i32;
    store i32* %a1 with i32 %a;
    store i32* %b1 with i32 %b;
    store i32* %c1 with i32 %c;
    store i32* %d1 with i32 %d;
    store i32* %e1 with i32 %e;
    store i32* %last1 with i32 %last;
    i32 %0 = load i32* %a1;
    i64 %1 = sext i32 %0 to i64;
    [18 * [18 * [18 * [18 * [7 * i32]]]]]* %2 = getelementptr &([18 * [18 * [18 * [18 * [18 * [7 * i32]]]]]]* @dp)[i64 0][i64 %1];
    i32 %3 = load i32* %b1;
    i64 %4 = sext i32 %3 to i64;
    [18 * [18 * [18 * [7 * i32]]]]* %5 = getelementptr &([18 * [18 * [18 * [18 * [7 * i32]]]]]* %2)[i64 0][i64 %4];
    i32 %6 = load i32* %c1;
    i64 %7 = sext i32 %6 to i64;
    [18 * [18 * [7 * i32]]]* %8 = getelementptr &([18 * [18 * [18 * [7 * i32]]]]* %5)[i64 0][i64 %7];
    i32 %9 = load i32* %d1;
    i64 %10 = sext i32 %9 to i64;
    [18 * [7 * i32]]* %11 = getelementptr &([18 * [18 * [7 * i32]]]* %8)[i64 0][i64 %10];
    i32 %12 = load i32* %e1;
    i64 %13 = sext i32 %12 to i64;
    [7 * i32]* %14 = getelementptr &([18 * [7 * i32]]* %11)[i64 0][i64 %13];
    i32 %15 = load i32* %last1;
    i64 %16 = sext i32 %15 to i64;
    i32* %17 = getelementptr &([7 * i32]* %14)[i64 0][i64 %16];
    i32 %18 = load i32* %17;
    i1 %19 = scmp neq i32 %18, i32 -1;
    i32 %20 = zext i1 %19 to i32;
    i1 %21 = scmp neq i32 %20, i32 0;
    cbr i1 %21(prob = 0.5), ^if.then, ^b2;
^b2:
    i32 %22 = load i32* %a1;
    i32 %23 = load i32* %b1;
    i32 %24 = add i32 %22, i32 %23;
    i32 %25 = load i32* %c1;
    i32 %26 = add i32 %24, i32 %25;
    i32 %27 = load i32* %d1;
    i32 %28 = add i32 %26, i32 %27;
    i32 %29 = load i32* %e1;
    i32 %30 = add i32 %28, i32 %29;
    i1 %31 = scmp eq i32 %30, i32 0;
    i32 %32 = zext i1 %31 to i32;
    i1 %33 = scmp neq i32 %32, i32 0;
    cbr i1 %33(prob = 0.5), ^if.then1, ^b3;
^if.then:
    i32 %34 = load i32* %a1;
    i64 %35 = sext i32 %34 to i64;
    [18 * [18 * [18 * [18 * [7 * i32]]]]]* %36 = getelementptr &([18 * [18 * [18 * [18 * [18 * [7 * i32]]]]]]* @dp)[i64 0][i64 %35];
    i32 %37 = load i32* %b1;
    i64 %38 = sext i32 %37 to i64;
    [18 * [18 * [18 * [7 * i32]]]]* %39 = getelementptr &([18 * [18 * [18 * [18 * [7 * i32]]]]]* %36)[i64 0][i64 %38];
    i32 %40 = load i32* %c1;
    i64 %41 = sext i32 %40 to i64;
    [18 * [18 * [7 * i32]]]* %42 = getelementptr &([18 * [18 * [18 * [7 * i32]]]]* %39)[i64 0][i64 %41];
    i32 %43 = load i32* %d1;
    i64 %44 = sext i32 %43 to i64;
    [18 * [7 * i32]]* %45 = getelementptr &([18 * [18 * [7 * i32]]]* %42)[i64 0][i64 %44];
    i32 %46 = load i32* %e1;
    i64 %47 = sext i32 %46 to i64;
    [7 * i32]* %48 = getelementptr &([18 * [7 * i32]]* %45)[i64 0][i64 %47];
    i32 %49 = load i32* %last1;
    i64 %50 = sext i32 %49 to i64;
    i32* %51 = getelementptr &([7 * i32]* %48)[i64 0][i64 %50];
    i32 %52 = load i32* %51;
    ret i32 %52;
^b3:
    store i32* %ans with i32 0;
    i32 %53 = load i32* %a1;
    i1 %54 = scmp neq i32 %53, i32 0;
    cbr i1 %54(prob = 0.5), ^if.then2, ^b4;
^if.then1:
    ret i32 1;
^if.then2:
    i32 %55 = load i32* %ans;
    i32 %56 = load i32* %a1;
    i32 %57 = load i32* %last1;
    i32 %58 = call (i32, i32) -> i32 @equal(i32 %57, i32 2);
    i32 %59 = sub i32 %56, i32 %58;
    i32 %60 = load i32* %a1;
    i32 %61 = sub i32 %60, i32 1;
    i32 %62 = load i32* %b1;
    i32 %63 = load i32* %c1;
    i32 %64 = load i32* %d1;
    i32 %65 = load i32* %e1;
    i32 %66 = call (i32, i32, i32, i32, i32, i32) -> i32 @dfs(i32 %61, i32 %62, i32 %63, i32 %64, i32 %65, i32 1);
    i32 %67 = mul i32 %59, i32 %66;
    i32 %68 = add i32 %55, i32 %67;
    i32 %69 = srem i32 %68, i32 1000000007;
    store i32* %ans with i32 %69;
    ubr ^b4;
^b4:
    i32 %70 = load i32* %b1;
    i1 %71 = scmp neq i32 %70, i32 0;
    cbr i1 %71(prob = 0.5), ^if.then3, ^b5;
^if.then3:
    i32 %72 = load i32* %ans;
    i32 %73 = load i32* %b1;
    i32 %74 = load i32* %last1;
    i32 %75 = call (i32, i32) -> i32 @equal(i32 %74, i32 3);
    i32 %76 = sub i32 %73, i32 %75;
    i32 %77 = load i32* %a1;
    i32 %78 = add i32 %77, i32 1;
    i32 %79 = load i32* %b1;
    i32 %80 = sub i32 %79, i32 1;
    i32 %81 = load i32* %c1;
    i32 %82 = load i32* %d1;
    i32 %83 = load i32* %e1;
    i32 %84 = call (i32, i32, i32, i32, i32, i32) -> i32 @dfs(i32 %78, i32 %80, i32 %81, i32 %82, i32 %83, i32 2);
    i32 %85 = mul i32 %76, i32 %84;
    i32 %86 = add i32 %72, i32 %85;
    i32 %87 = srem i32 %86, i32 1000000007;
    store i32* %ans with i32 %87;
    ubr ^b5;
^b5:
    i32 %88 = load i32* %c1;
    i1 %89 = scmp neq i32 %88, i32 0;
    cbr i1 %89(prob = 0.5), ^if.then4, ^b6;
^if.then4:
    i32 %90 = load i32* %ans;
    i32 %91 = load i32* %c1;
    i32 %92 = load i32* %last1;
    i32 %93 = call (i32, i32) -> i32 @equal(i32 %92, i32 4);
    i32 %94 = sub i32 %91, i32 %93;
    i32 %95 = load i32* %a1;
    i32 %96 = load i32* %b1;
    i32 %97 = add i32 %96, i32 1;
    i32 %98 = load i32* %c1;
    i32 %99 = sub i32 %98, i32 1;
    i32 %100 = load i32* %d1;
    i32 %101 = load i32* %e1;
    i32 %102 = call (i32, i32, i32, i32, i32, i32) -> i32 @dfs(i32 %95, i32 %97, i32 %99, i32 %100, i32 %101, i32 3);
    i32 %103 = mul i32 %94, i32 %102;
    i32 %104 = add i32 %90, i32 %103;
    i32 %105 = srem i32 %104, i32 1000000007;
    store i32* %ans with i32 %105;
    ubr ^b6;
^b6:
    i32 %106 = load i32* %d1;
    i1 %107 = scmp neq i32 %106, i32 0;
    cbr i1 %107(prob = 0.5), ^if.then5, ^b7;
^if.then5:
    i32 %108 = load i32* %ans;
    i32 %109 = load i32* %d1;
    i32 %110 = load i32* %last1;
    i32 %111 = call (i32, i32) -> i32 @equal(i32 %110, i32 5);
    i32 %112 = sub i32 %109, i32 %111;
    i32 %113 = load i32* %a1;
    i32 %114 = load i32* %b1;
    i32 %115 = load i32* %c1;
    i32 %116 = add i32 %115, i32 1;
    i32 %117 = load i32* %d1;
    i32 %118 = sub i32 %117, i32 1;
    i32 %119 = load i32* %e1;
    i32 %120 = call (i32, i32, i32, i32, i32, i32) -> i32 @dfs(i32 %113, i32 %114, i32 %116, i32 %118, i32 %119, i32 4);
    i32 %121 = mul i32 %112, i32 %120;
    i32 %122 = add i32 %108, i32 %121;
    i32 %123 = srem i32 %122, i32 1000000007;
    store i32* %ans with i32 %123;
    ubr ^b7;
^b7:
    i32 %124 = load i32* %e1;
    i1 %125 = scmp neq i32 %124, i32 0;
    cbr i1 %125(prob = 0.5), ^if.then6, ^b8;
^if.then6:
    i32 %126 = load i32* %ans;
    i32 %127 = load i32* %e1;
    i32 %128 = load i32* %a1;
    i32 %129 = load i32* %b1;
    i32 %130 = load i32* %c1;
    i32 %131 = load i32* %d1;
    i32 %132 = add i32 %131, i32 1;
    i32 %133 = load i32* %e1;
    i32 %134 = sub i32 %133, i32 1;
    i32 %135 = call (i32, i32, i32, i32, i32, i32) -> i32 @dfs(i32 %128, i32 %129, i32 %130, i32 %132, i32 %134, i32 5);
    i32 %136 = mul i32 %127, i32 %135;
    i32 %137 = add i32 %126, i32 %136;
    i32 %138 = srem i32 %137, i32 1000000007;
    store i32* %ans with i32 %138;
    ubr ^b8;
^b8:
    i32 %139 = load i32* %a1;
    i64 %140 = sext i32 %139 to i64;
    [18 * [18 * [18 * [18 * [7 * i32]]]]]* %141 = getelementptr &([18 * [18 * [18 * [18 * [18 * [7 * i32]]]]]]* @dp)[i64 0][i64 %140];
    i32 %142 = load i32* %b1;
    i64 %143 = sext i32 %142 to i64;
    [18 * [18 * [18 * [7 * i32]]]]* %144 = getelementptr &([18 * [18 * [18 * [18 * [7 * i32]]]]]* %141)[i64 0][i64 %143];
    i32 %145 = load i32* %c1;
    i64 %146 = sext i32 %145 to i64;
    [18 * [18 * [7 * i32]]]* %147 = getelementptr &([18 * [18 * [18 * [7 * i32]]]]* %144)[i64 0][i64 %146];
    i32 %148 = load i32* %d1;
    i64 %149 = sext i32 %148 to i64;
    [18 * [7 * i32]]* %150 = getelementptr &([18 * [18 * [7 * i32]]]* %147)[i64 0][i64 %149];
    i32 %151 = load i32* %e1;
    i64 %152 = sext i32 %151 to i64;
    [7 * i32]* %153 = getelementptr &([18 * [7 * i32]]* %150)[i64 0][i64 %152];
    i32 %154 = load i32* %last1;
    i64 %155 = sext i32 %154 to i64;
    i32* %156 = getelementptr &([7 * i32]* %153)[i64 0][i64 %155];
    i32 %157 = load i32* %ans;
    i32 %158 = srem i32 %157, i32 1000000007;
    store i32* %156 with i32 %158;
    i32 %159 = load i32* %a1;
    i64 %160 = sext i32 %159 to i64;
    [18 * [18 * [18 * [18 * [7 * i32]]]]]* %161 = getelementptr &([18 * [18 * [18 * [18 * [18 * [7 * i32]]]]]]* @dp)[i64 0][i64 %160];
    i32 %162 = load i32* %b1;
    i64 %163 = sext i32 %162 to i64;
    [18 * [18 * [18 * [7 * i32]]]]* %164 = getelementptr &([18 * [18 * [18 * [18 * [7 * i32]]]]]* %161)[i64 0][i64 %163];
    i32 %165 = load i32* %c1;
    i64 %166 = sext i32 %165 to i64;
    [18 * [18 * [7 * i32]]]* %167 = getelementptr &([18 * [18 * [18 * [7 * i32]]]]* %164)[i64 0][i64 %166];
    i32 %168 = load i32* %d1;
    i64 %169 = sext i32 %168 to i64;
    [18 * [7 * i32]]* %170 = getelementptr &([18 * [18 * [7 * i32]]]* %167)[i64 0][i64 %169];
    i32 %171 = load i32* %e1;
    i64 %172 = sext i32 %171 to i64;
    [7 * i32]* %173 = getelementptr &([18 * [7 * i32]]* %170)[i64 0][i64 %172];
    i32 %174 = load i32* %last1;
    i64 %175 = sext i32 %174 to i64;
    i32* %176 = getelementptr &([7 * i32]* %173)[i64 0][i64 %175];
    i32 %177 = load i32* %176;
    ret i32 %177;
}
internal [20 * i32]* @cns;
func @main() -> i32 { Entry } {
^entry:
    i32* %ans = alloc i32;
    i32* %h = alloc i32;
    i32* %m = alloc i32;
    i32* %l = alloc i32;
    i32* %k = alloc i32;
    i32* %j = alloc i32;
    i32* %i = alloc i32;
    i32* %n = alloc i32;
    i32 %0 = call () -> i32 @getint();
    store i32* %n with i32 %0;
    store i32* %i with i32 0;
    ubr ^while.header;
^while.header:
    i32 %1 = load i32* %i;
    i1 %2 = scmp lt i32 %1, i32 18;
    i32 %3 = zext i1 %2 to i32;
    i1 %4 = scmp neq i32 %3, i32 0;
    cbr i1 %4(prob = 0.97), ^while.body, ^b;
^while.body:
    store i32* %j with i32 0;
    ubr ^while.header1;
^b:
    store i32* %i with i32 0;
    ubr ^while.header2;
^while.header1:
    i32 %5 = load i32* %j;
    i1 %6 = scmp lt i32 %5, i32 18;
    i32 %7 = zext i1 %6 to i32;
    i1 %8 = scmp neq i32 %7, i32 0;
    cbr i1 %8(prob = 0.97), ^while.body1, ^b1;
^while.header2:
    i32 %9 = load i32* %i;
    i32 %10 = load i32* %n;
    i1 %11 = scmp lt i32 %9, i32 %10;
    i32 %12 = zext i1 %11 to i32;
    i1 %13 = scmp neq i32 %12, i32 0;
    cbr i1 %13(prob = 0.97), ^while.body2, ^b2;
^while.body1:
    store i32* %k with i32 0;
    ubr ^while.header3;
^b1:
    i32 %14 = load i32* %i;
    i32 %15 = add i32 %14, i32 1;
    store i32* %i with i32 %15;
    ubr ^while.header;
^while.body2:
    i32 %16 = load i32* %i;
    i64 %17 = sext i32 %16 to i64;
    i32* %18 = getelementptr &([200 * i32]* @list)[i64 0][i64 %17];
    i32 %19 = call () -> i32 @getint();
    store i32* %18 with i32 %19;
    i32 %20 = load i32* %i;
    i64 %21 = sext i32 %20 to i64;
    i32* %22 = getelementptr &([200 * i32]* @list)[i64 0][i64 %21];
    i32 %23 = load i32* %22;
    i64 %24 = sext i32 %23 to i64;
    i32* %25 = getelementptr &([20 * i32]* @cns)[i64 0][i64 %24];
    i32 %26 = load i32* %i;
    i64 %27 = sext i32 %26 to i64;
    i32* %28 = getelementptr &([200 * i32]* @list)[i64 0][i64 %27];
    i32 %29 = load i32* %28;
    i64 %30 = sext i32 %29 to i64;
    i32* %31 = getelementptr &([20 * i32]* @cns)[i64 0][i64 %30];
    i32 %32 = load i32* %31;
    i32 %33 = add i32 %32, i32 1;
    store i32* %25 with i32 %33;
    i32 %34 = load i32* %i;
    i32 %35 = add i32 %34, i32 1;
    store i32* %i with i32 %35;
    ubr ^while.header2;
^b2:
    i32* %36 = getelementptr &([20 * i32]* @cns)[i64 0][i64 1];
    i32 %37 = load i32* %36;
    i32* %38 = getelementptr &([20 * i32]* @cns)[i64 0][i64 2];
    i32 %39 = load i32* %38;
    i32* %40 = getelementptr &([20 * i32]* @cns)[i64 0][i64 3];
    i32 %41 = load i32* %40;
    i32* %42 = getelementptr &([20 * i32]* @cns)[i64 0][i64 4];
    i32 %43 = load i32* %42;
    i32* %44 = getelementptr &([20 * i32]* @cns)[i64 0][i64 5];
    i32 %45 = load i32* %44;
    i32 %46 = call (i32, i32, i32, i32, i32, i32) -> i32 @dfs(i32 %37, i32 %39, i32 %41, i32 %43, i32 %45, i32 0);
    store i32* %ans with i32 %46;
    i32 %47 = load i32* %ans;
    call (i32) -> void @putint(i32 %47);
    i32 %48 = load i32* %ans;
    ret i32 %48;
^while.header3:
    i32 %49 = load i32* %k;
    i1 %50 = scmp lt i32 %49, i32 18;
    i32 %51 = zext i1 %50 to i32;
    i1 %52 = scmp neq i32 %51, i32 0;
    cbr i1 %52(prob = 0.97), ^while.body3, ^b3;
^while.body3:
    store i32* %l with i32 0;
    ubr ^while.header4;
^b3:
    i32 %53 = load i32* %j;
    i32 %54 = add i32 %53, i32 1;
    store i32* %j with i32 %54;
    ubr ^while.header1;
^while.header4:
    i32 %55 = load i32* %l;
    i1 %56 = scmp lt i32 %55, i32 18;
    i32 %57 = zext i1 %56 to i32;
    i1 %58 = scmp neq i32 %57, i32 0;
    cbr i1 %58(prob = 0.97), ^while.body4, ^b4;
^while.body4:
    store i32* %m with i32 0;
    ubr ^while.header5;
^b4:
    i32 %59 = load i32* %k;
    i32 %60 = add i32 %59, i32 1;
    store i32* %k with i32 %60;
    ubr ^while.header3;
^while.header5:
    i32 %61 = load i32* %m;
    i1 %62 = scmp lt i32 %61, i32 18;
    i32 %63 = zext i1 %62 to i32;
    i1 %64 = scmp neq i32 %63, i32 0;
    cbr i1 %64(prob = 0.97), ^while.body5, ^b5;
^while.body5:
    store i32* %h with i32 0;
    ubr ^while.header6;
^b5:
    i32 %65 = load i32* %l;
    i32 %66 = add i32 %65, i32 1;
    store i32* %l with i32 %66;
    ubr ^while.header4;
^while.header6:
    i32 %67 = load i32* %h;
    i1 %68 = scmp lt i32 %67, i32 7;
    i32 %69 = zext i1 %68 to i32;
    i1 %70 = scmp neq i32 %69, i32 0;
    cbr i1 %70(prob = 0.97), ^while.body6, ^b6;
^while.body6:
    i32 %71 = load i32* %i;
    i64 %72 = sext i32 %71 to i64;
    [18 * [18 * [18 * [18 * [7 * i32]]]]]* %73 = getelementptr &([18 * [18 * [18 * [18 * [18 * [7 * i32]]]]]]* @dp)[i64 0][i64 %72];
    i32 %74 = load i32* %j;
    i64 %75 = sext i32 %74 to i64;
    [18 * [18 * [18 * [7 * i32]]]]* %76 = getelementptr &([18 * [18 * [18 * [18 * [7 * i32]]]]]* %73)[i64 0][i64 %75];
    i32 %77 = load i32* %k;
    i64 %78 = sext i32 %77 to i64;
    [18 * [18 * [7 * i32]]]* %79 = getelementptr &([18 * [18 * [18 * [7 * i32]]]]* %76)[i64 0][i64 %78];
    i32 %80 = load i32* %l;
    i64 %81 = sext i32 %80 to i64;
    [18 * [7 * i32]]* %82 = getelementptr &([18 * [18 * [7 * i32]]]* %79)[i64 0][i64 %81];
    i32 %83 = load i32* %m;
    i64 %84 = sext i32 %83 to i64;
    [7 * i32]* %85 = getelementptr &([18 * [7 * i32]]* %82)[i64 0][i64 %84];
    i32 %86 = load i32* %h;
    i64 %87 = sext i32 %86 to i64;
    i32* %88 = getelementptr &([7 * i32]* %85)[i64 0][i64 %87];
    store i32* %88 with i32 -1;
    i32 %89 = load i32* %h;
    i32 %90 = add i32 %89, i32 1;
    store i32* %h with i32 %90;
    ubr ^while.header6;
^b6:
    i32 %91 = load i32* %m;
    i32 %92 = add i32 %91, i32 1;
    store i32* %m with i32 %92;
    ubr ^while.header5;
}
