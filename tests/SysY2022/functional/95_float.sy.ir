internal func @getint() -> i32 { NoMemoryRead NoMemoryWrite };
internal func @getch() -> i32 { NoMemoryRead NoMemoryWrite };
internal func @getarray() -> i32 { NoMemoryRead };
internal func @getfloat() -> f32 { NoMemoryRead NoMemoryWrite };
internal func @getfarray() -> i32 { NoMemoryRead };
internal func @putint() -> void { NoMemoryRead NoMemoryWrite };
internal func @putch() -> void { NoMemoryRead NoMemoryWrite };
internal func @putarray() -> void { NoMemoryWrite };
internal func @putfloat() -> void { NoMemoryRead NoMemoryWrite };
internal func @putfarray() -> void { NoMemoryWrite };
internal func @starttime() -> void { NoMemoryRead NoMemoryWrite };
internal func @stoptime() -> void { NoMemoryRead NoMemoryWrite };
internal f32* @RADIUS { ReadOnly } = 5.5;
internal f32* @PI { ReadOnly } = 3.14159;
internal f32* @EPS { ReadOnly } = 1e-06;
internal f32* @PI_HEX { ReadOnly } = 3.14159;
internal f32* @HEX2 { ReadOnly } = 0.078125;
internal f32* @FACT { ReadOnly } = -33000;
internal f32* @EVAL1 { ReadOnly } = 95.0332;
internal f32* @EVAL2 { ReadOnly } = 34.5575;
internal f32* @EVAL3 { ReadOnly } = 34.5575;
internal f32* @CONV1 { ReadOnly } = 233;
internal f32* @CONV2 { ReadOnly } = 4095;
internal i32* @MAX { ReadOnly } = 1000000000;
internal i32* @TWO { ReadOnly } = 2;
internal i32* @THREE { ReadOnly } = 3;
internal i32* @FIVE { ReadOnly } = 5;
internal func @float_abs(f32 %x) -> f32 {
^entry:
    f32* %x1 = alloc f32;
    store f32* %x1 with f32 %x;
    f32 %0 = load f32* %x1;
    i1 %1 = fcmp lt f32 %0, f32 0;
    i32 %2 = zext i1 %1 to i32;
    i1 %3 = scmp neq i32 %2, i32 0;
    cbr i1 %3(prob = 0.5), ^if.then, ^b;
^if.then:
    f32 %4 = load f32* %x1;
    f32 %5 = fneg f32 %4;
    ret f32 %5;
^b:
    f32 %6 = load f32* %x1;
    ret f32 %6;
}
internal func @circle_area(i32 %radius) -> f32 {
^entry:
    i32* %radius1 = alloc i32;
    store i32* %radius1 with i32 %radius;
    i32 %0 = load i32* %radius1;
    f32 %1 = s2f i32 %0 to f32;
    f32 %2 = fmul f32 3.14159, f32 %1;
    i32 %3 = load i32* %radius1;
    f32 %4 = s2f i32 %3 to f32;
    f32 %5 = fmul f32 %2, f32 %4;
    i32 %6 = load i32* %radius1;
    i32 %7 = load i32* %radius1;
    i32 %8 = mul i32 %6, i32 %7;
    f32 %9 = s2f i32 %8 to f32;
    f32 %10 = fmul f32 %9, f32 3.14159;
    f32 %11 = fadd f32 %5, f32 %10;
    f32 %12 = fdiv f32 %11, f32 2;
    ret f32 %12;
}
internal func @float_eq(f32 %a, f32 %b) -> i32 {
^entry:
    f32* %b1 = alloc f32;
    f32* %a1 = alloc f32;
    store f32* %a1 with f32 %a;
    store f32* %b1 with f32 %b;
    f32 %0 = load f32* %a1;
    f32 %1 = load f32* %b1;
    f32 %2 = fsub f32 %0, f32 %1;
    f32 %3 = call (f32) -> f32 @float_abs(f32 %2);
    i1 %4 = fcmp lt f32 %3, f32 1e-06;
    i32 %5 = zext i1 %4 to i32;
    i1 %6 = scmp neq i32 %5, i32 0;
    cbr i1 %6(prob = 0.5), ^if.then, ^if.else;
^if.then:
    ret i32 1;
^if.else:
    ret i32 0;
^b2:
    unreachable;
}
internal func @error() -> void {
^entry:
    call (i32) -> void @putch(i32 101);
    call (i32) -> void @putch(i32 114);
    call (i32) -> void @putch(i32 114);
    call (i32) -> void @putch(i32 111);
    call (i32) -> void @putch(i32 114);
    call (i32) -> void @putch(i32 10);
    ret;
}
internal func @ok() -> void {
^entry:
    call (i32) -> void @putch(i32 111);
    call (i32) -> void @putch(i32 107);
    call (i32) -> void @putch(i32 10);
    ret;
}
internal func @assert(i32 %cond) -> void {
^entry:
    i32* %cond1 = alloc i32;
    store i32* %cond1 with i32 %cond;
    i32 %0 = load i32* %cond1;
    i1 %1 = scmp neq i32 %0, i32 0;
    i1 %2 = xor i1 %1, i1 true;
    i32 %3 = zext i1 %2 to i32;
    i1 %4 = scmp neq i32 %3, i32 0;
    cbr i1 %4(prob = 0.5), ^if.then, ^if.else;
^if.then:
    call () -> void @error();
    ubr ^b;
^if.else:
    call () -> void @ok();
    ubr ^b;
^b:
    ret;
}
internal func @assert_not(i32 %cond) -> void {
^entry:
    i32* %cond1 = alloc i32;
    store i32* %cond1 with i32 %cond;
    i32 %0 = load i32* %cond1;
    i1 %1 = scmp neq i32 %0, i32 0;
    cbr i1 %1(prob = 0.5), ^if.then, ^if.else;
^if.then:
    call () -> void @error();
    ubr ^b;
^if.else:
    call () -> void @ok();
    ubr ^b;
^b:
    ret;
}
func @main() -> i32 { Entry } {
^entry:
    f32* %area_tru = alloc f32;
    f32* %area = alloc f32;
    f32* %input = alloc f32;
    i32* %len = alloc i32;
    [10 * f32]* %arr = alloc [10 * f32];
    i32* %p = alloc i32;
    i32* %i = alloc i32;
    i32 %0 = call (f32, f32) -> i32 @float_eq(f32 0.078125, f32 -33000);
    call (i32) -> void @assert_not(i32 %0);
    i32 %1 = call (f32, f32) -> i32 @float_eq(f32 95.0332, f32 34.5575);
    call (i32) -> void @assert_not(i32 %1);
    i32 %2 = call (f32, f32) -> i32 @float_eq(f32 34.5575, f32 34.5575);
    call (i32) -> void @assert(i32 %2);
    f32 %3 = call (i32) -> f32 @circle_area(i32 5);
    f32 %4 = call (i32) -> f32 @circle_area(i32 5);
    i32 %5 = call (f32, f32) -> i32 @float_eq(f32 %3, f32 %4);
    call (i32) -> void @assert(i32 %5);
    i32 %6 = call (f32, f32) -> i32 @float_eq(f32 233, f32 4095);
    call (i32) -> void @assert_not(i32 %6);
    i1 %7 = fcmp neq f32 1.5, f32 0;
    cbr i1 %7(prob = 0.5), ^if.then, ^b;
^if.then:
    call () -> void @ok();
    ubr ^b;
^b:
    i1 %8 = fcmp neq f32 3.3, f32 0;
    i1 %9 = xor i1 %8, i1 true;
    i32 %10 = zext i1 %9 to i32;
    i1 %11 = scmp neq i32 %10, i32 0;
    i1 %12 = xor i1 %11, i1 true;
    i32 %13 = zext i1 %12 to i32;
    i1 %14 = scmp neq i32 %13, i32 0;
    cbr i1 %14(prob = 0.5), ^if.then1, ^b1;
^if.then1:
    call () -> void @ok();
    ubr ^b1;
^b1:
    i1 %15 = fcmp neq f32 0, f32 0;
    cbr i1 %15(prob = 0.5), ^b2, ^b3;
^b2:
    i1 %16 = scmp neq i32 3, i32 0;
    ubr ^b3;
^b3:
    i1 %17 = phi [^b2, i1 %16] [^b1, i1 false];
    i32 %18 = zext i1 %17 to i32;
    i1 %19 = scmp neq i32 %18, i32 0;
    cbr i1 %19(prob = 0.5), ^if.then2, ^b4;
^if.then2:
    call () -> void @error();
    ubr ^b4;
^b4:
    i1 %20 = scmp neq i32 0, i32 0;
    cbr i1 %20(prob = 0.5), ^b6, ^b5;
^b5:
    i1 %21 = fcmp neq f32 0.3, f32 0;
    ubr ^b6;
^b6:
    i1 %22 = phi [^b5, i1 %21] [^b4, i1 true];
    i32 %23 = zext i1 %22 to i32;
    i1 %24 = scmp neq i32 %23, i32 0;
    cbr i1 %24(prob = 0.5), ^if.then3, ^b7;
^if.then3:
    call () -> void @ok();
    ubr ^b7;
^b7:
    store i32* %i with i32 1;
    store i32* %p with i32 0;
    f32* %25 = getelementptr &([10 * f32]* %arr)[i64 0][i64 0];
    store f32* %25 with f32 1;
    f32* %26 = getelementptr &([10 * f32]* %arr)[i64 0][i64 1];
    store f32* %26 with f32 2;
    f32* %27 = getelementptr &([10 * f32]* %arr)[i64 1][i64 0];
    f32* %28 = getelementptr &([10 * f32]* %arr)[i64 0][i64 2];
    store f32* %28 with f32 0;
    f32* %29 = getelementptr &([10 * f32]* %arr)[i64 0][i64 3];
    store f32* %29 with f32 0;
    f32* %30 = getelementptr &([10 * f32]* %arr)[i64 0][i64 4];
    store f32* %30 with f32 0;
    f32* %31 = getelementptr &([10 * f32]* %arr)[i64 0][i64 5];
    store f32* %31 with f32 0;
    f32* %32 = getelementptr &([10 * f32]* %arr)[i64 0][i64 6];
    store f32* %32 with f32 0;
    f32* %33 = getelementptr &([10 * f32]* %arr)[i64 0][i64 7];
    store f32* %33 with f32 0;
    f32* %34 = getelementptr &([10 * f32]* %arr)[i64 0][i64 8];
    store f32* %34 with f32 0;
    f32* %35 = getelementptr &([10 * f32]* %arr)[i64 0][i64 9];
    store f32* %35 with f32 0;
    f32* %36 = getelementptr &([10 * f32]* %arr)[i64 0][i64 0];
    i32 %37 = call (f32*) -> i32 @getfarray(f32* %36);
    store i32* %len with i32 %37;
    ubr ^while.header;
^while.header:
    i32 %38 = load i32* %i;
    i1 %39 = scmp lt i32 %38, i32 1000000000;
    i32 %40 = zext i1 %39 to i32;
    i1 %41 = scmp neq i32 %40, i32 0;
    cbr i1 %41(prob = 0.97), ^while.body, ^b8;
^while.body:
    f32 %42 = call () -> f32 @getfloat();
    store f32* %input with f32 %42;
    f32 %43 = load f32* %input;
    f32 %44 = fmul f32 3.14159, f32 %43;
    f32 %45 = load f32* %input;
    f32 %46 = fmul f32 %44, f32 %45;
    store f32* %area with f32 %46;
    f32 %47 = load f32* %input;
    i32 %48 = f2s f32 %47 to i32;
    f32 %49 = call (i32) -> f32 @circle_area(i32 %48);
    store f32* %area_tru with f32 %49;
    i32 %50 = load i32* %p;
    i64 %51 = sext i32 %50 to i64;
    f32* %52 = getelementptr &([10 * f32]* %arr)[i64 0][i64 %51];
    i32 %53 = load i32* %p;
    i64 %54 = sext i32 %53 to i64;
    f32* %55 = getelementptr &([10 * f32]* %arr)[i64 0][i64 %54];
    f32 %56 = load f32* %55;
    f32 %57 = load f32* %input;
    f32 %58 = fadd f32 %56, f32 %57;
    store f32* %52 with f32 %58;
    f32 %59 = load f32* %area;
    call (f32) -> void @putfloat(f32 %59);
    call (i32) -> void @putch(i32 32);
    f32 %60 = load f32* %area_tru;
    i32 %61 = f2s f32 %60 to i32;
    call (i32) -> void @putint(i32 %61);
    call (i32) -> void @putch(i32 10);
    i32 %62 = load i32* %i;
    f32 %63 = s2f i32 %62 to f32;
    f32 %64 = fmul f32 %63, f32 10;
    i32 %65 = f2s f32 %64 to i32;
    store i32* %i with i32 %65;
    i32 %66 = load i32* %p;
    i32 %67 = add i32 %66, i32 1;
    store i32* %p with i32 %67;
    ubr ^while.header;
^b8:
    i32 %68 = load i32* %len;
    f32* %69 = getelementptr &([10 * f32]* %arr)[i64 0][i64 0];
    call (i32, f32*) -> void @putfarray(i32 %68, f32* %69);
    ret i32 0;
}
internal func @cmmc::Intrinsic::memset() -> i8* { NoMemoryRead };
