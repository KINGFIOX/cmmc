internal func @getint() -> i32 { NoMemoryRead NoMemoryWrite };
internal func @getch() -> i32 { NoMemoryRead NoMemoryWrite };
internal func @getarray() -> i32 { NoMemoryRead };
internal func @getfloat() -> f32 { NoMemoryRead NoMemoryWrite };
internal func @getfarray() -> i32 { NoMemoryRead };
internal func @putint() -> void { NoMemoryRead NoMemoryWrite };
internal func @putch() -> void { NoMemoryRead NoMemoryWrite };
internal func @putarray() -> void { NoMemoryWrite };
internal func @putfloat() -> void { NoMemoryRead NoMemoryWrite };
internal func @putfarray() -> void { NoMemoryWrite };
internal func @starttime() -> void { NoMemoryRead NoMemoryWrite };
internal func @stoptime() -> void { NoMemoryRead NoMemoryWrite };
internal i32* @N { ReadOnly } = 10000;
internal func @long_array(i32 %k) -> i32 {
^entry:
    i32* %j = alloc i32;
    i32* %j1 = alloc i32;
    i32* %ans = alloc i32;
    i32* %i = alloc i32;
    [10000 * i32]* %a3 = alloc [10000 * i32];
    [10000 * i32]* %a2 = alloc [10000 * i32];
    [10000 * i32]* %a1 = alloc [10000 * i32];
    i32* %k1 = alloc i32;
    store i32* %k1 with i32 %k;
    store i32* %i with i32 0;
    ubr ^while.header;
^while.header:
    i32 %0 = load i32* %i;
    i1 %1 = scmp lt i32 %0, i32 10000;
    i32 %2 = zext i1 %1 to i32;
    i1 %3 = scmp neq i32 %2, i32 0;
    cbr i1 %3(prob = 0.97), ^while.body, ^b;
^while.body:
    i32 %4 = load i32* %i;
    i64 %5 = sext i32 %4 to i64;
    i32* %6 = getelementptr &([10000 * i32]* %a1)[i64 0][i64 %5];
    i32 %7 = load i32* %i;
    i32 %8 = load i32* %i;
    i32 %9 = mul i32 %7, i32 %8;
    i32 %10 = srem i32 %9, i32 10;
    store i32* %6 with i32 %10;
    i32 %11 = load i32* %i;
    i32 %12 = add i32 %11, i32 1;
    store i32* %i with i32 %12;
    ubr ^while.header;
^b:
    store i32* %i with i32 0;
    ubr ^while.header1;
^while.header1:
    i32 %13 = load i32* %i;
    i1 %14 = scmp lt i32 %13, i32 10000;
    i32 %15 = zext i1 %14 to i32;
    i1 %16 = scmp neq i32 %15, i32 0;
    cbr i1 %16(prob = 0.97), ^while.body1, ^b1;
^while.body1:
    i32 %17 = load i32* %i;
    i64 %18 = sext i32 %17 to i64;
    i32* %19 = getelementptr &([10000 * i32]* %a2)[i64 0][i64 %18];
    i32 %20 = load i32* %i;
    i64 %21 = sext i32 %20 to i64;
    i32* %22 = getelementptr &([10000 * i32]* %a1)[i64 0][i64 %21];
    i32 %23 = load i32* %22;
    i32 %24 = load i32* %i;
    i64 %25 = sext i32 %24 to i64;
    i32* %26 = getelementptr &([10000 * i32]* %a1)[i64 0][i64 %25];
    i32 %27 = load i32* %26;
    i32 %28 = mul i32 %23, i32 %27;
    i32 %29 = srem i32 %28, i32 10;
    store i32* %19 with i32 %29;
    i32 %30 = load i32* %i;
    i32 %31 = add i32 %30, i32 1;
    store i32* %i with i32 %31;
    ubr ^while.header1;
^b1:
    store i32* %i with i32 0;
    ubr ^while.header2;
^while.header2:
    i32 %32 = load i32* %i;
    i1 %33 = scmp lt i32 %32, i32 10000;
    i32 %34 = zext i1 %33 to i32;
    i1 %35 = scmp neq i32 %34, i32 0;
    cbr i1 %35(prob = 0.97), ^while.body2, ^b2;
^while.body2:
    i32 %36 = load i32* %i;
    i64 %37 = sext i32 %36 to i64;
    i32* %38 = getelementptr &([10000 * i32]* %a3)[i64 0][i64 %37];
    i32 %39 = load i32* %i;
    i64 %40 = sext i32 %39 to i64;
    i32* %41 = getelementptr &([10000 * i32]* %a2)[i64 0][i64 %40];
    i32 %42 = load i32* %41;
    i32 %43 = load i32* %i;
    i64 %44 = sext i32 %43 to i64;
    i32* %45 = getelementptr &([10000 * i32]* %a2)[i64 0][i64 %44];
    i32 %46 = load i32* %45;
    i32 %47 = mul i32 %42, i32 %46;
    i32 %48 = srem i32 %47, i32 100;
    i32 %49 = load i32* %i;
    i64 %50 = sext i32 %49 to i64;
    i32* %51 = getelementptr &([10000 * i32]* %a1)[i64 0][i64 %50];
    i32 %52 = load i32* %51;
    i32 %53 = add i32 %48, i32 %52;
    store i32* %38 with i32 %53;
    i32 %54 = load i32* %i;
    i32 %55 = add i32 %54, i32 1;
    store i32* %i with i32 %55;
    ubr ^while.header2;
^b2:
    store i32* %ans with i32 0;
    store i32* %i with i32 0;
    ubr ^while.header3;
^while.header3:
    i32 %56 = load i32* %i;
    i1 %57 = scmp lt i32 %56, i32 10000;
    i32 %58 = zext i1 %57 to i32;
    i1 %59 = scmp neq i32 %58, i32 0;
    cbr i1 %59(prob = 0.97), ^while.body3, ^b3;
^while.body3:
    i32 %60 = load i32* %i;
    i1 %61 = scmp lt i32 %60, i32 10;
    i32 %62 = zext i1 %61 to i32;
    i1 %63 = scmp neq i32 %62, i32 0;
    cbr i1 %63(prob = 0.5), ^if.then, ^if.else;
^b3:
    i32 %64 = load i32* %ans;
    ret i32 %64;
^if.then:
    i32 %65 = load i32* %ans;
    i32 %66 = load i32* %i;
    i64 %67 = sext i32 %66 to i64;
    i32* %68 = getelementptr &([10000 * i32]* %a3)[i64 0][i64 %67];
    i32 %69 = load i32* %68;
    i32 %70 = add i32 %65, i32 %69;
    i32 %71 = srem i32 %70, i32 1333;
    store i32* %ans with i32 %71;
    i32 %72 = load i32* %ans;
    call (i32) -> void @putint(i32 %72);
    ubr ^b4;
^if.else:
    i32 %73 = load i32* %i;
    i1 %74 = scmp lt i32 %73, i32 20;
    i32 %75 = zext i1 %74 to i32;
    i1 %76 = scmp neq i32 %75, i32 0;
    cbr i1 %76(prob = 0.5), ^if.then1, ^if.else1;
^b4:
    i32 %77 = load i32* %i;
    i32 %78 = add i32 %77, i32 1;
    store i32* %i with i32 %78;
    ubr ^while.header3;
^if.then1:
    store i32* %j1 with i32 5000;
    ubr ^while.header4;
^if.else1:
    i32 %79 = load i32* %i;
    i1 %80 = scmp lt i32 %79, i32 30;
    i32 %81 = zext i1 %80 to i32;
    i1 %82 = scmp neq i32 %81, i32 0;
    cbr i1 %82(prob = 0.5), ^if.then2, ^if.else2;
^if.then2:
    store i32* %j with i32 5000;
    ubr ^while.header5;
^while.header4:
    i32 %83 = load i32* %j1;
    i1 %84 = scmp lt i32 %83, i32 10000;
    i32 %85 = zext i1 %84 to i32;
    i1 %86 = scmp neq i32 %85, i32 0;
    cbr i1 %86(prob = 0.97), ^while.body4, ^b5;
^if.else2:
    i32 %87 = load i32* %ans;
    i32 %88 = load i32* %i;
    i64 %89 = sext i32 %88 to i64;
    i32* %90 = getelementptr &([10000 * i32]* %a3)[i64 0][i64 %89];
    i32 %91 = load i32* %90;
    i32 %92 = load i32* %k1;
    i32 %93 = mul i32 %91, i32 %92;
    i32 %94 = add i32 %87, i32 %93;
    i32 %95 = srem i32 %94, i32 99988;
    store i32* %ans with i32 %95;
    ubr ^b6;
^while.body4:
    i32 %96 = load i32* %ans;
    i32 %97 = load i32* %i;
    i64 %98 = sext i32 %97 to i64;
    i32* %99 = getelementptr &([10000 * i32]* %a3)[i64 0][i64 %98];
    i32 %100 = load i32* %99;
    i32 %101 = add i32 %96, i32 %100;
    i32 %102 = load i32* %j1;
    i64 %103 = sext i32 %102 to i64;
    i32* %104 = getelementptr &([10000 * i32]* %a1)[i64 0][i64 %103];
    i32 %105 = load i32* %104;
    i32 %106 = sub i32 %101, i32 %105;
    store i32* %ans with i32 %106;
    i32 %107 = load i32* %j1;
    i32 %108 = add i32 %107, i32 1;
    store i32* %j1 with i32 %108;
    ubr ^while.header4;
^b5:
    i32 %109 = load i32* %ans;
    call (i32) -> void @putint(i32 %109);
    ubr ^b7;
^b6:
    ubr ^b7;
^while.header5:
    i32 %110 = load i32* %j;
    i1 %111 = scmp lt i32 %110, i32 10000;
    i32 %112 = zext i1 %111 to i32;
    i1 %113 = scmp neq i32 %112, i32 0;
    cbr i1 %113(prob = 0.97), ^while.body5, ^b8;
^b7:
    ubr ^b4;
^b8:
    i32 %114 = load i32* %ans;
    call (i32) -> void @putint(i32 %114);
    ubr ^b6;
^while.body5:
    i32 %115 = load i32* %j;
    i1 %116 = scmp gt i32 %115, i32 2233;
    i32 %117 = zext i1 %116 to i32;
    i1 %118 = scmp neq i32 %117, i32 0;
    cbr i1 %118(prob = 0.5), ^if.then3, ^if.else3;
^if.then3:
    i32 %119 = load i32* %ans;
    i32 %120 = load i32* %i;
    i64 %121 = sext i32 %120 to i64;
    i32* %122 = getelementptr &([10000 * i32]* %a2)[i64 0][i64 %121];
    i32 %123 = load i32* %122;
    i32 %124 = add i32 %119, i32 %123;
    i32 %125 = load i32* %j;
    i64 %126 = sext i32 %125 to i64;
    i32* %127 = getelementptr &([10000 * i32]* %a1)[i64 0][i64 %126];
    i32 %128 = load i32* %127;
    i32 %129 = sub i32 %124, i32 %128;
    store i32* %ans with i32 %129;
    i32 %130 = load i32* %j;
    i32 %131 = add i32 %130, i32 1;
    store i32* %j with i32 %131;
    ubr ^b9;
^if.else3:
    i32 %132 = load i32* %ans;
    i32 %133 = load i32* %i;
    i64 %134 = sext i32 %133 to i64;
    i32* %135 = getelementptr &([10000 * i32]* %a1)[i64 0][i64 %134];
    i32 %136 = load i32* %135;
    i32 %137 = add i32 %132, i32 %136;
    i32 %138 = load i32* %j;
    i64 %139 = sext i32 %138 to i64;
    i32* %140 = getelementptr &([10000 * i32]* %a3)[i64 0][i64 %139];
    i32 %141 = load i32* %140;
    i32 %142 = add i32 %137, i32 %141;
    i32 %143 = srem i32 %142, i32 13333;
    store i32* %ans with i32 %143;
    i32 %144 = load i32* %j;
    i32 %145 = add i32 %144, i32 2;
    store i32* %j with i32 %145;
    ubr ^b9;
^b9:
    ubr ^while.header5;
}
func @main() -> i32 { Entry } {
^entry:
    i32 %0 = call (i32) -> i32 @long_array(i32 9);
    ret i32 %0;
}
