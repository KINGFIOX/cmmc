internal func @putint(i32) -> void { NoMemoryRead NoMemoryWrite };
func @main() -> i32 { NoMemoryRead NoMemoryWrite NoRecurse Entry } {
^entry():
    [10000 * i32]* %a1 = alloc [10000 * i32];
    [10000 * i32]* %a2 = alloc [10000 * i32];
    [10000 * i32]* %a3 = alloc [10000 * i32];
    ubr [ ^while.body [10000 * i32]* %a2, [10000 * i32]* %a3, [10000 * i32]* %a1, i32 0 ];
^while.body([10000 * i32]* %arg, [10000 * i32]* %arg1, [10000 * i32]* %arg2, i32 %arg3):
    i32* %0 = getelementptr &([10000 * i32]* %arg2)[i32 0][i32 %arg3];
    i32 %1 = mul i32 %arg3, i32 %arg3;
    i32 %2 = srem i32 %1, i32 10;
    store i32* %0 with i32 %2;
    i32 %3 = add i32 %arg3, i32 1;
    i1 %4 = scmp lt i32 %3, i32 10000;
    cbr i1 %4, [ ^while.body [10000 * i32]* %arg, [10000 * i32]* %arg1, [10000 * i32]* %arg2, i32 %3 ], [ ^while.body1 [10000 * i32]* %arg1, [10000 * i32]* %arg2, [10000 * i32]* %arg, i32 0 ];
^while.body1([10000 * i32]* %arg, [10000 * i32]* %arg1, [10000 * i32]* %arg2, i32 %arg3):
    i32* %0 = getelementptr &([10000 * i32]* %arg2)[i32 0][i32 %arg3];
    i32* %1 = getelementptr &([10000 * i32]* %arg1)[i32 0][i32 %arg3];
    i32 %2 = load i32* %1;
    i32 %3 = mul i32 %2, i32 %2;
    i32 %4 = srem i32 %3, i32 10;
    store i32* %0 with i32 %4;
    i32 %5 = add i32 %arg3, i32 1;
    i1 %6 = scmp lt i32 %5, i32 10000;
    cbr i1 %6, [ ^while.body1 [10000 * i32]* %arg, [10000 * i32]* %arg1, [10000 * i32]* %arg2, i32 %5 ], [ ^while.body2 [10000 * i32]* %arg1, [10000 * i32]* %arg2, [10000 * i32]* %arg, i32 0 ];
^while.body2([10000 * i32]* %arg, [10000 * i32]* %arg1, [10000 * i32]* %arg2, i32 %arg3):
    i32* %0 = getelementptr &([10000 * i32]* %arg2)[i32 0][i32 %arg3];
    i32* %1 = getelementptr &([10000 * i32]* %arg1)[i32 0][i32 %arg3];
    i32 %2 = load i32* %1;
    i32 %3 = mul i32 %2, i32 %2;
    i32 %4 = srem i32 %3, i32 100;
    i32* %5 = getelementptr &([10000 * i32]* %arg)[i32 0][i32 %arg3];
    i32 %6 = load i32* %5;
    i32 %7 = add i32 %4, i32 %6;
    store i32* %0 with i32 %7;
    i32 %8 = add i32 %arg3, i32 1;
    i1 %9 = scmp lt i32 %8, i32 10000;
    cbr i1 %9, [ ^while.body2 [10000 * i32]* %arg, [10000 * i32]* %arg1, [10000 * i32]* %arg2, i32 %8 ], [ ^while.body3 [10000 * i32]* %arg, [10000 * i32]* %arg1, [10000 * i32]* %arg2, i32 0, i32 0 ];
^while.body3([10000 * i32]* %arg, [10000 * i32]* %arg1, [10000 * i32]* %arg2, i32 %arg3, i32 %arg4):
    i1 %0 = scmp lt i32 %arg3, i32 10;
    cbr i1 %0, [ ^indirect [10000 * i32]* %arg1, [10000 * i32]* %arg, [10000 * i32]* %arg2, i32 %arg3, i32 %arg3, i32 %arg4 ], [ ^indirect1 [10000 * i32]* %arg1, [10000 * i32]* %arg2, [10000 * i32]* %arg, i32 %arg3, i32 %arg3, i32 %arg4 ];
^indirect([10000 * i32]* %arg, [10000 * i32]* %arg1, [10000 * i32]* %arg2, i32 %arg3, i32 %arg4, i32 %arg5):
    i32* %0 = getelementptr &([10000 * i32]* %arg2)[i32 0][i32 %arg3];
    i32 %1 = load i32* %0;
    i32 %2 = add i32 %arg5, i32 %1;
    i32 %3 = srem i32 %2, i32 1333;
    call (i32) -> void @putint(i32 %3);
    i32 %4 = add i32 %arg4, i32 1;
    i1 %5 = scmp lt i32 %4, i32 10000;
    cbr i1 %5, [ ^while.body3 [10000 * i32]* %arg1, [10000 * i32]* %arg, [10000 * i32]* %arg2, i32 %4, i32 %3 ], [ ^b i32 %3 ];
^indirect1([10000 * i32]* %arg, [10000 * i32]* %arg1, [10000 * i32]* %arg2, i32 %arg3, i32 %arg4, i32 %arg5):
    i1 %0 = scmp lt i32 %arg3, i32 20;
    cbr i1 %0, [ ^if.then [10000 * i32]* %arg, [10000 * i32]* %arg2, [10000 * i32]* %arg1, i32 %arg4, i32 %arg5 ], [ ^if.else [10000 * i32]* %arg2, [10000 * i32]* %arg, [10000 * i32]* %arg1, i32 %arg4, i32 %arg5 ];
^if.then([10000 * i32]* %arg, [10000 * i32]* %arg1, [10000 * i32]* %arg2, i32 %arg3, i32 %arg4):
    i32* %j = alloc i32;
    ubr [ ^while.body4 i32* %j, [10000 * i32]* %arg, [10000 * i32]* %arg1, [10000 * i32]* %arg2, i32 %arg3, i32 %arg4, i32 5000 ];
^if.else([10000 * i32]* %arg, [10000 * i32]* %arg1, [10000 * i32]* %arg2, i32 %arg3, i32 %arg4):
    i1 %0 = scmp lt i32 %arg3, i32 30;
    cbr i1 %0, [ ^if.then1 [10000 * i32]* %arg2, [10000 * i32]* %arg1, [10000 * i32]* %arg, i32 %arg3, i32 %arg4 ], [ ^indirect2 [10000 * i32]* %arg1, [10000 * i32]* %arg, [10000 * i32]* %arg2, i32 %arg3, i32 %arg4 ];
^b(i32 %arg):
    ret i32 %arg;
^if.then1([10000 * i32]* %arg, [10000 * i32]* %arg1, [10000 * i32]* %arg2, i32 %arg3, i32 %arg4):
    i32* %j = alloc i32;
    ubr [ ^while.body5 [10000 * i32]* %arg, [10000 * i32]* %arg1, [10000 * i32]* %arg2, i32* %j, i32 %arg3, i32 %arg4, i32 5000 ];
^while.body4(i32* %arg, [10000 * i32]* %arg1, [10000 * i32]* %arg2, [10000 * i32]* %arg3, i32 %arg4, i32 %arg5, i32 %arg6):
    i32* %0 = getelementptr &([10000 * i32]* %arg3)[i32 0][i32 %arg4];
    i32 %1 = load i32* %0;
    i32 %2 = add i32 %arg5, i32 %1;
    i32* %3 = getelementptr &([10000 * i32]* %arg2)[i32 0][i32 %arg6];
    i32 %4 = load i32* %3;
    i32 %5 = sub i32 %2, i32 %4;
    i32 %6 = add i32 %arg6, i32 1;
    i1 %7 = scmp lt i32 %6, i32 10000;
    cbr i1 %7, [ ^while.body4 i32* %arg, [10000 * i32]* %arg1, [10000 * i32]* %arg2, [10000 * i32]* %arg3, i32 %arg4, i32 %5, i32 %6 ], [ ^b1 [10000 * i32]* %arg2, [10000 * i32]* %arg1, [10000 * i32]* %arg3, i32* %arg, i32 %arg4, i32 %5 ];
^indirect2([10000 * i32]* %arg, [10000 * i32]* %arg1, [10000 * i32]* %arg2, i32 %arg3, i32 %arg4):
    i32* %0 = getelementptr &([10000 * i32]* %arg2)[i32 0][i32 %arg3];
    i32 %1 = load i32* %0;
    i32 %2 = mul i32 %1, i32 9;
    i32 %3 = add i32 %arg4, i32 %2;
    i32 %4 = srem i32 %3, i32 99988;
    i32 %5 = add i32 %arg3, i32 1;
    i1 %6 = scmp lt i32 %5, i32 10000;
    cbr i1 %6, [ ^while.body3 [10000 * i32]* %arg1, [10000 * i32]* %arg, [10000 * i32]* %arg2, i32 %5, i32 %4 ], [ ^b i32 %4 ];
^b1([10000 * i32]* %arg, [10000 * i32]* %arg1, [10000 * i32]* %arg2, i32* %arg3, i32 %arg4, i32 %arg5):
    call (i32) -> void @putint(i32 %arg5);
    free i32* %arg3;
    i32 %0 = add i32 %arg4, i32 1;
    ubr [ ^while.header [10000 * i32]* %arg2, [10000 * i32]* %arg1, [10000 * i32]* %arg, i32 %0, i32 %0, i32 %arg5 ];
^while.body5([10000 * i32]* %arg, [10000 * i32]* %arg1, [10000 * i32]* %arg2, i32* %arg3, i32 %arg4, i32 %arg5, i32 %arg6):
    i1 %0 = scmp gt i32 %arg6, i32 2233;
    cbr i1 %0, [ ^indirect3 i32* %arg3, [10000 * i32]* %arg, [10000 * i32]* %arg2, [10000 * i32]* %arg1, i32 %arg6, i32 %arg4, i32 %arg5 ], [ ^indirect4 i32* %arg3, [10000 * i32]* %arg1, [10000 * i32]* %arg, [10000 * i32]* %arg2, i32 %arg6, i32 %arg4, i32 %arg5 ];
^while.header([10000 * i32]* %arg, [10000 * i32]* %arg1, [10000 * i32]* %arg2, i32 %arg3, i32 %arg4, i32 %arg5):
    i1 %0 = scmp lt i32 %arg3, i32 10000;
    cbr i1 %0, [ ^while.body3 [10000 * i32]* %arg2, [10000 * i32]* %arg1, [10000 * i32]* %arg, i32 %arg4, i32 %arg5 ], [ ^b i32 %arg5 ];
^indirect3(i32* %arg, [10000 * i32]* %arg1, [10000 * i32]* %arg2, [10000 * i32]* %arg3, i32 %arg4, i32 %arg5, i32 %arg6):
    i32* %0 = getelementptr &([10000 * i32]* %arg3)[i32 0][i32 %arg5];
    i32 %1 = load i32* %0;
    i32 %2 = add i32 %arg6, i32 %1;
    i32* %3 = getelementptr &([10000 * i32]* %arg2)[i32 0][i32 %arg4];
    i32 %4 = load i32* %3;
    i32 %5 = sub i32 %2, i32 %4;
    i32 %6 = add i32 %arg4, i32 1;
    i1 %7 = scmp lt i32 %6, i32 10000;
    cbr i1 %7, [ ^while.body5 [10000 * i32]* %arg1, [10000 * i32]* %arg3, [10000 * i32]* %arg2, i32* %arg, i32 %arg5, i32 %5, i32 %6 ], [ ^b2 [10000 * i32]* %arg1, [10000 * i32]* %arg3, [10000 * i32]* %arg2, i32* %arg, i32 %arg5, i32 %5 ];
^indirect4(i32* %arg, [10000 * i32]* %arg1, [10000 * i32]* %arg2, [10000 * i32]* %arg3, i32 %arg4, i32 %arg5, i32 %arg6):
    i32* %0 = getelementptr &([10000 * i32]* %arg3)[i32 0][i32 %arg5];
    i32 %1 = load i32* %0;
    i32 %2 = add i32 %arg6, i32 %1;
    i32* %3 = getelementptr &([10000 * i32]* %arg2)[i32 0][i32 %arg4];
    i32 %4 = load i32* %3;
    i32 %5 = add i32 %2, i32 %4;
    i32 %6 = srem i32 %5, i32 13333;
    i32 %7 = add i32 %arg4, i32 2;
    i1 %8 = scmp lt i32 %7, i32 10000;
    cbr i1 %8, [ ^while.body5 [10000 * i32]* %arg2, [10000 * i32]* %arg1, [10000 * i32]* %arg3, i32* %arg, i32 %arg5, i32 %6, i32 %7 ], [ ^b2 [10000 * i32]* %arg2, [10000 * i32]* %arg1, [10000 * i32]* %arg3, i32* %arg, i32 %arg5, i32 %6 ];
^b2([10000 * i32]* %arg, [10000 * i32]* %arg1, [10000 * i32]* %arg2, i32* %arg3, i32 %arg4, i32 %arg5):
    call (i32) -> void @putint(i32 %arg5);
    free i32* %arg3;
    i32 %0 = add i32 %arg4, i32 1;
    ubr [ ^while.header [10000 * i32]* %arg, [10000 * i32]* %arg1, [10000 * i32]* %arg2, i32 %0, i32 %0, i32 %arg5 ];
}
