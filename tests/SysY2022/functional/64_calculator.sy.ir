internal func @getint() -> i32 { NoMemoryRead NoMemoryWrite };
internal func @getch() -> i32 { NoMemoryRead NoMemoryWrite };
internal func @getarray() -> i32 { NoMemoryRead };
internal func @getfloat() -> f32 { NoMemoryRead NoMemoryWrite };
internal func @getfarray() -> i32 { NoMemoryRead };
internal func @putint() -> void { NoMemoryRead NoMemoryWrite };
internal func @putch() -> void { NoMemoryRead NoMemoryWrite };
internal func @putarray() -> void { NoMemoryWrite };
internal func @putfloat() -> void { NoMemoryRead NoMemoryWrite };
internal func @putfarray() -> void { NoMemoryWrite };
internal func @starttime() -> void { NoMemoryRead NoMemoryWrite };
internal func @stoptime() -> void { NoMemoryRead NoMemoryWrite };
internal [10000 * i32]* @ints;
internal i32* @intt;
internal [10000 * i32]* @chas;
internal i32* @chat;
internal i32* @i = 0;
internal i32* @ii = 1;
internal i32* @c;
internal [10000 * i32]* @get;
internal [10000 * i32]* @get2;
internal func @isdigit(i32 %x) -> i32 {
^entry:
    i32* %x1 = alloc i32;
    store i32* %x1 with i32 %x;
    i32 %0 = load i32* %x1;
    i1 %1 = scmp ge i32 %0, i32 48;
    i32 %2 = zext i1 %1 to i32;
    i1 %3 = scmp neq i32 %2, i32 0;
    cbr i1 %3(prob = 0.5), ^b, ^b1;
^b:
    i32 %4 = load i32* %x1;
    i1 %5 = scmp le i32 %4, i32 57;
    i32 %6 = zext i1 %5 to i32;
    i1 %7 = scmp neq i32 %6, i32 0;
    ubr ^b1;
^b1:
    i1 %8 = phi [^b, i1 %7] [^entry, i1 false];
    i32 %9 = zext i1 %8 to i32;
    i1 %10 = scmp neq i32 %9, i32 0;
    cbr i1 %10(prob = 0.5), ^if.then, ^b2;
^if.then:
    ret i32 1;
^b2:
    ret i32 0;
}
internal func @power(i32 %b, i32 %a) -> i32 {
^entry:
    i32* %result = alloc i32;
    i32* %a1 = alloc i32;
    i32* %b1 = alloc i32;
    store i32* %b1 with i32 %b;
    store i32* %a1 with i32 %a;
    store i32* %result with i32 1;
    ubr ^while.header;
^while.header:
    i32 %0 = load i32* %a1;
    i1 %1 = scmp neq i32 %0, i32 0;
    i32 %2 = zext i1 %1 to i32;
    i1 %3 = scmp neq i32 %2, i32 0;
    cbr i1 %3(prob = 0.97), ^while.body, ^b2;
^while.body:
    i32 %4 = load i32* %result;
    i32 %5 = load i32* %b1;
    i32 %6 = mul i32 %4, i32 %5;
    store i32* %result with i32 %6;
    i32 %7 = load i32* %a1;
    i32 %8 = sub i32 %7, i32 1;
    store i32* %a1 with i32 %8;
    ubr ^while.header;
^b2:
    i32 %9 = load i32* %result;
    ret i32 %9;
}
internal func @getstr(i32* %get) -> i32 {
^entry:
    i32* %length = alloc i32;
    i32* %x = alloc i32;
    i32** %get1 = alloc i32*;
    store i32** %get1 with i32* %get;
    i32 %0 = call () -> i32 @getch();
    store i32* %x with i32 %0;
    store i32* %length with i32 0;
    ubr ^while.header;
^while.header:
    i32 %1 = load i32* %x;
    i1 %2 = scmp neq i32 %1, i32 13;
    i32 %3 = zext i1 %2 to i32;
    i1 %4 = scmp neq i32 %3, i32 0;
    cbr i1 %4(prob = 0.5), ^b, ^b1;
^b:
    i32 %5 = load i32* %x;
    i1 %6 = scmp neq i32 %5, i32 10;
    i32 %7 = zext i1 %6 to i32;
    i1 %8 = scmp neq i32 %7, i32 0;
    ubr ^b1;
^b1:
    i1 %9 = phi [^b, i1 %8] [^while.header, i1 false];
    i32 %10 = zext i1 %9 to i32;
    i1 %11 = scmp neq i32 %10, i32 0;
    cbr i1 %11(prob = 0.97), ^while.body, ^b2;
^while.body:
    i32 %12 = load i32* %length;
    i64 %13 = sext i32 %12 to i64;
    i32* %14 = load i32** %get1;
    i32* %15 = getelementptr &(i32* %14)[i64 %13];
    i32 %16 = load i32* %x;
    store i32* %15 with i32 %16;
    i32 %17 = load i32* %length;
    i32 %18 = add i32 %17, i32 1;
    store i32* %length with i32 %18;
    i32 %19 = call () -> i32 @getch();
    store i32* %x with i32 %19;
    ubr ^while.header;
^b2:
    i32 %20 = load i32* %length;
    ret i32 %20;
}
internal func @intpush(i32 %x) -> void {
^entry:
    i32* %x1 = alloc i32;
    store i32* %x1 with i32 %x;
    i32 %0 = load i32* @intt;
    i32 %1 = add i32 %0, i32 1;
    store i32* @intt with i32 %1;
    i32 %2 = load i32* @intt;
    i64 %3 = sext i32 %2 to i64;
    i32* %4 = getelementptr &([10000 * i32]* @ints)[i64 0][i64 %3];
    i32 %5 = load i32* %x1;
    store i32* %4 with i32 %5;
    ret;
}
internal func @chapush(i32 %x) -> void {
^entry:
    i32* %x1 = alloc i32;
    store i32* %x1 with i32 %x;
    i32 %0 = load i32* @chat;
    i32 %1 = add i32 %0, i32 1;
    store i32* @chat with i32 %1;
    i32 %2 = load i32* @chat;
    i64 %3 = sext i32 %2 to i64;
    i32* %4 = getelementptr &([10000 * i32]* @chas)[i64 0][i64 %3];
    i32 %5 = load i32* %x1;
    store i32* %4 with i32 %5;
    ret;
}
internal func @intpop() -> i32 {
^entry:
    i32 %0 = load i32* @intt;
    i32 %1 = sub i32 %0, i32 1;
    store i32* @intt with i32 %1;
    i32 %2 = load i32* @intt;
    i32 %3 = add i32 %2, i32 1;
    i64 %4 = sext i32 %3 to i64;
    i32* %5 = getelementptr &([10000 * i32]* @ints)[i64 0][i64 %4];
    i32 %6 = load i32* %5;
    ret i32 %6;
}
internal func @chapop() -> i32 {
^entry:
    i32 %0 = load i32* @chat;
    i32 %1 = sub i32 %0, i32 1;
    store i32* @chat with i32 %1;
    i32 %2 = load i32* @chat;
    i32 %3 = add i32 %2, i32 1;
    i64 %4 = sext i32 %3 to i64;
    i32* %5 = getelementptr &([10000 * i32]* @chas)[i64 0][i64 %4];
    i32 %6 = load i32* %5;
    ret i32 %6;
}
internal func @intadd(i32 %x) -> void {
^entry:
    i32* %x1 = alloc i32;
    store i32* %x1 with i32 %x;
    i32 %0 = load i32* @intt;
    i64 %1 = sext i32 %0 to i64;
    i32* %2 = getelementptr &([10000 * i32]* @ints)[i64 0][i64 %1];
    i32 %3 = load i32* @intt;
    i64 %4 = sext i32 %3 to i64;
    i32* %5 = getelementptr &([10000 * i32]* @ints)[i64 0][i64 %4];
    i32 %6 = load i32* %5;
    i32 %7 = mul i32 %6, i32 10;
    store i32* %2 with i32 %7;
    i32 %8 = load i32* @intt;
    i64 %9 = sext i32 %8 to i64;
    i32* %10 = getelementptr &([10000 * i32]* @ints)[i64 0][i64 %9];
    i32 %11 = load i32* @intt;
    i64 %12 = sext i32 %11 to i64;
    i32* %13 = getelementptr &([10000 * i32]* @ints)[i64 0][i64 %12];
    i32 %14 = load i32* %13;
    i32 %15 = load i32* %x1;
    i32 %16 = add i32 %14, i32 %15;
    store i32* %10 with i32 %16;
    ret;
}
internal func @find() -> i32 {
^entry:
    i32 %0 = call () -> i32 @chapop();
    store i32* @c with i32 %0;
    i32 %1 = load i32* @ii;
    i64 %2 = sext i32 %1 to i64;
    i32* %3 = getelementptr &([10000 * i32]* @get2)[i64 0][i64 %2];
    store i32* %3 with i32 32;
    i32 %4 = load i32* @ii;
    i32 %5 = add i32 %4, i32 1;
    i64 %6 = sext i32 %5 to i64;
    i32* %7 = getelementptr &([10000 * i32]* @get2)[i64 0][i64 %6];
    i32 %8 = load i32* @c;
    store i32* %7 with i32 %8;
    i32 %9 = load i32* @ii;
    i32 %10 = add i32 %9, i32 2;
    store i32* @ii with i32 %10;
    i32 %11 = load i32* @chat;
    i1 %12 = scmp eq i32 %11, i32 0;
    i32 %13 = zext i1 %12 to i32;
    i1 %14 = scmp neq i32 %13, i32 0;
    cbr i1 %14(prob = 0.5), ^if.then, ^b;
^if.then:
    ret i32 0;
^b:
    ret i32 1;
}
func @main() -> i32 { Entry } {
^entry:
    i32* %c = alloc i32;
    i32* %b = alloc i32;
    i32* %a = alloc i32;
    i32* %c1 = alloc i32;
    i32* %lengets = alloc i32;
    store i32* @intt with i32 0;
    store i32* @chat with i32 0;
    i32* %0 = getelementptr &([10000 * i32]* @get)[i64 0][i64 0];
    i32 %1 = call (i32*) -> i32 @getstr(i32* %0);
    store i32* %lengets with i32 %1;
    ubr ^while.header;
^while.header:
    i32 %2 = load i32* @i;
    i32 %3 = load i32* %lengets;
    i1 %4 = scmp lt i32 %2, i32 %3;
    i32 %5 = zext i1 %4 to i32;
    i1 %6 = scmp neq i32 %5, i32 0;
    cbr i1 %6(prob = 0.97), ^while.body, ^b1;
^b1:
    ubr ^while.header1;
^while.body:
    i32 %7 = load i32* @i;
    i64 %8 = sext i32 %7 to i64;
    i32* %9 = getelementptr &([10000 * i32]* @get)[i64 0][i64 %8];
    i32 %10 = load i32* %9;
    i32 %11 = call (i32) -> i32 @isdigit(i32 %10);
    i1 %12 = scmp eq i32 %11, i32 1;
    i32 %13 = zext i1 %12 to i32;
    i1 %14 = scmp neq i32 %13, i32 0;
    cbr i1 %14(prob = 0.5), ^if.then, ^if.else;
^if.then:
    i32 %15 = load i32* @ii;
    i64 %16 = sext i32 %15 to i64;
    i32* %17 = getelementptr &([10000 * i32]* @get2)[i64 0][i64 %16];
    i32 %18 = load i32* @i;
    i64 %19 = sext i32 %18 to i64;
    i32* %20 = getelementptr &([10000 * i32]* @get)[i64 0][i64 %19];
    i32 %21 = load i32* %20;
    store i32* %17 with i32 %21;
    i32 %22 = load i32* @ii;
    i32 %23 = add i32 %22, i32 1;
    store i32* @ii with i32 %23;
    ubr ^b2;
^if.else:
    i32 %24 = load i32* @i;
    i64 %25 = sext i32 %24 to i64;
    i32* %26 = getelementptr &([10000 * i32]* @get)[i64 0][i64 %25];
    i32 %27 = load i32* %26;
    i1 %28 = scmp eq i32 %27, i32 40;
    i32 %29 = zext i1 %28 to i32;
    i1 %30 = scmp neq i32 %29, i32 0;
    cbr i1 %30(prob = 0.5), ^if.then1, ^b4;
^while.header1:
    i32 %31 = load i32* @chat;
    i1 %32 = scmp gt i32 %31, i32 0;
    i32 %33 = zext i1 %32 to i32;
    i1 %34 = scmp neq i32 %33, i32 0;
    cbr i1 %34(prob = 0.97), ^while.body1, ^b3;
^b2:
    i32 %35 = load i32* @i;
    i32 %36 = add i32 %35, i32 1;
    store i32* @i with i32 %36;
    ubr ^while.header;
^if.then1:
    call (i32) -> void @chapush(i32 40);
    ubr ^b4;
^while.body1:
    i32 %37 = call () -> i32 @chapop();
    store i32* %c1 with i32 %37;
    i32 %38 = load i32* @ii;
    i64 %39 = sext i32 %38 to i64;
    i32* %40 = getelementptr &([10000 * i32]* @get2)[i64 0][i64 %39];
    store i32* %40 with i32 32;
    i32 %41 = load i32* @ii;
    i32 %42 = add i32 %41, i32 1;
    i64 %43 = sext i32 %42 to i64;
    i32* %44 = getelementptr &([10000 * i32]* @get2)[i64 0][i64 %43];
    i32 %45 = load i32* %c1;
    store i32* %44 with i32 %45;
    i32 %46 = load i32* @ii;
    i32 %47 = add i32 %46, i32 2;
    store i32* @ii with i32 %47;
    ubr ^while.header1;
^b3:
    i32 %48 = load i32* @ii;
    i64 %49 = sext i32 %48 to i64;
    i32* %50 = getelementptr &([10000 * i32]* @get2)[i64 0][i64 %49];
    store i32* %50 with i32 64;
    store i32* @i with i32 1;
    ubr ^while.header2;
^b4:
    i32 %51 = load i32* @i;
    i64 %52 = sext i32 %51 to i64;
    i32* %53 = getelementptr &([10000 * i32]* @get)[i64 0][i64 %52];
    i32 %54 = load i32* %53;
    i1 %55 = scmp eq i32 %54, i32 94;
    i32 %56 = zext i1 %55 to i32;
    i1 %57 = scmp neq i32 %56, i32 0;
    cbr i1 %57(prob = 0.5), ^if.then2, ^b5;
^if.then2:
    call (i32) -> void @chapush(i32 94);
    ubr ^b5;
^while.header2:
    i32 %58 = load i32* @i;
    i64 %59 = sext i32 %58 to i64;
    i32* %60 = getelementptr &([10000 * i32]* @get2)[i64 0][i64 %59];
    i32 %61 = load i32* %60;
    i1 %62 = scmp neq i32 %61, i32 64;
    i32 %63 = zext i1 %62 to i32;
    i1 %64 = scmp neq i32 %63, i32 0;
    cbr i1 %64(prob = 0.97), ^while.body2, ^b7;
^b5:
    i32 %65 = load i32* @i;
    i64 %66 = sext i32 %65 to i64;
    i32* %67 = getelementptr &([10000 * i32]* @get)[i64 0][i64 %66];
    i32 %68 = load i32* %67;
    i1 %69 = scmp eq i32 %68, i32 41;
    i32 %70 = zext i1 %69 to i32;
    i1 %71 = scmp neq i32 %70, i32 0;
    cbr i1 %71(prob = 0.5), ^if.then3, ^b6;
^if.then3:
    i32 %72 = call () -> i32 @chapop();
    store i32* @c with i32 %72;
    ubr ^while.header3;
^while.body2:
    i32 %73 = load i32* @i;
    i64 %74 = sext i32 %73 to i64;
    i32* %75 = getelementptr &([10000 * i32]* @get2)[i64 0][i64 %74];
    i32 %76 = load i32* %75;
    i1 %77 = scmp eq i32 %76, i32 43;
    i32 %78 = zext i1 %77 to i32;
    i1 %79 = scmp neq i32 %78, i32 0;
    cbr i1 %79(prob = 0.5), ^b9, ^b8;
^b6:
    i32 %80 = load i32* @i;
    i64 %81 = sext i32 %80 to i64;
    i32* %82 = getelementptr &([10000 * i32]* @get)[i64 0][i64 %81];
    i32 %83 = load i32* %82;
    i1 %84 = scmp eq i32 %83, i32 43;
    i32 %85 = zext i1 %84 to i32;
    i1 %86 = scmp neq i32 %85, i32 0;
    cbr i1 %86(prob = 0.5), ^if.then4, ^b10;
^b7:
    i32* %87 = getelementptr &([10000 * i32]* @ints)[i64 0][i64 1];
    i32 %88 = load i32* %87;
    call (i32) -> void @putint(i32 %88);
    ret i32 0;
^b8:
    i32 %89 = load i32* @i;
    i64 %90 = sext i32 %89 to i64;
    i32* %91 = getelementptr &([10000 * i32]* @get2)[i64 0][i64 %90];
    i32 %92 = load i32* %91;
    i1 %93 = scmp eq i32 %92, i32 45;
    i32 %94 = zext i1 %93 to i32;
    i1 %95 = scmp neq i32 %94, i32 0;
    ubr ^b9;
^if.then4:
    ubr ^while.header4;
^b9:
    i1 %96 = phi [^b8, i1 %95] [^while.body2, i1 true];
    i32 %97 = zext i1 %96 to i32;
    i1 %98 = scmp neq i32 %97, i32 0;
    cbr i1 %98(prob = 0.5), ^b13, ^b11;
^while.header3:
    i32 %99 = load i32* @c;
    i1 %100 = scmp neq i32 %99, i32 40;
    i32 %101 = zext i1 %100 to i32;
    i1 %102 = scmp neq i32 %101, i32 0;
    cbr i1 %102(prob = 0.97), ^while.body3, ^b12;
^b10:
    i32 %103 = load i32* @i;
    i64 %104 = sext i32 %103 to i64;
    i32* %105 = getelementptr &([10000 * i32]* @get)[i64 0][i64 %104];
    i32 %106 = load i32* %105;
    i1 %107 = scmp eq i32 %106, i32 45;
    i32 %108 = zext i1 %107 to i32;
    i1 %109 = scmp neq i32 %108, i32 0;
    cbr i1 %109(prob = 0.5), ^if.then5, ^b14;
^while.body3:
    i32 %110 = load i32* @ii;
    i64 %111 = sext i32 %110 to i64;
    i32* %112 = getelementptr &([10000 * i32]* @get2)[i64 0][i64 %111];
    store i32* %112 with i32 32;
    i32 %113 = load i32* @ii;
    i32 %114 = add i32 %113, i32 1;
    i64 %115 = sext i32 %114 to i64;
    i32* %116 = getelementptr &([10000 * i32]* @get2)[i64 0][i64 %115];
    i32 %117 = load i32* @c;
    store i32* %116 with i32 %117;
    i32 %118 = load i32* @ii;
    i32 %119 = add i32 %118, i32 2;
    store i32* @ii with i32 %119;
    i32 %120 = call () -> i32 @chapop();
    store i32* @c with i32 %120;
    ubr ^while.header3;
^b11:
    i32 %121 = load i32* @i;
    i64 %122 = sext i32 %121 to i64;
    i32* %123 = getelementptr &([10000 * i32]* @get2)[i64 0][i64 %122];
    i32 %124 = load i32* %123;
    i1 %125 = scmp eq i32 %124, i32 42;
    i32 %126 = zext i1 %125 to i32;
    i1 %127 = scmp neq i32 %126, i32 0;
    ubr ^b13;
^b12:
    ubr ^b6;
^b13:
    i1 %128 = phi [^b11, i1 %127] [^b9, i1 true];
    i32 %129 = zext i1 %128 to i32;
    i1 %130 = scmp neq i32 %129, i32 0;
    cbr i1 %130(prob = 0.5), ^b16, ^b15;
^if.then5:
    ubr ^while.header5;
^while.header4:
    i32 %131 = load i32* @chat;
    i64 %132 = sext i32 %131 to i64;
    i32* %133 = getelementptr &([10000 * i32]* @chas)[i64 0][i64 %132];
    i32 %134 = load i32* %133;
    i1 %135 = scmp eq i32 %134, i32 43;
    i32 %136 = zext i1 %135 to i32;
    i1 %137 = scmp neq i32 %136, i32 0;
    cbr i1 %137(prob = 0.5), ^b18, ^b17;
^b14:
    i32 %138 = load i32* @i;
    i64 %139 = sext i32 %138 to i64;
    i32* %140 = getelementptr &([10000 * i32]* @get)[i64 0][i64 %139];
    i32 %141 = load i32* %140;
    i1 %142 = scmp eq i32 %141, i32 42;
    i32 %143 = zext i1 %142 to i32;
    i1 %144 = scmp neq i32 %143, i32 0;
    cbr i1 %144(prob = 0.5), ^if.then6, ^b19;
^b15:
    i32 %145 = load i32* @i;
    i64 %146 = sext i32 %145 to i64;
    i32* %147 = getelementptr &([10000 * i32]* @get2)[i64 0][i64 %146];
    i32 %148 = load i32* %147;
    i1 %149 = scmp eq i32 %148, i32 47;
    i32 %150 = zext i1 %149 to i32;
    i1 %151 = scmp neq i32 %150, i32 0;
    ubr ^b16;
^b16:
    i1 %152 = phi [^b15, i1 %151] [^b13, i1 true];
    i32 %153 = zext i1 %152 to i32;
    i1 %154 = scmp neq i32 %153, i32 0;
    cbr i1 %154(prob = 0.5), ^b21, ^b20;
^b17:
    i32 %155 = load i32* @chat;
    i64 %156 = sext i32 %155 to i64;
    i32* %157 = getelementptr &([10000 * i32]* @chas)[i64 0][i64 %156];
    i32 %158 = load i32* %157;
    i1 %159 = scmp eq i32 %158, i32 45;
    i32 %160 = zext i1 %159 to i32;
    i1 %161 = scmp neq i32 %160, i32 0;
    ubr ^b18;
^b18:
    i1 %162 = phi [^b17, i1 %161] [^while.header4, i1 true];
    i32 %163 = zext i1 %162 to i32;
    i1 %164 = scmp neq i32 %163, i32 0;
    cbr i1 %164(prob = 0.5), ^b23, ^b22;
^if.then6:
    ubr ^while.header6;
^while.header5:
    i32 %165 = load i32* @chat;
    i64 %166 = sext i32 %165 to i64;
    i32* %167 = getelementptr &([10000 * i32]* @chas)[i64 0][i64 %166];
    i32 %168 = load i32* %167;
    i1 %169 = scmp eq i32 %168, i32 43;
    i32 %170 = zext i1 %169 to i32;
    i1 %171 = scmp neq i32 %170, i32 0;
    cbr i1 %171(prob = 0.5), ^b25, ^b24;
^b19:
    i32 %172 = load i32* @i;
    i64 %173 = sext i32 %172 to i64;
    i32* %174 = getelementptr &([10000 * i32]* @get)[i64 0][i64 %173];
    i32 %175 = load i32* %174;
    i1 %176 = scmp eq i32 %175, i32 47;
    i32 %177 = zext i1 %176 to i32;
    i1 %178 = scmp neq i32 %177, i32 0;
    cbr i1 %178(prob = 0.5), ^if.then7, ^b26;
^b20:
    i32 %179 = load i32* @i;
    i64 %180 = sext i32 %179 to i64;
    i32* %181 = getelementptr &([10000 * i32]* @get2)[i64 0][i64 %180];
    i32 %182 = load i32* %181;
    i1 %183 = scmp eq i32 %182, i32 37;
    i32 %184 = zext i1 %183 to i32;
    i1 %185 = scmp neq i32 %184, i32 0;
    ubr ^b21;
^b21:
    i1 %186 = phi [^b20, i1 %185] [^b16, i1 true];
    i32 %187 = zext i1 %186 to i32;
    i1 %188 = scmp neq i32 %187, i32 0;
    cbr i1 %188(prob = 0.5), ^b28, ^b27;
^b22:
    i32 %189 = load i32* @chat;
    i64 %190 = sext i32 %189 to i64;
    i32* %191 = getelementptr &([10000 * i32]* @chas)[i64 0][i64 %190];
    i32 %192 = load i32* %191;
    i1 %193 = scmp eq i32 %192, i32 42;
    i32 %194 = zext i1 %193 to i32;
    i1 %195 = scmp neq i32 %194, i32 0;
    ubr ^b23;
^b23:
    i1 %196 = phi [^b22, i1 %195] [^b18, i1 true];
    i32 %197 = zext i1 %196 to i32;
    i1 %198 = scmp neq i32 %197, i32 0;
    cbr i1 %198(prob = 0.5), ^b30, ^b29;
^b24:
    i32 %199 = load i32* @chat;
    i64 %200 = sext i32 %199 to i64;
    i32* %201 = getelementptr &([10000 * i32]* @chas)[i64 0][i64 %200];
    i32 %202 = load i32* %201;
    i1 %203 = scmp eq i32 %202, i32 45;
    i32 %204 = zext i1 %203 to i32;
    i1 %205 = scmp neq i32 %204, i32 0;
    ubr ^b25;
^b25:
    i1 %206 = phi [^b24, i1 %205] [^while.header5, i1 true];
    i32 %207 = zext i1 %206 to i32;
    i1 %208 = scmp neq i32 %207, i32 0;
    cbr i1 %208(prob = 0.5), ^b32, ^b31;
^if.then7:
    ubr ^while.header7;
^while.header6:
    i32 %209 = load i32* @chat;
    i64 %210 = sext i32 %209 to i64;
    i32* %211 = getelementptr &([10000 * i32]* @chas)[i64 0][i64 %210];
    i32 %212 = load i32* %211;
    i1 %213 = scmp eq i32 %212, i32 42;
    i32 %214 = zext i1 %213 to i32;
    i1 %215 = scmp neq i32 %214, i32 0;
    cbr i1 %215(prob = 0.5), ^b34, ^b33;
^b26:
    i32 %216 = load i32* @i;
    i64 %217 = sext i32 %216 to i64;
    i32* %218 = getelementptr &([10000 * i32]* @get)[i64 0][i64 %217];
    i32 %219 = load i32* %218;
    i1 %220 = scmp eq i32 %219, i32 37;
    i32 %221 = zext i1 %220 to i32;
    i1 %222 = scmp neq i32 %221, i32 0;
    cbr i1 %222(prob = 0.5), ^if.then8, ^b35;
^b27:
    i32 %223 = load i32* @i;
    i64 %224 = sext i32 %223 to i64;
    i32* %225 = getelementptr &([10000 * i32]* @get2)[i64 0][i64 %224];
    i32 %226 = load i32* %225;
    i1 %227 = scmp eq i32 %226, i32 94;
    i32 %228 = zext i1 %227 to i32;
    i1 %229 = scmp neq i32 %228, i32 0;
    ubr ^b28;
^b28:
    i1 %230 = phi [^b27, i1 %229] [^b21, i1 true];
    i32 %231 = zext i1 %230 to i32;
    i1 %232 = scmp neq i32 %231, i32 0;
    cbr i1 %232(prob = 0.5), ^if.then9, ^if.else1;
^b29:
    i32 %233 = load i32* @chat;
    i64 %234 = sext i32 %233 to i64;
    i32* %235 = getelementptr &([10000 * i32]* @chas)[i64 0][i64 %234];
    i32 %236 = load i32* %235;
    i1 %237 = scmp eq i32 %236, i32 47;
    i32 %238 = zext i1 %237 to i32;
    i1 %239 = scmp neq i32 %238, i32 0;
    ubr ^b30;
^b30:
    i1 %240 = phi [^b29, i1 %239] [^b23, i1 true];
    i32 %241 = zext i1 %240 to i32;
    i1 %242 = scmp neq i32 %241, i32 0;
    cbr i1 %242(prob = 0.5), ^b37, ^b36;
^b31:
    i32 %243 = load i32* @chat;
    i64 %244 = sext i32 %243 to i64;
    i32* %245 = getelementptr &([10000 * i32]* @chas)[i64 0][i64 %244];
    i32 %246 = load i32* %245;
    i1 %247 = scmp eq i32 %246, i32 42;
    i32 %248 = zext i1 %247 to i32;
    i1 %249 = scmp neq i32 %248, i32 0;
    ubr ^b32;
^b32:
    i1 %250 = phi [^b31, i1 %249] [^b25, i1 true];
    i32 %251 = zext i1 %250 to i32;
    i1 %252 = scmp neq i32 %251, i32 0;
    cbr i1 %252(prob = 0.5), ^b39, ^b38;
^b33:
    i32 %253 = load i32* @chat;
    i64 %254 = sext i32 %253 to i64;
    i32* %255 = getelementptr &([10000 * i32]* @chas)[i64 0][i64 %254];
    i32 %256 = load i32* %255;
    i1 %257 = scmp eq i32 %256, i32 47;
    i32 %258 = zext i1 %257 to i32;
    i1 %259 = scmp neq i32 %258, i32 0;
    ubr ^b34;
^b34:
    i1 %260 = phi [^b33, i1 %259] [^while.header6, i1 true];
    i32 %261 = zext i1 %260 to i32;
    i1 %262 = scmp neq i32 %261, i32 0;
    cbr i1 %262(prob = 0.5), ^b41, ^b40;
^if.then8:
    ubr ^while.header8;
^while.header7:
    i32 %263 = load i32* @chat;
    i64 %264 = sext i32 %263 to i64;
    i32* %265 = getelementptr &([10000 * i32]* @chas)[i64 0][i64 %264];
    i32 %266 = load i32* %265;
    i1 %267 = scmp eq i32 %266, i32 42;
    i32 %268 = zext i1 %267 to i32;
    i1 %269 = scmp neq i32 %268, i32 0;
    cbr i1 %269(prob = 0.5), ^b43, ^b42;
^b35:
    i32 %270 = load i32* @ii;
    i64 %271 = sext i32 %270 to i64;
    i32* %272 = getelementptr &([10000 * i32]* @get2)[i64 0][i64 %271];
    store i32* %272 with i32 32;
    i32 %273 = load i32* @ii;
    i32 %274 = add i32 %273, i32 1;
    store i32* @ii with i32 %274;
    ubr ^b2;
^if.then9:
    i32 %275 = call () -> i32 @intpop();
    store i32* %a with i32 %275;
    i32 %276 = call () -> i32 @intpop();
    store i32* %b with i32 %276;
    store i32* %c with i32 0;
    i32 %277 = load i32* @i;
    i64 %278 = sext i32 %277 to i64;
    i32* %279 = getelementptr &([10000 * i32]* @get2)[i64 0][i64 %278];
    i32 %280 = load i32* %279;
    i1 %281 = scmp eq i32 %280, i32 43;
    i32 %282 = zext i1 %281 to i32;
    i1 %283 = scmp neq i32 %282, i32 0;
    cbr i1 %283(prob = 0.5), ^if.then10, ^b46;
^b36:
    i32 %284 = load i32* @chat;
    i64 %285 = sext i32 %284 to i64;
    i32* %286 = getelementptr &([10000 * i32]* @chas)[i64 0][i64 %285];
    i32 %287 = load i32* %286;
    i1 %288 = scmp eq i32 %287, i32 37;
    i32 %289 = zext i1 %288 to i32;
    i1 %290 = scmp neq i32 %289, i32 0;
    ubr ^b37;
^if.else1:
    i32 %291 = load i32* @i;
    i64 %292 = sext i32 %291 to i64;
    i32* %293 = getelementptr &([10000 * i32]* @get2)[i64 0][i64 %292];
    i32 %294 = load i32* %293;
    i1 %295 = scmp neq i32 %294, i32 32;
    i32 %296 = zext i1 %295 to i32;
    i1 %297 = scmp neq i32 %296, i32 0;
    cbr i1 %297(prob = 0.5), ^if.then11, ^b44;
^b37:
    i1 %298 = phi [^b36, i1 %290] [^b30, i1 true];
    i32 %299 = zext i1 %298 to i32;
    i1 %300 = scmp neq i32 %299, i32 0;
    cbr i1 %300(prob = 0.5), ^b47, ^b45;
^b38:
    i32 %301 = load i32* @chat;
    i64 %302 = sext i32 %301 to i64;
    i32* %303 = getelementptr &([10000 * i32]* @chas)[i64 0][i64 %302];
    i32 %304 = load i32* %303;
    i1 %305 = scmp eq i32 %304, i32 47;
    i32 %306 = zext i1 %305 to i32;
    i1 %307 = scmp neq i32 %306, i32 0;
    ubr ^b39;
^b39:
    i1 %308 = phi [^b38, i1 %307] [^b32, i1 true];
    i32 %309 = zext i1 %308 to i32;
    i1 %310 = scmp neq i32 %309, i32 0;
    cbr i1 %310(prob = 0.5), ^b49, ^b48;
^b40:
    i32 %311 = load i32* @chat;
    i64 %312 = sext i32 %311 to i64;
    i32* %313 = getelementptr &([10000 * i32]* @chas)[i64 0][i64 %312];
    i32 %314 = load i32* %313;
    i1 %315 = scmp eq i32 %314, i32 37;
    i32 %316 = zext i1 %315 to i32;
    i1 %317 = scmp neq i32 %316, i32 0;
    ubr ^b41;
^b41:
    i1 %318 = phi [^b40, i1 %317] [^b34, i1 true];
    i32 %319 = zext i1 %318 to i32;
    i1 %320 = scmp neq i32 %319, i32 0;
    cbr i1 %320(prob = 0.5), ^b51, ^b50;
^b42:
    i32 %321 = load i32* @chat;
    i64 %322 = sext i32 %321 to i64;
    i32* %323 = getelementptr &([10000 * i32]* @chas)[i64 0][i64 %322];
    i32 %324 = load i32* %323;
    i1 %325 = scmp eq i32 %324, i32 47;
    i32 %326 = zext i1 %325 to i32;
    i1 %327 = scmp neq i32 %326, i32 0;
    ubr ^b43;
^b43:
    i1 %328 = phi [^b42, i1 %327] [^while.header7, i1 true];
    i32 %329 = zext i1 %328 to i32;
    i1 %330 = scmp neq i32 %329, i32 0;
    cbr i1 %330(prob = 0.5), ^b53, ^b52;
^while.header8:
    i32 %331 = load i32* @chat;
    i64 %332 = sext i32 %331 to i64;
    i32* %333 = getelementptr &([10000 * i32]* @chas)[i64 0][i64 %332];
    i32 %334 = load i32* %333;
    i1 %335 = scmp eq i32 %334, i32 42;
    i32 %336 = zext i1 %335 to i32;
    i1 %337 = scmp neq i32 %336, i32 0;
    cbr i1 %337(prob = 0.5), ^b55, ^b54;
^if.then10:
    i32 %338 = load i32* %a;
    i32 %339 = load i32* %b;
    i32 %340 = add i32 %338, i32 %339;
    store i32* %c with i32 %340;
    ubr ^b46;
^if.then11:
    i32 %341 = load i32* @i;
    i64 %342 = sext i32 %341 to i64;
    i32* %343 = getelementptr &([10000 * i32]* @get2)[i64 0][i64 %342];
    i32 %344 = load i32* %343;
    i32 %345 = sub i32 %344, i32 48;
    call (i32) -> void @intpush(i32 %345);
    store i32* @ii with i32 1;
    ubr ^while.header9;
^b44:
    ubr ^b56;
^b45:
    i32 %346 = load i32* @chat;
    i64 %347 = sext i32 %346 to i64;
    i32* %348 = getelementptr &([10000 * i32]* @chas)[i64 0][i64 %347];
    i32 %349 = load i32* %348;
    i1 %350 = scmp eq i32 %349, i32 94;
    i32 %351 = zext i1 %350 to i32;
    i1 %352 = scmp neq i32 %351, i32 0;
    ubr ^b47;
^b46:
    i32 %353 = load i32* @i;
    i64 %354 = sext i32 %353 to i64;
    i32* %355 = getelementptr &([10000 * i32]* @get2)[i64 0][i64 %354];
    i32 %356 = load i32* %355;
    i1 %357 = scmp eq i32 %356, i32 45;
    i32 %358 = zext i1 %357 to i32;
    i1 %359 = scmp neq i32 %358, i32 0;
    cbr i1 %359(prob = 0.5), ^if.then12, ^b59;
^b47:
    i1 %360 = phi [^b45, i1 %352] [^b37, i1 true];
    i32 %361 = zext i1 %360 to i32;
    i1 %362 = scmp neq i32 %361, i32 0;
    cbr i1 %362(prob = 0.97), ^while.body4, ^b57;
^b48:
    i32 %363 = load i32* @chat;
    i64 %364 = sext i32 %363 to i64;
    i32* %365 = getelementptr &([10000 * i32]* @chas)[i64 0][i64 %364];
    i32 %366 = load i32* %365;
    i1 %367 = scmp eq i32 %366, i32 37;
    i32 %368 = zext i1 %367 to i32;
    i1 %369 = scmp neq i32 %368, i32 0;
    ubr ^b49;
^b49:
    i1 %370 = phi [^b48, i1 %369] [^b39, i1 true];
    i32 %371 = zext i1 %370 to i32;
    i1 %372 = scmp neq i32 %371, i32 0;
    cbr i1 %372(prob = 0.5), ^b60, ^b58;
^b50:
    i32 %373 = load i32* @chat;
    i64 %374 = sext i32 %373 to i64;
    i32* %375 = getelementptr &([10000 * i32]* @chas)[i64 0][i64 %374];
    i32 %376 = load i32* %375;
    i1 %377 = scmp eq i32 %376, i32 94;
    i32 %378 = zext i1 %377 to i32;
    i1 %379 = scmp neq i32 %378, i32 0;
    ubr ^b51;
^b51:
    i1 %380 = phi [^b50, i1 %379] [^b41, i1 true];
    i32 %381 = zext i1 %380 to i32;
    i1 %382 = scmp neq i32 %381, i32 0;
    cbr i1 %382(prob = 0.97), ^while.body5, ^b61;
^b52:
    i32 %383 = load i32* @chat;
    i64 %384 = sext i32 %383 to i64;
    i32* %385 = getelementptr &([10000 * i32]* @chas)[i64 0][i64 %384];
    i32 %386 = load i32* %385;
    i1 %387 = scmp eq i32 %386, i32 37;
    i32 %388 = zext i1 %387 to i32;
    i1 %389 = scmp neq i32 %388, i32 0;
    ubr ^b53;
^b53:
    i1 %390 = phi [^b52, i1 %389] [^b43, i1 true];
    i32 %391 = zext i1 %390 to i32;
    i1 %392 = scmp neq i32 %391, i32 0;
    cbr i1 %392(prob = 0.5), ^b63, ^b62;
^b54:
    i32 %393 = load i32* @chat;
    i64 %394 = sext i32 %393 to i64;
    i32* %395 = getelementptr &([10000 * i32]* @chas)[i64 0][i64 %394];
    i32 %396 = load i32* %395;
    i1 %397 = scmp eq i32 %396, i32 47;
    i32 %398 = zext i1 %397 to i32;
    i1 %399 = scmp neq i32 %398, i32 0;
    ubr ^b55;
^b55:
    i1 %400 = phi [^b54, i1 %399] [^while.header8, i1 true];
    i32 %401 = zext i1 %400 to i32;
    i1 %402 = scmp neq i32 %401, i32 0;
    cbr i1 %402(prob = 0.5), ^b65, ^b64;
^if.then12:
    i32 %403 = load i32* %b;
    i32 %404 = load i32* %a;
    i32 %405 = sub i32 %403, i32 %404;
    store i32* %c with i32 %405;
    ubr ^b59;
^b56:
    i32 %406 = load i32* @i;
    i32 %407 = add i32 %406, i32 1;
    store i32* @i with i32 %407;
    ubr ^while.header2;
^b57:
    call (i32) -> void @chapush(i32 43);
    ubr ^b10;
^while.header9:
    i32 %408 = load i32* @i;
    i32 %409 = load i32* @ii;
    i32 %410 = add i32 %408, i32 %409;
    i64 %411 = sext i32 %410 to i64;
    i32* %412 = getelementptr &([10000 * i32]* @get2)[i64 0][i64 %411];
    i32 %413 = load i32* %412;
    i1 %414 = scmp neq i32 %413, i32 32;
    i32 %415 = zext i1 %414 to i32;
    i1 %416 = scmp neq i32 %415, i32 0;
    cbr i1 %416(prob = 0.97), ^while.body6, ^b66;
^while.body4:
    i32 %417 = call () -> i32 @find();
    i1 %418 = scmp eq i32 %417, i32 0;
    i32 %419 = zext i1 %418 to i32;
    i1 %420 = scmp neq i32 %419, i32 0;
    cbr i1 %420(prob = 0.5), ^if.then13, ^b67;
^b58:
    i32 %421 = load i32* @chat;
    i64 %422 = sext i32 %421 to i64;
    i32* %423 = getelementptr &([10000 * i32]* @chas)[i64 0][i64 %422];
    i32 %424 = load i32* %423;
    i1 %425 = scmp eq i32 %424, i32 94;
    i32 %426 = zext i1 %425 to i32;
    i1 %427 = scmp neq i32 %426, i32 0;
    ubr ^b60;
^b59:
    i32 %428 = load i32* @i;
    i64 %429 = sext i32 %428 to i64;
    i32* %430 = getelementptr &([10000 * i32]* @get2)[i64 0][i64 %429];
    i32 %431 = load i32* %430;
    i1 %432 = scmp eq i32 %431, i32 42;
    i32 %433 = zext i1 %432 to i32;
    i1 %434 = scmp neq i32 %433, i32 0;
    cbr i1 %434(prob = 0.5), ^if.then14, ^b70;
^b60:
    i1 %435 = phi [^b58, i1 %427] [^b49, i1 true];
    i32 %436 = zext i1 %435 to i32;
    i1 %437 = scmp neq i32 %436, i32 0;
    cbr i1 %437(prob = 0.97), ^while.body7, ^b68;
^b61:
    call (i32) -> void @chapush(i32 42);
    ubr ^b19;
^while.body5:
    i32 %438 = call () -> i32 @find();
    i1 %439 = scmp eq i32 %438, i32 0;
    i32 %440 = zext i1 %439 to i32;
    i1 %441 = scmp neq i32 %440, i32 0;
    cbr i1 %441(prob = 0.5), ^if.then15, ^b69;
^b62:
    i32 %442 = load i32* @chat;
    i64 %443 = sext i32 %442 to i64;
    i32* %444 = getelementptr &([10000 * i32]* @chas)[i64 0][i64 %443];
    i32 %445 = load i32* %444;
    i1 %446 = scmp eq i32 %445, i32 94;
    i32 %447 = zext i1 %446 to i32;
    i1 %448 = scmp neq i32 %447, i32 0;
    ubr ^b63;
^b63:
    i1 %449 = phi [^b62, i1 %448] [^b53, i1 true];
    i32 %450 = zext i1 %449 to i32;
    i1 %451 = scmp neq i32 %450, i32 0;
    cbr i1 %451(prob = 0.97), ^while.body8, ^b71;
^b64:
    i32 %452 = load i32* @chat;
    i64 %453 = sext i32 %452 to i64;
    i32* %454 = getelementptr &([10000 * i32]* @chas)[i64 0][i64 %453];
    i32 %455 = load i32* %454;
    i1 %456 = scmp eq i32 %455, i32 37;
    i32 %457 = zext i1 %456 to i32;
    i1 %458 = scmp neq i32 %457, i32 0;
    ubr ^b65;
^b65:
    i1 %459 = phi [^b64, i1 %458] [^b55, i1 true];
    i32 %460 = zext i1 %459 to i32;
    i1 %461 = scmp neq i32 %460, i32 0;
    cbr i1 %461(prob = 0.5), ^b73, ^b72;
^while.body6:
    i32 %462 = load i32* @i;
    i32 %463 = load i32* @ii;
    i32 %464 = add i32 %462, i32 %463;
    i64 %465 = sext i32 %464 to i64;
    i32* %466 = getelementptr &([10000 * i32]* @get2)[i64 0][i64 %465];
    i32 %467 = load i32* %466;
    i32 %468 = sub i32 %467, i32 48;
    call (i32) -> void @intadd(i32 %468);
    i32 %469 = load i32* @ii;
    i32 %470 = add i32 %469, i32 1;
    store i32* @ii with i32 %470;
    ubr ^while.header9;
^if.then13:
    ubr ^b57;
^if.then14:
    i32 %471 = load i32* %a;
    i32 %472 = load i32* %b;
    i32 %473 = mul i32 %471, i32 %472;
    store i32* %c with i32 %473;
    ubr ^b70;
^b66:
    i32 %474 = load i32* @i;
    i32 %475 = load i32* @ii;
    i32 %476 = add i32 %474, i32 %475;
    i32 %477 = sub i32 %476, i32 1;
    store i32* @i with i32 %477;
    ubr ^b44;
^b67:
    ubr ^while.header4;
^b68:
    call (i32) -> void @chapush(i32 45);
    ubr ^b14;
^if.then15:
    ubr ^b61;
^while.body7:
    i32 %478 = call () -> i32 @find();
    i1 %479 = scmp eq i32 %478, i32 0;
    i32 %480 = zext i1 %479 to i32;
    i1 %481 = scmp neq i32 %480, i32 0;
    cbr i1 %481(prob = 0.5), ^if.then16, ^b74;
^b69:
    ubr ^while.header6;
^b70:
    i32 %482 = load i32* @i;
    i64 %483 = sext i32 %482 to i64;
    i32* %484 = getelementptr &([10000 * i32]* @get2)[i64 0][i64 %483];
    i32 %485 = load i32* %484;
    i1 %486 = scmp eq i32 %485, i32 47;
    i32 %487 = zext i1 %486 to i32;
    i1 %488 = scmp neq i32 %487, i32 0;
    cbr i1 %488(prob = 0.5), ^if.then17, ^b76;
^b71:
    call (i32) -> void @chapush(i32 47);
    ubr ^b26;
^while.body8:
    i32 %489 = call () -> i32 @find();
    i1 %490 = scmp eq i32 %489, i32 0;
    i32 %491 = zext i1 %490 to i32;
    i1 %492 = scmp neq i32 %491, i32 0;
    cbr i1 %492(prob = 0.5), ^if.then18, ^b75;
^b72:
    i32 %493 = load i32* @chat;
    i64 %494 = sext i32 %493 to i64;
    i32* %495 = getelementptr &([10000 * i32]* @chas)[i64 0][i64 %494];
    i32 %496 = load i32* %495;
    i1 %497 = scmp eq i32 %496, i32 94;
    i32 %498 = zext i1 %497 to i32;
    i1 %499 = scmp neq i32 %498, i32 0;
    ubr ^b73;
^b73:
    i1 %500 = phi [^b72, i1 %499] [^b65, i1 true];
    i32 %501 = zext i1 %500 to i32;
    i1 %502 = scmp neq i32 %501, i32 0;
    cbr i1 %502(prob = 0.97), ^while.body9, ^b77;
^if.then16:
    ubr ^b68;
^if.then17:
    i32 %503 = load i32* %b;
    i32 %504 = load i32* %a;
    i32 %505 = sdiv i32 %503, i32 %504;
    store i32* %c with i32 %505;
    ubr ^b76;
^b74:
    ubr ^while.header5;
^if.then18:
    ubr ^b71;
^b75:
    ubr ^while.header7;
^b76:
    i32 %506 = load i32* @i;
    i64 %507 = sext i32 %506 to i64;
    i32* %508 = getelementptr &([10000 * i32]* @get2)[i64 0][i64 %507];
    i32 %509 = load i32* %508;
    i1 %510 = scmp eq i32 %509, i32 37;
    i32 %511 = zext i1 %510 to i32;
    i1 %512 = scmp neq i32 %511, i32 0;
    cbr i1 %512(prob = 0.5), ^if.then19, ^b79;
^b77:
    call (i32) -> void @chapush(i32 37);
    ubr ^b35;
^while.body9:
    i32 %513 = call () -> i32 @find();
    i1 %514 = scmp eq i32 %513, i32 0;
    i32 %515 = zext i1 %514 to i32;
    i1 %516 = scmp neq i32 %515, i32 0;
    cbr i1 %516(prob = 0.5), ^if.then20, ^b78;
^if.then19:
    i32 %517 = load i32* %b;
    i32 %518 = load i32* %a;
    i32 %519 = srem i32 %517, i32 %518;
    store i32* %c with i32 %519;
    ubr ^b79;
^if.then20:
    ubr ^b77;
^b78:
    ubr ^while.header8;
^b79:
    i32 %520 = load i32* @i;
    i64 %521 = sext i32 %520 to i64;
    i32* %522 = getelementptr &([10000 * i32]* @get2)[i64 0][i64 %521];
    i32 %523 = load i32* %522;
    i1 %524 = scmp eq i32 %523, i32 94;
    i32 %525 = zext i1 %524 to i32;
    i1 %526 = scmp neq i32 %525, i32 0;
    cbr i1 %526(prob = 0.5), ^if.then21, ^b80;
^if.then21:
    i32 %527 = load i32* %b;
    i32 %528 = load i32* %a;
    i32 %529 = call (i32, i32) -> i32 @power(i32 %527, i32 %528);
    store i32* %c with i32 %529;
    ubr ^b80;
^b80:
    i32 %530 = load i32* %c;
    call (i32) -> void @intpush(i32 %530);
    ubr ^b56;
}
