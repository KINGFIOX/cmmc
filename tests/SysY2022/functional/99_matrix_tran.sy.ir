internal func @putint(i32) -> void { NoMemoryRead NoMemoryWrite };
internal func @putch(i32) -> void { NoMemoryRead NoMemoryWrite };
func @main() -> i32 { NoMemoryRead NoMemoryWrite NoRecurse } {
^entry():
    [3 * f32]* %a0 = alloc [3 * f32];
    [3 * f32]* %a1 = alloc [3 * f32];
    [3 * f32]* %a2 = alloc [3 * f32];
    [6 * f32]* %c0 = alloc [6 * f32];
    [3 * f32]* %c1 = alloc [3 * f32];
    [3 * f32]* %c2 = alloc [3 * f32];
    ubr [ ^while.body [3 * f32]* %c2, [6 * f32]* %c0, [3 * f32]* %a2, [3 * f32]* %a1, [3 * f32]* %a0, [3 * f32]* %c1, i32 0 ];
^while.body([3 * f32]* %arg, [6 * f32]* %arg1, [3 * f32]* %arg2, [3 * f32]* %arg3, [3 * f32]* %arg4, [3 * f32]* %arg5, i32 %arg6):
    f32* %0 = getelementptr &([3 * f32]* %arg4)[i32 0][i32 %arg6];
    f32 %1 = s2f i32 %arg6 to f32;
    store f32* %0 with f32 %1;
    f32* %2 = getelementptr &([3 * f32]* %arg3)[i32 0][i32 %arg6];
    store f32* %2 with f32 %1;
    f32* %3 = getelementptr &([3 * f32]* %arg2)[i32 0][i32 %arg6];
    store f32* %3 with f32 %1;
    i32 %4 = add i32 %arg6, i32 1;
    i1 %5 = scmp lt i32 %4, i32 3;
    cbr i1 %5, [ ^while.body [3 * f32]* %arg, [6 * f32]* %arg1, [3 * f32]* %arg2, [3 * f32]* %arg3, [3 * f32]* %arg4, [3 * f32]* %arg5, i32 %4 ], [ ^b [3 * f32]* %arg, [3 * f32]* %arg5, [6 * f32]* %arg1, [3 * f32]* %arg2, [3 * f32]* %arg3, [3 * f32]* %arg4 ];
^b([3 * f32]* %arg, [3 * f32]* %arg1, [6 * f32]* %arg2, [3 * f32]* %arg3, [3 * f32]* %arg4, [3 * f32]* %arg5):
    f32* %0 = getelementptr &([3 * f32]* %arg5)[i32 0][i32 0];
    f32* %1 = getelementptr &([3 * f32]* %arg4)[i32 0][i32 0];
    f32* %2 = getelementptr &([3 * f32]* %arg3)[i32 0][i32 0];
    f32* %3 = getelementptr &([6 * f32]* %arg2)[i32 0][i32 0];
    f32* %4 = getelementptr &([3 * f32]* %arg1)[i32 0][i32 0];
    f32* %5 = getelementptr &([3 * f32]* %arg)[i32 0][i32 0];
    f32* %6 = getelementptr &(f32* %4)[i32 2];
    f32* %7 = getelementptr &(f32* %2)[i32 1];
    f32 %8 = load f32* %7;
    store f32* %6 with f32 %8;
    f32* %9 = getelementptr &(f32* %5)[i32 1];
    f32* %10 = getelementptr &(f32* %1)[i32 2];
    f32 %11 = load f32* %10;
    store f32* %9 with f32 %11;
    f32* %12 = getelementptr &(f32* %3)[i32 1];
    f32 %13 = load f32* %1;
    store f32* %12 with f32 %13;
    f32* %14 = getelementptr &(f32* %3)[i32 2];
    f32 %15 = load f32* %2;
    store f32* %14 with f32 %15;
    f32* %16 = getelementptr &(f32* %0)[i32 1];
    f32 %17 = load f32* %16;
    store f32* %4 with f32 %17;
    f32* %18 = getelementptr &(f32* %0)[i32 2];
    f32 %19 = load f32* %18;
    store f32* %5 with f32 %19;
    f32* %20 = getelementptr &(f32* %4)[i32 1];
    f32* %21 = getelementptr &(f32* %1)[i32 1];
    f32 %22 = load f32* %21;
    store f32* %20 with f32 %22;
    f32* %23 = getelementptr &(f32* %5)[i32 2];
    f32* %24 = getelementptr &(f32* %2)[i32 2];
    f32 %25 = load f32* %24;
    store f32* %23 with f32 %25;
    f32 %26 = load f32* %0;
    store f32* %3 with f32 %26;
    ubr [ ^while.body1 [3 * f32]* %arg, [6 * f32]* %arg2, [3 * f32]* %arg1, i32 0 ];
^while.body1([3 * f32]* %arg, [6 * f32]* %arg1, [3 * f32]* %arg2, i32 %arg3):
    f32* %0 = getelementptr &([6 * f32]* %arg1)[i32 0][i32 %arg3];
    f32 %1 = load f32* %0;
    i32 %2 = f2s f32 %1 to i32;
    call (i32) -> void @putint(i32 %2);
    i32 %3 = add i32 %arg3, i32 1;
    i1 %4 = scmp lt i32 %3, i32 3;
    cbr i1 %4, [ ^while.body1 [3 * f32]* %arg, [6 * f32]* %arg1, [3 * f32]* %arg2, i32 %3 ], [ ^b1 [3 * f32]* %arg, [3 * f32]* %arg2 ];
^b1([3 * f32]* %arg, [3 * f32]* %arg1):
    call (i32) -> void @putch(i32 10);
    ubr [ ^while.body2 [3 * f32]* %arg, [3 * f32]* %arg1, i32 0 ];
^while.body2([3 * f32]* %arg, [3 * f32]* %arg1, i32 %arg2):
    f32* %0 = getelementptr &([3 * f32]* %arg1)[i32 0][i32 %arg2];
    f32 %1 = load f32* %0;
    i32 %2 = f2s f32 %1 to i32;
    call (i32) -> void @putint(i32 %2);
    i32 %3 = add i32 %arg2, i32 1;
    i1 %4 = scmp lt i32 %3, i32 3;
    cbr i1 %4, [ ^while.body2 [3 * f32]* %arg, [3 * f32]* %arg1, i32 %3 ], [ ^b2 [3 * f32]* %arg ];
^b2([3 * f32]* %arg):
    call (i32) -> void @putch(i32 10);
    ubr [ ^while.body3 [3 * f32]* %arg, i32 0 ];
^while.body3([3 * f32]* %arg, i32 %arg1):
    f32* %0 = getelementptr &([3 * f32]* %arg)[i32 0][i32 %arg1];
    f32 %1 = load f32* %0;
    i32 %2 = f2s f32 %1 to i32;
    call (i32) -> void @putint(i32 %2);
    i32 %3 = add i32 %arg1, i32 1;
    i1 %4 = scmp lt i32 %3, i32 3;
    cbr i1 %4, [ ^while.body3 [3 * f32]* %arg, i32 %3 ], [ ^b3 ];
^b3():
    call (i32) -> void @putch(i32 10);
    ret i32 0;
}
