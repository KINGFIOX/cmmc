internal func @getint() -> i32 { NoMemoryRead NoMemoryWrite };
internal func @getch() -> i32 { NoMemoryRead NoMemoryWrite };
internal func @getarray() -> i32 { NoMemoryRead };
internal func @getfloat() -> f32 { NoMemoryRead NoMemoryWrite };
internal func @getfarray() -> i32 { NoMemoryRead };
internal func @putint() -> void { NoMemoryRead NoMemoryWrite };
internal func @putch() -> void { NoMemoryRead NoMemoryWrite };
internal func @putarray() -> void { NoMemoryWrite };
internal func @putfloat() -> void { NoMemoryRead NoMemoryWrite };
internal func @putfarray() -> void { NoMemoryWrite };
internal func @starttime() -> void { NoMemoryRead NoMemoryWrite };
internal func @stoptime() -> void { NoMemoryRead NoMemoryWrite };
internal i32* @INF { ReadOnly } = 1073741824;
internal [30 * [30 * i32]]* @a;
internal [4 * [2 * i32]]* @step = [[1, 0], [-1, 0], [0, 1], [0, -1]];
internal i32* @w;
internal i32* @h;
internal i32* @x_0;
internal i32* @y_0;
internal i32* @x_1;
internal i32* @y_1;
internal func @search(i32 %x, i32 %y, i32 %n) -> i32 {
^entry:
    i32* %searchRe = alloc i32;
    i32* %y2 = alloc i32;
    i32* %x2 = alloc i32;
    i32* %coun = alloc i32;
    i32* %i = alloc i32;
    i32* %num = alloc i32;
    i32* %n1 = alloc i32;
    i32* %y1 = alloc i32;
    i32* %x1 = alloc i32;
    store i32* %x1 with i32 %x;
    store i32* %y1 with i32 %y;
    store i32* %n1 with i32 %n;
    i32 %0 = load i32* %n1;
    i1 %1 = scmp gt i32 %0, i32 10;
    i32 %2 = zext i1 %1 to i32;
    i1 %3 = scmp neq i32 %2, i32 0;
    cbr i1 %3(prob = 0.5), ^if.then, ^b;
^b:
    store i32* %num with i32 1073741824;
    store i32* %i with i32 0;
    ubr ^while.header;
^if.then:
    ret i32 1073741824;
^while.header:
    i32 %4 = load i32* %i;
    i1 %5 = scmp lt i32 %4, i32 4;
    i32 %6 = zext i1 %5 to i32;
    i1 %7 = scmp neq i32 %6, i32 0;
    cbr i1 %7(prob = 0.97), ^while.body, ^b1;
^while.body:
    store i32* %coun with i32 0;
    i32 %8 = load i32* %x1;
    store i32* %x2 with i32 %8;
    i32 %9 = load i32* %y1;
    store i32* %y2 with i32 %9;
    ubr ^while.header1;
^b1:
    i32 %10 = load i32* %num;
    i1 %11 = scmp gt i32 %10, i32 10;
    i32 %12 = zext i1 %11 to i32;
    i1 %13 = scmp neq i32 %12, i32 0;
    cbr i1 %13(prob = 0.5), ^if.then1, ^b2;
^while.header1:
    i32 %14 = load i32* %x2;
    i64 %15 = sext i32 %14 to i64;
    [30 * i32]* %16 = getelementptr &([30 * [30 * i32]]* @a)[i64 0][i64 %15];
    i32 %17 = load i32* %y2;
    i64 %18 = sext i32 %17 to i64;
    i32* %19 = getelementptr &([30 * i32]* %16)[i64 0][i64 %18];
    i32 %20 = load i32* %19;
    i1 %21 = scmp neq i32 %20, i32 1;
    i32 %22 = zext i1 %21 to i32;
    i1 %23 = scmp neq i32 %22, i32 0;
    cbr i1 %23(prob = 0.97), ^while.body1, ^b3;
^if.then1:
    ret i32 1073741824;
^b2:
    i32 %24 = load i32* %num;
    ret i32 %24;
^while.body1:
    i32 %25 = load i32* %x2;
    i32 %26 = load i32* @x_1;
    i1 %27 = scmp eq i32 %25, i32 %26;
    i32 %28 = zext i1 %27 to i32;
    i1 %29 = scmp neq i32 %28, i32 0;
    cbr i1 %29(prob = 0.5), ^b4, ^b6;
^b3:
    i32 %30 = load i32* %x2;
    i32 %31 = load i32* @x_1;
    i1 %32 = scmp eq i32 %30, i32 %31;
    i32 %33 = zext i1 %32 to i32;
    i1 %34 = scmp neq i32 %33, i32 0;
    cbr i1 %34(prob = 0.5), ^b5, ^b7;
^b4:
    i32 %35 = load i32* %y2;
    i32 %36 = load i32* @y_1;
    i1 %37 = scmp eq i32 %35, i32 %36;
    i32 %38 = zext i1 %37 to i32;
    i1 %39 = scmp neq i32 %38, i32 0;
    ubr ^b6;
^b5:
    i32 %40 = load i32* %y2;
    i32 %41 = load i32* @y_1;
    i1 %42 = scmp eq i32 %40, i32 %41;
    i32 %43 = zext i1 %42 to i32;
    i1 %44 = scmp neq i32 %43, i32 0;
    ubr ^b7;
^b6:
    i1 %45 = phi [^b4, i1 %39] [^while.body1, i1 false];
    i32 %46 = zext i1 %45 to i32;
    i1 %47 = scmp neq i32 %46, i32 0;
    cbr i1 %47(prob = 0.5), ^if.then2, ^b8;
^b7:
    i1 %48 = phi [^b5, i1 %44] [^b3, i1 false];
    i32 %49 = zext i1 %48 to i32;
    i1 %50 = scmp neq i32 %49, i32 0;
    cbr i1 %50(prob = 0.5), ^if.then3, ^b9;
^if.then2:
    ubr ^b3;
^b8:
    i32 %51 = load i32* %x2;
    i32 %52 = load i32* %i;
    i64 %53 = sext i32 %52 to i64;
    [2 * i32]* %54 = getelementptr &([4 * [2 * i32]]* @step)[i64 0][i64 %53];
    i32* %55 = getelementptr &([2 * i32]* %54)[i64 0][i64 0];
    i32 %56 = load i32* %55;
    i32 %57 = add i32 %51, i32 %56;
    store i32* %x2 with i32 %57;
    i32 %58 = load i32* %y2;
    i32 %59 = load i32* %i;
    i64 %60 = sext i32 %59 to i64;
    [2 * i32]* %61 = getelementptr &([4 * [2 * i32]]* @step)[i64 0][i64 %60];
    i32* %62 = getelementptr &([2 * i32]* %61)[i64 0][i64 1];
    i32 %63 = load i32* %62;
    i32 %64 = add i32 %58, i32 %63;
    store i32* %y2 with i32 %64;
    i32 %65 = load i32* %coun;
    i32 %66 = add i32 %65, i32 1;
    store i32* %coun with i32 %66;
    ubr ^while.header1;
^b9:
    i32 %67 = load i32* %coun;
    i1 %68 = scmp le i32 %67, i32 1;
    i32 %69 = zext i1 %68 to i32;
    i1 %70 = scmp neq i32 %69, i32 0;
    cbr i1 %70(prob = 0.5), ^if.then4, ^b10;
^if.then3:
    ret i32 1;
^if.then4:
    i32 %71 = load i32* %i;
    i32 %72 = add i32 %71, i32 1;
    store i32* %i with i32 %72;
    ubr ^while.header;
^b10:
    i32 %73 = load i32* %x2;
    i1 %74 = scmp eq i32 %73, i32 0;
    i32 %75 = zext i1 %74 to i32;
    i1 %76 = scmp neq i32 %75, i32 0;
    cbr i1 %76(prob = 0.5), ^b12, ^b11;
^b11:
    i32 %77 = load i32* %x2;
    i32 %78 = load i32* @h;
    i32 %79 = add i32 %78, i32 1;
    i1 %80 = scmp eq i32 %77, i32 %79;
    i32 %81 = zext i1 %80 to i32;
    i1 %82 = scmp neq i32 %81, i32 0;
    ubr ^b12;
^b12:
    i1 %83 = phi [^b11, i1 %82] [^b10, i1 true];
    i32 %84 = zext i1 %83 to i32;
    i1 %85 = scmp neq i32 %84, i32 0;
    cbr i1 %85(prob = 0.5), ^b14, ^b13;
^b13:
    i32 %86 = load i32* %y2;
    i1 %87 = scmp eq i32 %86, i32 0;
    i32 %88 = zext i1 %87 to i32;
    i1 %89 = scmp neq i32 %88, i32 0;
    ubr ^b14;
^b14:
    i1 %90 = phi [^b13, i1 %89] [^b12, i1 true];
    i32 %91 = zext i1 %90 to i32;
    i1 %92 = scmp neq i32 %91, i32 0;
    cbr i1 %92(prob = 0.5), ^b16, ^b15;
^b15:
    i32 %93 = load i32* %y2;
    i32 %94 = load i32* @w;
    i32 %95 = add i32 %94, i32 1;
    i1 %96 = scmp eq i32 %93, i32 %95;
    i32 %97 = zext i1 %96 to i32;
    i1 %98 = scmp neq i32 %97, i32 0;
    ubr ^b16;
^b16:
    i1 %99 = phi [^b15, i1 %98] [^b14, i1 true];
    i32 %100 = zext i1 %99 to i32;
    i1 %101 = scmp neq i32 %100, i32 0;
    cbr i1 %101(prob = 0.5), ^if.then5, ^b17;
^if.then5:
    i32 %102 = load i32* %i;
    i32 %103 = add i32 %102, i32 1;
    store i32* %i with i32 %103;
    ubr ^while.header;
^b17:
    i32 %104 = load i32* %x2;
    i64 %105 = sext i32 %104 to i64;
    [30 * i32]* %106 = getelementptr &([30 * [30 * i32]]* @a)[i64 0][i64 %105];
    i32 %107 = load i32* %y2;
    i64 %108 = sext i32 %107 to i64;
    i32* %109 = getelementptr &([30 * i32]* %106)[i64 0][i64 %108];
    store i32* %109 with i32 0;
    i32 %110 = load i32* %x2;
    i32 %111 = load i32* %i;
    i64 %112 = sext i32 %111 to i64;
    [2 * i32]* %113 = getelementptr &([4 * [2 * i32]]* @step)[i64 0][i64 %112];
    i32* %114 = getelementptr &([2 * i32]* %113)[i64 0][i64 0];
    i32 %115 = load i32* %114;
    i32 %116 = sub i32 %110, i32 %115;
    i32 %117 = load i32* %y2;
    i32 %118 = load i32* %i;
    i64 %119 = sext i32 %118 to i64;
    [2 * i32]* %120 = getelementptr &([4 * [2 * i32]]* @step)[i64 0][i64 %119];
    i32* %121 = getelementptr &([2 * i32]* %120)[i64 0][i64 1];
    i32 %122 = load i32* %121;
    i32 %123 = sub i32 %117, i32 %122;
    i32 %124 = load i32* %n1;
    i32 %125 = add i32 %124, i32 1;
    i32 %126 = call (i32, i32, i32) -> i32 @search(i32 %116, i32 %123, i32 %125);
    i32 %127 = add i32 %126, i32 1;
    store i32* %searchRe with i32 %127;
    i32 %128 = load i32* %searchRe;
    i32 %129 = load i32* %num;
    i1 %130 = scmp lt i32 %128, i32 %129;
    i32 %131 = zext i1 %130 to i32;
    i1 %132 = scmp neq i32 %131, i32 0;
    cbr i1 %132(prob = 0.5), ^if.then6, ^b18;
^if.then6:
    i32 %133 = load i32* %searchRe;
    store i32* %num with i32 %133;
    ubr ^b18;
^b18:
    i32 %134 = load i32* %x2;
    i64 %135 = sext i32 %134 to i64;
    [30 * i32]* %136 = getelementptr &([30 * [30 * i32]]* @a)[i64 0][i64 %135];
    i32 %137 = load i32* %y2;
    i64 %138 = sext i32 %137 to i64;
    i32* %139 = getelementptr &([30 * i32]* %136)[i64 0][i64 %138];
    store i32* %139 with i32 1;
    i32 %140 = load i32* %i;
    i32 %141 = add i32 %140, i32 1;
    store i32* %i with i32 %141;
    ubr ^while.header;
}
func @main() -> i32 { Entry } {
^entry:
    i32* %res = alloc i32;
    i32* %j = alloc i32;
    i32* %i = alloc i32;
    i32 %0 = call () -> i32 @getint();
    store i32* @w with i32 %0;
    i32 %1 = call () -> i32 @getint();
    store i32* @h with i32 %1;
    ubr ^while.header;
^while.header:
    i32 %2 = load i32* @w;
    i1 %3 = scmp neq i32 %2, i32 0;
    i32 %4 = zext i1 %3 to i32;
    i1 %5 = scmp neq i32 %4, i32 0;
    cbr i1 %5(prob = 0.97), ^while.body, ^b;
^while.body:
    store i32* %i with i32 0;
    store i32* %j with i32 0;
    store i32* %i with i32 0;
    ubr ^while.header1;
^b:
    ret i32 0;
^while.header1:
    i32 %6 = load i32* %i;
    i1 %7 = scmp lt i32 %6, i32 30;
    i32 %8 = zext i1 %7 to i32;
    i1 %9 = scmp neq i32 %8, i32 0;
    cbr i1 %9(prob = 0.97), ^while.body1, ^b1;
^while.body1:
    store i32* %j with i32 0;
    ubr ^while.header2;
^b1:
    store i32* %i with i32 1;
    ubr ^while.header3;
^while.header2:
    i32 %10 = load i32* %j;
    i1 %11 = scmp lt i32 %10, i32 30;
    i32 %12 = zext i1 %11 to i32;
    i1 %13 = scmp neq i32 %12, i32 0;
    cbr i1 %13(prob = 0.97), ^while.body2, ^b2;
^while.header3:
    i32 %14 = load i32* %i;
    i32 %15 = load i32* @h;
    i1 %16 = scmp le i32 %14, i32 %15;
    i32 %17 = zext i1 %16 to i32;
    i1 %18 = scmp neq i32 %17, i32 0;
    cbr i1 %18(prob = 0.97), ^while.body3, ^b3;
^while.body2:
    i32 %19 = load i32* %i;
    i64 %20 = sext i32 %19 to i64;
    [30 * i32]* %21 = getelementptr &([30 * [30 * i32]]* @a)[i64 0][i64 %20];
    i32 %22 = load i32* %j;
    i64 %23 = sext i32 %22 to i64;
    i32* %24 = getelementptr &([30 * i32]* %21)[i64 0][i64 %23];
    store i32* %24 with i32 1;
    i32 %25 = load i32* %j;
    i32 %26 = add i32 %25, i32 1;
    store i32* %j with i32 %26;
    ubr ^while.header2;
^b2:
    i32 %27 = load i32* %i;
    i32 %28 = add i32 %27, i32 1;
    store i32* %i with i32 %28;
    ubr ^while.header1;
^while.body3:
    store i32* %j with i32 1;
    ubr ^while.header4;
^b3:
    i32 %29 = load i32* @x_0;
    i32 %30 = load i32* @y_0;
    i32 %31 = call (i32, i32, i32) -> i32 @search(i32 %29, i32 %30, i32 1);
    store i32* %res with i32 %31;
    i32 %32 = load i32* %res;
    i1 %33 = scmp le i32 %32, i32 10;
    i32 %34 = zext i1 %33 to i32;
    i1 %35 = scmp neq i32 %34, i32 0;
    cbr i1 %35(prob = 0.5), ^if.then, ^if.else;
^if.then:
    i32 %36 = load i32* %res;
    call (i32) -> void @putint(i32 %36);
    call (i32) -> void @putch(i32 10);
    ubr ^b5;
^while.header4:
    i32 %37 = load i32* %j;
    i32 %38 = load i32* @w;
    i1 %39 = scmp le i32 %37, i32 %38;
    i32 %40 = zext i1 %39 to i32;
    i1 %41 = scmp neq i32 %40, i32 0;
    cbr i1 %41(prob = 0.97), ^while.body4, ^b4;
^if.else:
    call (i32) -> void @putint(i32 -1);
    call (i32) -> void @putch(i32 10);
    ubr ^b5;
^b4:
    i32 %42 = load i32* %i;
    i32 %43 = add i32 %42, i32 1;
    store i32* %i with i32 %43;
    ubr ^while.header3;
^b5:
    i32 %44 = call () -> i32 @getint();
    store i32* @w with i32 %44;
    i32 %45 = call () -> i32 @getint();
    store i32* @h with i32 %45;
    ubr ^while.header;
^while.body4:
    i32 %46 = load i32* %i;
    i64 %47 = sext i32 %46 to i64;
    [30 * i32]* %48 = getelementptr &([30 * [30 * i32]]* @a)[i64 0][i64 %47];
    i32 %49 = load i32* %j;
    i64 %50 = sext i32 %49 to i64;
    i32* %51 = getelementptr &([30 * i32]* %48)[i64 0][i64 %50];
    i32 %52 = call () -> i32 @getint();
    store i32* %51 with i32 %52;
    i32 %53 = load i32* %i;
    i64 %54 = sext i32 %53 to i64;
    [30 * i32]* %55 = getelementptr &([30 * [30 * i32]]* @a)[i64 0][i64 %54];
    i32 %56 = load i32* %j;
    i64 %57 = sext i32 %56 to i64;
    i32* %58 = getelementptr &([30 * i32]* %55)[i64 0][i64 %57];
    i32 %59 = load i32* %58;
    i1 %60 = scmp eq i32 %59, i32 2;
    i32 %61 = zext i1 %60 to i32;
    i1 %62 = scmp neq i32 %61, i32 0;
    cbr i1 %62(prob = 0.5), ^if.then1, ^if.else1;
^if.then1:
    i32 %63 = load i32* %i;
    store i32* @x_0 with i32 %63;
    i32 %64 = load i32* %j;
    store i32* @y_0 with i32 %64;
    ubr ^b6;
^if.else1:
    i32 %65 = load i32* %i;
    i64 %66 = sext i32 %65 to i64;
    [30 * i32]* %67 = getelementptr &([30 * [30 * i32]]* @a)[i64 0][i64 %66];
    i32 %68 = load i32* %j;
    i64 %69 = sext i32 %68 to i64;
    i32* %70 = getelementptr &([30 * i32]* %67)[i64 0][i64 %69];
    i32 %71 = load i32* %70;
    i1 %72 = scmp eq i32 %71, i32 3;
    i32 %73 = zext i1 %72 to i32;
    i1 %74 = scmp neq i32 %73, i32 0;
    cbr i1 %74(prob = 0.5), ^if.then2, ^b7;
^b6:
    i32 %75 = load i32* %j;
    i32 %76 = add i32 %75, i32 1;
    store i32* %j with i32 %76;
    ubr ^while.header4;
^if.then2:
    i32 %77 = load i32* %i;
    store i32* @x_1 with i32 %77;
    i32 %78 = load i32* %j;
    store i32* @y_1 with i32 %78;
    ubr ^b7;
^b7:
    ubr ^b6;
}
