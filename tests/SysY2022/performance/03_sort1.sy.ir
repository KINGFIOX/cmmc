internal func @getarray() -> i32 { NoMemoryRead };
internal func @putint() -> void { NoMemoryRead NoMemoryWrite };
internal func @putch() -> void { NoMemoryRead NoMemoryWrite };
internal func @starttime() -> void { NoMemoryRead NoMemoryWrite };
internal func @stoptime() -> void { NoMemoryRead NoMemoryWrite };
internal func @radixSort(i32 %bitround, i32* %a, i32 %l, i32 %r, i32* %0) -> void {
^entry:
    i32* %i = alloc i32;
    i32* %i1 = alloc i32;
    [16 * i32]* %cnt = alloc [16 * i32];
    [16 * i32]* %tail = alloc [16 * i32];
    [16 * i32]* %head = alloc [16 * i32];
    i32* %l1 = alloc i32;
    i32** %a1 = alloc i32*;
    i32* %bitround1 = alloc i32;
    store i32* %bitround1 with i32 %bitround;
    store i32** %a1 with i32* %a;
    store i32* %l1 with i32 %l;
    i32 %1 = add i32 %l, i32 1;
    i1 %2 = scmp eq i32 %bitround, i32 -1;
    i1 %3 = scmp ge i32 %1, i32 %r;
    i1 %4 = or i1 %3, i1 %2;
    i32* %5 = getelementptr &([16 * i32]* %cnt)[i64 0][i64 0];
    i32* %6 = getelementptr &([16 * i32]* %tail)[i64 0][i64 0];
    i32* %7 = getelementptr &([16 * i32]* %head)[i64 0][i64 0];
    store i32* %7 with i32 0;
    i32* %8 = getelementptr &([16 * i32]* %cnt)[i64 0][i64 1];
    i32* %9 = getelementptr &([16 * i32]* %tail)[i64 0][i64 1];
    i32* %10 = getelementptr &([16 * i32]* %head)[i64 0][i64 1];
    store i32* %10 with i32 0;
    i32* %11 = getelementptr &([16 * i32]* %cnt)[i64 0][i64 2];
    i32* %12 = getelementptr &([16 * i32]* %tail)[i64 0][i64 2];
    i32* %13 = getelementptr &([16 * i32]* %head)[i64 0][i64 2];
    store i32* %13 with i32 0;
    i32* %14 = getelementptr &([16 * i32]* %cnt)[i64 0][i64 3];
    i32* %15 = getelementptr &([16 * i32]* %tail)[i64 0][i64 3];
    i32* %16 = getelementptr &([16 * i32]* %head)[i64 0][i64 3];
    store i32* %16 with i32 0;
    i32* %17 = getelementptr &([16 * i32]* %cnt)[i64 0][i64 4];
    i32* %18 = getelementptr &([16 * i32]* %tail)[i64 0][i64 4];
    i32* %19 = getelementptr &([16 * i32]* %head)[i64 0][i64 4];
    store i32* %19 with i32 0;
    i32* %20 = getelementptr &([16 * i32]* %cnt)[i64 0][i64 5];
    i32* %21 = getelementptr &([16 * i32]* %tail)[i64 0][i64 5];
    i32* %22 = getelementptr &([16 * i32]* %head)[i64 0][i64 5];
    store i32* %22 with i32 0;
    i32* %23 = getelementptr &([16 * i32]* %cnt)[i64 0][i64 6];
    i32* %24 = getelementptr &([16 * i32]* %tail)[i64 0][i64 6];
    i32* %25 = getelementptr &([16 * i32]* %head)[i64 0][i64 6];
    store i32* %25 with i32 0;
    i32* %26 = getelementptr &([16 * i32]* %cnt)[i64 0][i64 7];
    i32* %27 = getelementptr &([16 * i32]* %tail)[i64 0][i64 7];
    i32* %28 = getelementptr &([16 * i32]* %head)[i64 0][i64 7];
    store i32* %28 with i32 0;
    i32* %29 = getelementptr &([16 * i32]* %cnt)[i64 0][i64 8];
    i32* %30 = getelementptr &([16 * i32]* %tail)[i64 0][i64 8];
    i32* %31 = getelementptr &([16 * i32]* %head)[i64 0][i64 8];
    store i32* %31 with i32 0;
    i32* %32 = getelementptr &([16 * i32]* %cnt)[i64 0][i64 9];
    i32* %33 = getelementptr &([16 * i32]* %tail)[i64 0][i64 9];
    i32* %34 = getelementptr &([16 * i32]* %head)[i64 0][i64 9];
    store i32* %34 with i32 0;
    i32* %35 = getelementptr &([16 * i32]* %cnt)[i64 0][i64 10];
    i32* %36 = getelementptr &([16 * i32]* %tail)[i64 0][i64 10];
    i32* %37 = getelementptr &([16 * i32]* %head)[i64 0][i64 10];
    store i32* %37 with i32 0;
    i32* %38 = getelementptr &([16 * i32]* %cnt)[i64 0][i64 11];
    i32* %39 = getelementptr &([16 * i32]* %tail)[i64 0][i64 11];
    i32* %40 = getelementptr &([16 * i32]* %head)[i64 0][i64 11];
    store i32* %40 with i32 0;
    i32* %41 = getelementptr &([16 * i32]* %cnt)[i64 0][i64 12];
    i32* %42 = getelementptr &([16 * i32]* %tail)[i64 0][i64 12];
    i32* %43 = getelementptr &([16 * i32]* %head)[i64 0][i64 12];
    store i32* %43 with i32 0;
    i32* %44 = getelementptr &([16 * i32]* %cnt)[i64 0][i64 13];
    i32* %45 = getelementptr &([16 * i32]* %tail)[i64 0][i64 13];
    i32* %46 = getelementptr &([16 * i32]* %head)[i64 0][i64 13];
    store i32* %46 with i32 0;
    i32* %47 = getelementptr &([16 * i32]* %cnt)[i64 0][i64 14];
    i32* %48 = getelementptr &([16 * i32]* %tail)[i64 0][i64 14];
    i32* %49 = getelementptr &([16 * i32]* %head)[i64 0][i64 14];
    store i32* %49 with i32 0;
    i32* %50 = getelementptr &([16 * i32]* %cnt)[i64 0][i64 15];
    i32* %51 = getelementptr &([16 * i32]* %tail)[i64 0][i64 15];
    i32* %52 = getelementptr &([16 * i32]* %head)[i64 0][i64 15];
    store i32* %52 with i32 0;
    store i32* %6 with i32 0;
    store i32* %9 with i32 0;
    store i32* %12 with i32 0;
    store i32* %15 with i32 0;
    store i32* %18 with i32 0;
    store i32* %21 with i32 0;
    store i32* %24 with i32 0;
    store i32* %27 with i32 0;
    store i32* %30 with i32 0;
    store i32* %33 with i32 0;
    store i32* %36 with i32 0;
    store i32* %39 with i32 0;
    store i32* %42 with i32 0;
    store i32* %45 with i32 0;
    store i32* %48 with i32 0;
    store i32* %51 with i32 0;
    store i32* %5 with i32 0;
    store i32* %8 with i32 0;
    store i32* %11 with i32 0;
    store i32* %14 with i32 0;
    store i32* %17 with i32 0;
    store i32* %20 with i32 0;
    store i32* %23 with i32 0;
    store i32* %26 with i32 0;
    store i32* %29 with i32 0;
    store i32* %32 with i32 0;
    store i32* %35 with i32 0;
    store i32* %38 with i32 0;
    store i32* %41 with i32 0;
    store i32* %44 with i32 0;
    store i32* %47 with i32 0;
    store i32* %50 with i32 0;
    cbr i1 %4(prob = 0.75), ^if.then, ^b;
^b:
    store i32* %i1 with i32 %l;
    i1 %53 = scmp gt i32 %bitround, i32 0;
    i1 %54 = scmp lt i32 %l, i32 %r;
    cbr i1 %54(prob = 0.97), ^while.body, ^b1;
^if.then:
    ret;
^b1:
    store i32* %7 with i32 %l;
    i32 %55 = load i32* %5;
    i32 %56 = add i32 %55, i32 %l;
    store i32* %6 with i32 %56;
    i32 %57 = load i32* %6;
    store i32* %10 with i32 %57;
    i32 %58 = load i32* %8;
    i32 %59 = add i32 %57, i32 %58;
    store i32* %9 with i32 %59;
    i32 %60 = load i32* %9;
    store i32* %13 with i32 %60;
    i32 %61 = load i32* %11;
    i32 %62 = add i32 %60, i32 %61;
    store i32* %12 with i32 %62;
    i32 %63 = load i32* %12;
    store i32* %16 with i32 %63;
    i32 %64 = load i32* %14;
    i32 %65 = add i32 %63, i32 %64;
    store i32* %15 with i32 %65;
    i32 %66 = load i32* %15;
    store i32* %19 with i32 %66;
    i32 %67 = load i32* %17;
    i32 %68 = add i32 %66, i32 %67;
    store i32* %18 with i32 %68;
    i32 %69 = load i32* %18;
    store i32* %22 with i32 %69;
    i32 %70 = load i32* %20;
    i32 %71 = add i32 %69, i32 %70;
    store i32* %21 with i32 %71;
    i32 %72 = load i32* %21;
    store i32* %25 with i32 %72;
    i32 %73 = load i32* %23;
    i32 %74 = add i32 %72, i32 %73;
    store i32* %24 with i32 %74;
    i32 %75 = load i32* %24;
    store i32* %28 with i32 %75;
    i32 %76 = load i32* %26;
    i32 %77 = add i32 %75, i32 %76;
    store i32* %27 with i32 %77;
    i32 %78 = load i32* %27;
    store i32* %31 with i32 %78;
    i32 %79 = load i32* %29;
    i32 %80 = add i32 %78, i32 %79;
    store i32* %30 with i32 %80;
    i32 %81 = load i32* %30;
    store i32* %34 with i32 %81;
    i32 %82 = load i32* %32;
    i32 %83 = add i32 %81, i32 %82;
    store i32* %33 with i32 %83;
    i32 %84 = load i32* %33;
    store i32* %37 with i32 %84;
    i32 %85 = load i32* %35;
    i32 %86 = add i32 %84, i32 %85;
    store i32* %36 with i32 %86;
    i32 %87 = load i32* %36;
    store i32* %40 with i32 %87;
    i32 %88 = load i32* %38;
    i32 %89 = add i32 %87, i32 %88;
    store i32* %39 with i32 %89;
    i32 %90 = load i32* %39;
    store i32* %43 with i32 %90;
    i32 %91 = load i32* %41;
    i32 %92 = add i32 %90, i32 %91;
    store i32* %42 with i32 %92;
    i32 %93 = load i32* %42;
    store i32* %46 with i32 %93;
    i32 %94 = load i32* %44;
    i32 %95 = add i32 %93, i32 %94;
    store i32* %45 with i32 %95;
    i32 %96 = load i32* %45;
    store i32* %49 with i32 %96;
    i32 %97 = load i32* %47;
    i32 %98 = add i32 %96, i32 %97;
    store i32* %48 with i32 %98;
    i32 %99 = load i32* %48;
    store i32* %52 with i32 %99;
    i32 %100 = load i32* %50;
    i32 %101 = add i32 %99, i32 %100;
    store i32* %51 with i32 %101;
    store i32* %i1 with i32 0;
    ubr ^while.guard;
^while.body:
    i32 %102 = phi [^b, i32 %l] [^b2, i32 %103];
    i32 %103 = add i32 %102, i32 1;
    i1 %104 = scmp lt i32 %103, i32 %r;
    i32* %105 = getelementptr &(i32* %a)[i32 %102];
    i32 %106 = load i32* %105;
    cbr i1 %53(prob = 0.97), ^while.body1, ^b2;
^while.body1:
    i32 %107 = phi [^while.body, i32 0] [^while.body1, i32 %109];
    i32 %108 = phi [^while.body, i32 %106] [^while.body1, i32 %110];
    i32 %109 = add i32 %107, i32 1;
    i32 %110 = sdiv i32 %108, i32 16;
    i1 %111 = scmp lt i32 %109, i32 %bitround;
    cbr i1 %111(prob = 0.97), ^while.body1, ^b2;
^while.guard:
    i32 %112 = phi [^b1, i32 %bitround] [^b3, i32 %132];
    i32 %113 = phi [^b1, i32 %l] [^b3, i32 %133];
    i32 %114 = phi [^b1, i32 0] [^b3, i32 %135];
    i32* %115 = getelementptr &([16 * i32]* %tail)[i64 0][i32 %114];
    i32* %116 = getelementptr &([16 * i32]* %head)[i64 0][i32 %114];
    i32 %117 = load i32* %116;
    i32 %118 = load i32* %115;
    i1 %119 = scmp lt i32 %117, i32 %118;
    cbr i1 %119(prob = 0.97), ^while.body2, ^b3;
^b2:
    i32 %120 = phi [^while.body, i32 %106] [^while.body1, i32 %110];
    i32 %121 = srem i32 %120, i32 16;
    i32* %122 = getelementptr &([16 * i32]* %cnt)[i64 0][i32 %121];
    i32 %123 = load i32* %122;
    i32 %124 = add i32 %123, i32 1;
    store i32* %122 with i32 %124;
    store i32* %i1 with i32 %103;
    cbr i1 %104(prob = 0.97), ^while.body, ^b1;
^while.body2:
    i32 %125 = phi [^while.guard, i32 %112] [^b6, i32 %159];
    i32 %126 = phi [^while.guard, i32 %114] [^b6, i32 %161];
    i1 %127 = scmp gt i32 %125, i32 0;
    i32* %128 = getelementptr &([16 * i32]* %head)[i64 0][i32 %126];
    i32 %129 = load i32* %128;
    i32* %130 = getelementptr &(i32* %a)[i32 %129];
    i32 %131 = load i32* %130;
    cbr i1 %127(prob = 0.97), ^while.body3, ^b5;
^b3:
    i32 %132 = phi [^while.guard, i32 %112] [^b6, i32 %159];
    i32 %133 = phi [^while.guard, i32 %113] [^b6, i32 %160];
    i32 %134 = phi [^while.guard, i32 %114] [^b6, i32 %161];
    i32 %135 = add i32 %134, i32 1;
    store i32* %i1 with i32 %135;
    i1 %136 = scmp lt i32 %135, i32 16;
    cbr i1 %136(prob = 0.97), ^while.guard, ^b4;
^b4:
    store i32* %7 with i32 %133;
    i32 %137 = load i32* %5;
    i32 %138 = add i32 %133, i32 %137;
    store i32* %6 with i32 %138;
    store i32* %i with i32 0;
    ubr ^while.body5;
^while.body3:
    i32 %139 = phi [^while.body2, i32 0] [^while.body3, i32 %141];
    i32 %140 = phi [^while.body2, i32 %131] [^while.body3, i32 %142];
    i32 %141 = add i32 %139, i32 1;
    i32 %142 = sdiv i32 %140, i32 16;
    i1 %143 = scmp lt i32 %141, i32 %125;
    cbr i1 %143(prob = 0.97), ^while.body3, ^b5;
^b5:
    i32 %144 = phi [^while.body2, i32 %131] [^while.body3, i32 %142];
    i32 %145 = srem i32 %144, i32 16;
    i1 %146 = scmp neq i32 %145, i32 %126;
    cbr i1 %146(prob = 0.97), ^while.body4, ^b6;
^while.body4:
    i32 %147 = phi [^b5, i32 %125] [^b10, i32 %186];
    i32 %148 = phi [^b5, i32 %131] [^b10, i32 %185];
    i1 %149 = scmp gt i32 %147, i32 0;
    cbr i1 %149(prob = 0.97), ^while.body6, ^b7;
^while.body5:
    i32 %150 = phi [^b4, i32 %132] [^b8, i32 %194];
    i32* %151 = phi [^b4, i32* %a] [^b8, i32* %195];
    i32 %152 = phi [^b4, i32 0] [^b8, i32 %197];
    i1 %153 = scmp gt i32 %152, i32 0;
    cbr i1 %153(prob = 0.5), ^if.then1, ^b8;
^b6:
    i32 %154 = phi [^b5, i32 %126] [^b10, i32 %187];
    i32 %155 = phi [^b5, i32 %131] [^b10, i32 %185];
    i32* %156 = getelementptr &([16 * i32]* %head)[i64 0][i32 %154];
    i32 %157 = load i32* %156;
    i32* %158 = getelementptr &(i32* %a)[i32 %157];
    store i32* %158 with i32 %155;
    i32 %159 = load i32* %bitround1;
    i32 %160 = load i32* %l1;
    i32 %161 = load i32* %i1;
    i32* %162 = getelementptr &([16 * i32]* %tail)[i64 0][i32 %161];
    i32* %163 = getelementptr &([16 * i32]* %head)[i64 0][i32 %161];
    i32 %164 = load i32* %163;
    i32 %165 = add i32 %164, i32 1;
    store i32* %163 with i32 %165;
    i32 %166 = load i32* %162;
    i1 %167 = scmp lt i32 %165, i32 %166;
    cbr i1 %167(prob = 0.97), ^while.body2, ^b3;
^if.then1:
    i32* %168 = getelementptr &([16 * i32]* %cnt)[i64 0][i32 %152];
    i32* %169 = getelementptr &([16 * i32]* %tail)[i64 0][i32 %152];
    i32* %170 = getelementptr &(i32* %169)[i64 -1];
    i32 %171 = load i32* %170;
    i32* %172 = getelementptr &([16 * i32]* %head)[i64 0][i32 %152];
    store i32* %172 with i32 %171;
    i32 %173 = load i32* %168;
    i32 %174 = add i32 %171, i32 %173;
    store i32* %169 with i32 %174;
    ubr ^b8;
^while.body6:
    i32 %175 = phi [^while.body4, i32 0] [^while.body6, i32 %177];
    i32 %176 = phi [^while.body4, i32 %148] [^while.body6, i32 %178];
    i32 %177 = add i32 %175, i32 1;
    i32 %178 = sdiv i32 %176, i32 16;
    i1 %179 = scmp lt i32 %177, i32 %147;
    cbr i1 %179(prob = 0.97), ^while.body6, ^b7;
^b7:
    i32 %180 = phi [^while.body4, i32 %148] [^while.body6, i32 %178];
    i32 %181 = srem i32 %180, i32 16;
    i32* %182 = getelementptr &([16 * i32]* %head)[i64 0][i32 %181];
    i32 %183 = load i32* %182;
    i32* %184 = getelementptr &(i32* %a)[i32 %183];
    i32 %185 = load i32* %184;
    store i32* %184 with i32 %148;
    i32 %186 = load i32* %bitround1;
    i32 %187 = load i32* %i1;
    i1 %188 = scmp gt i32 %186, i32 0;
    cbr i1 %188(prob = 0.97), ^while.body7, ^b9;
^b8:
    i32 %189 = add i32 %150, i32 -1;
    i32* %190 = getelementptr &([16 * i32]* %tail)[i64 0][i32 %152];
    i32* %191 = getelementptr &([16 * i32]* %head)[i64 0][i32 %152];
    i32 %192 = load i32* %191;
    i32 %193 = load i32* %190;
    call (i32, i32*, i32, i32, i32*) -> void @radixSort(i32 %189, i32* %151, i32 %192, i32 %193, i32* %0);
    i32 %194 = load i32* %bitround1;
    i32* %195 = load i32** %a1;
    i32 %196 = load i32* %i;
    i32 %197 = add i32 %196, i32 1;
    store i32* %i with i32 %197;
    i1 %198 = scmp lt i32 %197, i32 16;
    cbr i1 %198(prob = 0.97), ^while.body5, ^if.then;
^while.body7:
    i32 %199 = phi [^b7, i32 0] [^while.body7, i32 %201];
    i32 %200 = phi [^b7, i32 %148] [^while.body7, i32 %202];
    i32 %201 = add i32 %199, i32 1;
    i32 %202 = sdiv i32 %200, i32 16;
    i1 %203 = scmp lt i32 %201, i32 %186;
    cbr i1 %203(prob = 0.97), ^while.body7, ^b9;
^b9:
    i32 %204 = phi [^b7, i32 %148] [^while.body7, i32 %202];
    i32 %205 = srem i32 %204, i32 16;
    i32* %206 = getelementptr &([16 * i32]* %head)[i64 0][i32 %205];
    i32 %207 = load i32* %206;
    i32 %208 = add i32 %207, i32 1;
    store i32* %206 with i32 %208;
    cbr i1 %188(prob = 0.97), ^while.body8, ^b10;
^while.body8:
    i32 %209 = phi [^b9, i32 0] [^while.body8, i32 %211];
    i32 %210 = phi [^b9, i32 %185] [^while.body8, i32 %212];
    i32 %211 = add i32 %209, i32 1;
    i32 %212 = sdiv i32 %210, i32 16;
    i1 %213 = scmp lt i32 %211, i32 %186;
    cbr i1 %213(prob = 0.97), ^while.body8, ^b10;
^b10:
    i32 %214 = phi [^b9, i32 %185] [^while.body8, i32 %212];
    i32 %215 = srem i32 %214, i32 16;
    i1 %216 = scmp neq i32 %215, i32 %187;
    cbr i1 %216(prob = 0.97), ^while.body4, ^b6;
}
internal [30000010 * i32]* @a;
func @main() -> i32 { NoRecurse Entry } {
^entry:
    i32* %ans = alloc i32;
    i32* %n = alloc i32;
    i32* %0 = getelementptr &([30000010 * i32]* @a)[i64 0][i64 0];
    i32 %1 = call (i32*) -> i32 @getarray(i32* %0);
    store i32* %n with i32 %1;
    call (i32) -> void @starttime(i32 90);
    call (i32, i32*, i32, i32, i32*) -> void @radixSort(i32 8, i32* %0, i32 0, i32 %1, i32* %ans);
    i32 %2 = load i32* %n;
    i32 %3 = load i32* %ans;
    i1 %4 = scmp gt i32 %2, i32 0;
    cbr i1 %4(prob = 0.97), ^while.body, ^b;
^while.body:
    i32 %5 = phi [^entry, i32 %3] [^while.body, i32 %14];
    i32 %6 = phi [^entry, i32 0] [^while.body, i32 %7];
    i32 %7 = add i32 %6, i32 1;
    i32 %8 = add i32 %6, i32 2;
    i1 %9 = scmp lt i32 %7, i32 %2;
    i32* %10 = getelementptr &([30000010 * i32]* @a)[i64 0][i32 %6];
    i32 %11 = load i32* %10;
    i32 %12 = srem i32 %11, i32 %8;
    i32 %13 = mul i32 %6, i32 %12;
    i32 %14 = add i32 %5, i32 %13;
    cbr i1 %9(prob = 0.97), ^while.body, ^b;
^b:
    i32 %15 = phi [^entry, i32 %3] [^while.body, i32 %14];
    i1 %16 = scmp lt i32 %15, i32 0;
    cbr i1 %16(prob = 0.5), ^if.then, ^b1;
^if.then:
    i32 %17 = neg i32 %15;
    ubr ^b1;
^b1:
    i32 %18 = phi [^b, i32 %15] [^if.then, i32 %17];
    call (i32) -> void @stoptime(i32 102);
    call (i32) -> void @putint(i32 %18);
    call (i32) -> void @putch(i32 10);
    ret i32 0;
}
