internal func @getint() -> i32 { NoMemoryRead NoMemoryWrite };
internal func @getch() -> i32 { NoMemoryRead NoMemoryWrite };
internal func @putch(i32) -> void { NoMemoryRead NoMemoryWrite };
internal func @starttime(i32) -> void { NoMemoryRead NoMemoryWrite };
internal func @stoptime(i32) -> void { NoMemoryRead NoMemoryWrite };
internal [500 * [500 * i32]]* @sheet1, align 8 { Flexible };
internal [500 * [500 * i32]]* @sheet2, align 8 { Flexible };
func @main() -> i32 { NoRecurse Entry } {
  ^entry:
    i32 %0 = call () -> i32 @getint();
    i32 %1 = call () -> i32 @getint();
    i1 %2 = icmp sgt i32 %1, i32 0;
    i1 %3 = icmp sgt i32 %0, i32 0;
    i32 %4 = call () -> i32 @getint();
    i32 %5 = call () -> i32 @getch();
    [500 * [500 * i32]]* %6 = ptrcast [500 * [500 * i32]]* @sheet1 to [500 * [500 * i32]]*;
    cbr i1 %2(prob = 0.984615), ^while.body, ^b;
  ^while.body:
    i32 %7 = phi [^entry, i32 1] [^b1, i32 %14];
    cbr i1 %3(prob = 0.984615), ^indirect, ^b1;
  ^b:
    call (i32) -> void @starttime(i32 95);
    i1 %8 = icmp sgt i32 %4, i32 0;
    [500 * [500 * i32]]* %9 = ptrcast [500 * [500 * i32]]* @sheet2 to [500 * [500 * i32]]*;
    cbr i1 %8(prob = 0.984615), ^indirect1, ^b2;
  ^indirect:
    [500 * i32]* %10 = getelementptr &([500 * [500 * i32]]* %6)[i64 0][i32 %7];
    ubr ^while.body1;
  ^indirect1:
    [500 * i32]* %11 = getelementptr &([500 * [500 * i32]]* %6)[i64 0][i64 0];
    [500 * i32]* %12 = getelementptr &([500 * [500 * i32]]* %9)[i64 0][i64 0];
    ubr ^while.body2;
  ^b1:
    i32 %13 = call () -> i32 @getch();
    i32 %14 = add i32 %7, i32 1;
    i1 %15 = icmp sge i32 %1, i32 %14;
    cbr i1 %15(prob = 0.984615), ^while.body, ^b;
  ^b2:
    i32 %16 = phi [^b, i32 1] [^b4, i32 %31];
    i1 %17 = icmp eq i32 %16, i32 2;
    call (i32) -> void @stoptime(i32 106);
    cbr i1 %17(prob = 0.5), ^if.then, ^b3;
  ^while.body1:
    i32 %18 = phi [^indirect, i32 1] [^while.body1, i32 %23];
    i32 %19 = call () -> i32 @getch();
    i1 %20 = icmp eq i32 %19, i32 35;
    i32 %21 = zext i1 %20 to i32;
    i32* %22 = getelementptr &([500 * i32]* %10)[i64 0][i32 %18];
    store i32* %22 with i32 %21;
    i32 %23 = add i32 %18, i32 1;
    i1 %24 = icmp sge i32 %0, i32 %23;
    cbr i1 %24(prob = 0.984615), ^while.body1, ^b1;
  ^while.body2:
    i32 %25 = phi [^indirect1, i32 %4] [^b4, i32 %38];
    i32 %26 = phi [^indirect1, i32 1] [^b4, i32 %31];
    i1 %27 = icmp eq i32 %26, i32 1;
    [500 * i32]* %28 = select i1 %27 ? [500 * i32]* %11 : [500 * i32]* %12;
    [500 * i32]* %29 = select i1 %27 ? [500 * i32]* %12 : [500 * i32]* %11;
    i32 %30 = zext i1 %27 to i32;
    i32 %31 = add i32 %30, i32 1;
    cbr i1 %2(prob = 0.984615), ^while.body3, ^b4;
  ^if.then:
    cbr i1 %2(prob = 0.984615), ^while.body4, ^b5;
  ^b3:
    cbr i1 %2(prob = 0.984615), ^while.body5, ^b5;
  ^while.body3:
    i32 %32 = phi [^while.body2, i32 1] [^b6, i32 %37];
    [500 * i32]* %33 = getelementptr &([500 * i32]* %28)[i32 %32];
    [500 * i32]* %34 = getelementptr &([500 * i32]* %33)[i64 -1];
    [500 * i32]* %35 = getelementptr &([500 * i32]* %33)[i64 1];
    [500 * i32]* %36 = getelementptr &([500 * i32]* %29)[i32 %32];
    i32 %37 = add i32 %32, i32 1;
    cbr i1 %3(prob = 0.984615), ^while.body6, ^b6;
  ^b4:
    i32 %38 = add i32 %25, i32 -1;
    i1 %39 = icmp sgt i32 %38, i32 0;
    cbr i1 %39(prob = 0.984615), ^while.body2, ^b2;
  ^while.body4:
    i32 %40 = phi [^if.then, i32 1] [^b7, i32 %84];
    [500 * i32]* %41 = getelementptr &([500 * [500 * i32]]* %6)[i64 0][i32 %40];
    [500 * i32]* %42 = getelementptr &([500 * [500 * i32]]* %9)[i64 0][i32 %40];
    cbr i1 %3(prob = 0.984615), ^while.body7, ^b7;
  ^while.body5:
    i32 %43 = phi [^b3, i32 1] [^b8, i32 %93];
    [500 * i32]* %44 = getelementptr &([500 * [500 * i32]]* %6)[i64 0][i32 %43];
    cbr i1 %3(prob = 0.984615), ^while.body8, ^b8;
  ^b5:
    ret i32 0;
  ^while.body6:
    i32 %45 = phi [^while.body3, i32 1] [^b9, i32 %76];
    i32* %46 = getelementptr &([500 * i32]* %34)[i64 0][i32 %45];
    i32* %47 = getelementptr &(i32* %46)[i64 -1];
    i32 %48 = load i32* %47;
    i32 %49 = load i32* %46;
    i32 %50 = add i32 %48, i32 %49;
    i32* %51 = getelementptr &(i32* %46)[i64 1];
    i32 %52 = load i32* %51;
    i32 %53 = add i32 %50, i32 %52;
    i32* %54 = getelementptr &([500 * i32]* %33)[i64 0][i32 %45];
    i32* %55 = getelementptr &(i32* %54)[i64 -1];
    i32 %56 = load i32* %55;
    i32 %57 = add i32 %53, i32 %56;
    i32* %58 = getelementptr &(i32* %54)[i64 1];
    i32 %59 = load i32* %58;
    i32 %60 = add i32 %57, i32 %59;
    i32* %61 = getelementptr &([500 * i32]* %35)[i64 0][i32 %45];
    i32* %62 = getelementptr &(i32* %61)[i64 -1];
    i32 %63 = load i32* %62;
    i32 %64 = add i32 %60, i32 %63;
    i32 %65 = load i32* %61;
    i32 %66 = add i32 %64, i32 %65;
    i32* %67 = getelementptr &(i32* %61)[i64 1];
    i32 %68 = load i32* %67;
    i32 %69 = add i32 %66, i32 %68;
    i32 %70 = xor i32 %69, i32 2;
    i32 %71 = load i32* %54;
    i32 %72 = xor i32 %71, i32 1;
    i32 %73 = or i32 %70, i32 %72;
    i1 %74 = icmp eq i32 %73, i32 0;
    i32* %75 = getelementptr &([500 * i32]* %36)[i64 0][i32 %45];
    i32 %76 = add i32 %45, i32 1;
    cbr i1 %74(prob = 0.5), ^if.then1, ^if.else;
  ^b6:
    i1 %77 = icmp sge i32 %1, i32 %37;
    cbr i1 %77(prob = 0.984615), ^while.body3, ^b4;
  ^while.body7:
    i32 %78 = phi [^while.body4, i32 1] [^while.body7, i32 %82];
    i32* %79 = getelementptr &([500 * i32]* %42)[i64 0][i32 %78];
    i32 %80 = load i32* %79;
    i32* %81 = getelementptr &([500 * i32]* %41)[i64 0][i32 %78];
    store i32* %81 with i32 %80;
    i32 %82 = add i32 %78, i32 1;
    i1 %83 = icmp sge i32 %0, i32 %82;
    cbr i1 %83(prob = 0.984615), ^while.body7, ^b7;
  ^b7:
    i32 %84 = add i32 %40, i32 1;
    i1 %85 = icmp sge i32 %1, i32 %84;
    cbr i1 %85(prob = 0.984615), ^while.body4, ^b3;
  ^while.body8:
    i32 %86 = phi [^while.body5, i32 1] [^while.body8, i32 %91];
    i32* %87 = getelementptr &([500 * i32]* %44)[i64 0][i32 %86];
    i32 %88 = load i32* %87;
    i1 %89 = icmp eq i32 %88, i32 1;
    i32 %90 = select i1 %89 ? i32 35 : i32 46;
    call (i32) -> void @putch(i32 %90);
    i32 %91 = add i32 %86, i32 1;
    i1 %92 = icmp sge i32 %0, i32 %91;
    cbr i1 %92(prob = 0.984615), ^while.body8, ^b8;
  ^b8:
    call (i32) -> void @putch(i32 10);
    i32 %93 = add i32 %43, i32 1;
    i1 %94 = icmp sge i32 %1, i32 %93;
    cbr i1 %94(prob = 0.984615), ^while.body5, ^b5;
  ^if.then1:
    store i32* %75 with i32 1;
    ubr ^b9;
  ^if.else:
    i1 %95 = icmp eq i32 %69, i32 3;
    i32 %96 = zext i1 %95 to i32;
    store i32* %75 with i32 %96;
    ubr ^b9;
  ^b9:
    i1 %97 = icmp sge i32 %0, i32 %76;
    cbr i1 %97(prob = 0.984615), ^while.body6, ^b6;
}
