internal func @getint() -> i32 { NoMemoryRead NoMemoryWrite };
internal func @getch() -> i32 { NoMemoryRead NoMemoryWrite };
internal func @putch() -> void { NoMemoryRead NoMemoryWrite };
internal func @starttime() -> void { NoMemoryRead NoMemoryWrite };
internal func @stoptime() -> void { NoMemoryRead NoMemoryWrite };
internal [500 * [500 * i32]]* @sheet1;
internal [500 * [500 * i32]]* @sheet2;
func @main() -> i32 { NoRecurse Entry } {
  ^entry:
    i32 %0 = call () -> i32 @getint();
    i1 %1 = scmp gt i32 %0, i32 0;
    i32 %2 = call () -> i32 @getint();
    i32 %3 = call () -> i32 @getint();
    i32 %4 = call () -> i32 @getch();
    [500 * [500 * i32]]* %5 = ptrcast [500 * [500 * i32]]* @sheet1 to [500 * [500 * i32]]*;
    ubr ^while.header;
  ^while.header:
    i32 %6 = phi [^entry, i32 1] [^b, i32 %12];
    i1 %7 = scmp ge i32 %2, i32 %6;
    cbr i1 %7(prob = 0.97), ^while.body, ^entry1;
  ^while.body:
    cbr i1 %1(prob = 0.97), ^indirect, ^b;
  ^entry1:
    call (i32) -> void @starttime(i32 95);
    i1 %8 = scmp gt i32 %3, i32 0;
    [500 * [500 * i32]]* %9 = ptrcast [500 * [500 * i32]]* @sheet2 to [500 * [500 * i32]]*;
    cbr i1 %8(prob = 0.97), ^while.body1, ^b1;
  ^indirect:
    [500 * i32]* %10 = getelementptr &([500 * [500 * i32]]* %5)[i64 0][i32 %6];
    ubr ^while.body2;
  ^b:
    i32 %11 = call () -> i32 @getch();
    i32 %12 = add i32 %6, i32 1;
    ubr ^while.header;
  ^while.body1:
    i32 %13 = phi [^entry1, i32 %3] [^while.body3, i32 %44];
    i32 %14 = phi [^entry1, i32 1] [^while.body3, i32 %21];
    i1 %15 = scmp eq i32 %14, i32 1;
    [500 * [500 * i32]]* %16 = select i1 %15 ? [500 * [500 * i32]]* %5 : [500 * [500 * i32]]* %9;
    [500 * i32]* %17 = getelementptr &([500 * [500 * i32]]* %16)[i64 0][i64 0];
    [500 * [500 * i32]]* %18 = select i1 %15 ? [500 * [500 * i32]]* %9 : [500 * [500 * i32]]* %5;
    [500 * i32]* %19 = getelementptr &([500 * [500 * i32]]* %18)[i64 0][i64 0];
    i32 %20 = zext i1 %15 to i32;
    i32 %21 = add i32 %20, i32 1;
    ubr ^while.header1;
  ^b1:
    i32 %22 = phi [^entry1, i32 1] [^while.body3, i32 %21];
    call (i32) -> void @stoptime(i32 106);
    i1 %23 = scmp eq i32 %22, i32 2;
    cbr i1 %23(prob = 0.5), ^while.header2, ^while.header3;
  ^while.body2:
    i32 %24 = phi [^indirect, i32 1] [^while.body2, i32 %29];
    i32 %25 = call () -> i32 @getch();
    i1 %26 = scmp eq i32 %25, i32 35;
    i32 %27 = zext i1 %26 to i32;
    i32* %28 = getelementptr &([500 * i32]* %10)[i64 0][i32 %24];
    store i32* %28 with i32 %27;
    i32 %29 = add i32 %24, i32 1;
    i1 %30 = scmp ge i32 %0, i32 %29;
    cbr i1 %30(prob = 0.97), ^while.body2, ^b;
  ^while.header1:
    i32 %31 = phi [^while.body1, i32 1] [^b3, i32 %46];
    i32 %32 = add i32 %31, i32 -1;
    [500 * i32]* %33 = getelementptr &([500 * i32]* %17)[i32 %32];
    [500 * i32]* %34 = getelementptr &([500 * i32]* %17)[i32 %31];
    [500 * i32]* %35 = getelementptr &([500 * i32]* %34)[i64 1];
    i1 %36 = scmp ge i32 %2, i32 %31;
    [500 * i32]* %37 = getelementptr &([500 * i32]* %19)[i32 %31];
    cbr i1 %36(prob = 0.97), ^while.header4, ^while.body3;
  ^while.header2:
    i32 %38 = phi [^b1, i32 1] [^b4, i32 %79];
    i1 %39 = scmp ge i32 %2, i32 %38;
    cbr i1 %39(prob = 0.97), ^while.body4, ^while.header3;
  ^while.header3:
    i32 %40 = phi [^b1, i32 1] [^while.header2, i32 1] [^b5, i32 %81];
    i1 %41 = scmp ge i32 %2, i32 %40;
    cbr i1 %41(prob = 0.97), ^while.body5, ^b2;
  ^while.header4:
    i32 %42 = phi [^while.header1, i32 1] [^b6, i32 %99];
    i1 %43 = scmp ge i32 %0, i32 %42;
    cbr i1 %43(prob = 0.97), ^while.body6, ^b3;
  ^while.body3:
    i32 %44 = add i32 %13, i32 -1;
    i1 %45 = scmp gt i32 %44, i32 0;
    cbr i1 %45(prob = 0.97), ^while.body1, ^b1;
  ^while.body4:
    cbr i1 %1(prob = 0.97), ^indirect1, ^b4;
  ^while.body5:
    cbr i1 %1(prob = 0.97), ^indirect2, ^b5;
  ^b2:
    ret i32 0;
  ^b3:
    i32 %46 = add i32 %31, i32 1;
    ubr ^while.header1;
  ^indirect1:
    [500 * i32]* %47 = getelementptr &([500 * [500 * i32]]* %5)[i64 0][i32 %38];
    [500 * i32]* %48 = getelementptr &([500 * [500 * i32]]* %9)[i64 0][i32 %38];
    ubr ^while.body7;
  ^while.body6:
    i32 %49 = add i32 %42, i32 -1;
    i32* %50 = getelementptr &([500 * i32]* %33)[i64 0][i32 %49];
    i32 %51 = load i32* %50;
    i32* %52 = getelementptr &([500 * i32]* %33)[i64 0][i32 %42];
    i32 %53 = load i32* %52;
    i32 %54 = add i32 %51, i32 %53;
    i32* %55 = getelementptr &(i32* %52)[i64 1];
    i32 %56 = load i32* %55;
    i32 %57 = add i32 %54, i32 %56;
    i32* %58 = getelementptr &([500 * i32]* %34)[i64 0][i32 %49];
    i32 %59 = load i32* %58;
    i32 %60 = add i32 %57, i32 %59;
    i32* %61 = getelementptr &(i32* %58)[i64 2];
    i32 %62 = load i32* %61;
    i32 %63 = add i32 %60, i32 %62;
    i32* %64 = getelementptr &([500 * i32]* %35)[i64 0][i32 %49];
    i32 %65 = load i32* %64;
    i32 %66 = add i32 %63, i32 %65;
    i32* %67 = getelementptr &([500 * i32]* %35)[i64 0][i32 %42];
    i32 %68 = load i32* %67;
    i32 %69 = add i32 %66, i32 %68;
    i32* %70 = getelementptr &(i32* %67)[i64 1];
    i32 %71 = load i32* %70;
    i32 %72 = add i32 %69, i32 %71;
    i32 %73 = xor i32 %72, i32 2;
    i32* %74 = getelementptr &([500 * i32]* %34)[i64 0][i32 %42];
    i32 %75 = load i32* %74;
    i32 %76 = xor i32 %75, i32 1;
    i32 %77 = or i32 %73, i32 %76;
    i1 %78 = scmp eq i32 %77, i32 0;
    cbr i1 %78(prob = 0.5), ^if.then, ^if.else;
  ^b4:
    i32 %79 = add i32 %38, i32 1;
    ubr ^while.header2;
  ^indirect2:
    [500 * i32]* %80 = getelementptr &([500 * [500 * i32]]* %5)[i64 0][i32 %40];
    ubr ^while.body8;
  ^b5:
    call (i32) -> void @putch(i32 10);
    i32 %81 = add i32 %40, i32 1;
    ubr ^while.header3;
  ^if.then:
    i32* %82 = getelementptr &([500 * i32]* %37)[i64 0][i32 %42];
    store i32* %82 with i32 1;
    ubr ^b6;
  ^if.else:
    i1 %83 = scmp eq i32 %72, i32 3;
    i32 %84 = zext i1 %83 to i32;
    i32* %85 = getelementptr &([500 * i32]* %37)[i64 0][i32 %42];
    store i32* %85 with i32 %84;
    ubr ^b6;
  ^while.body7:
    i32 %86 = phi [^indirect1, i32 1] [^while.body7, i32 %90];
    i32* %87 = getelementptr &([500 * i32]* %48)[i64 0][i32 %86];
    i32 %88 = load i32* %87;
    i32* %89 = getelementptr &([500 * i32]* %47)[i64 0][i32 %86];
    store i32* %89 with i32 %88;
    i32 %90 = add i32 %86, i32 1;
    i1 %91 = scmp ge i32 %0, i32 %90;
    cbr i1 %91(prob = 0.97), ^while.body7, ^b4;
  ^while.body8:
    i32 %92 = phi [^indirect2, i32 1] [^while.body8, i32 %97];
    i32* %93 = getelementptr &([500 * i32]* %80)[i64 0][i32 %92];
    i32 %94 = load i32* %93;
    i1 %95 = scmp eq i32 %94, i32 1;
    i32 %96 = select i1 %95 ? i32 35 : i32 46;
    call (i32) -> void @putch(i32 %96);
    i32 %97 = add i32 %92, i32 1;
    i1 %98 = scmp ge i32 %0, i32 %97;
    cbr i1 %98(prob = 0.97), ^while.body8, ^b5;
  ^b6:
    i32 %99 = add i32 %42, i32 1;
    ubr ^while.header4;
}
