internal func @getfarray() -> i32 { NoMemoryRead };
internal func @putfloat() -> void { NoMemoryRead NoMemoryWrite };
internal func @starttime() -> void { NoMemoryRead NoMemoryWrite };
internal func @stoptime() -> void { NoMemoryRead NoMemoryWrite };
internal [1000 * [1000 * f32]]* @a;
func @main() -> i32 { NoRecurse Entry } {
^entry:
    [1000 * f32]* %var = alloc [1000 * f32];
    [1000 * f32]* %mean = alloc [1000 * f32];
    f32* %sum = alloc f32;
    i32* %i = alloc i32;
    store f32* %sum with f32 0;
    store i32* %i with i32 0;
    ubr ^while.header;
^while.header:
    i32 %0 = phi [^b1, i32 %9] [^entry, i32 0];
    f32 %1 = phi [^b1, f32 %7] [^entry, f32 0];
    i1 %2 = scmp lt i32 %0, i32 1000;
    cbr i1 %2(prob = 0.97), ^while.body, ^b;
^b:
    call (i32) -> void @starttime(i32 42);
    ubr ^while.header1;
^while.body:
    [1000 * f32]* %3 = getelementptr &([1000 * [1000 * f32]]* @a)[i64 0][i32 %0];
    f32* %4 = getelementptr &([1000 * f32]* %3)[i64 0][i64 0];
    i32 %5 = call (f32*) -> i32 @getfarray(f32* %4);
    i32 %6 = load i32* %i;
    f32 %7 = load f32* %sum;
    i1 %8 = scmp neq i32 %5, i32 1000;
    cbr i1 %8(prob = 0.5), ^if.then, ^b1;
^b1:
    i32 %9 = add i32 %6, i32 1;
    store i32* %i with i32 %9;
    ubr ^while.header;
^while.header1:
    i32 %10 = phi [^b5, i32 %52] [^b, i32 0];
    f32 %11 = phi [^b5, f32 %37] [^b, f32 %1];
    i1 %12 = scmp lt i32 %10, i32 100;
    cbr i1 %12(prob = 0.97), ^while.header2, ^while.header3;
^if.then:
    ret i32 %5;
^while.header2:
    i32 %13 = phi [^while.header1, i32 0] [^b4, i32 %49];
    i1 %14 = scmp lt i32 %13, i32 1000;
    cbr i1 %14(prob = 0.97), ^while.body1, ^while.header4;
^while.header3:
    i32 %15 = phi [^while.header1, i32 0] [^b3, i32 %35];
    f32 %16 = phi [^while.header1, f32 %11] [^b3, f32 %24];
    i1 %17 = scmp lt i32 %15, i32 1000;
    [1000 * f32]* %18 = getelementptr &([1000 * [1000 * f32]]* @a)[i64 0][i32 %15];
    cbr i1 %17(prob = 0.97), ^while.header5, ^b2;
^while.body1:
    [1000 * f32]* %19 = getelementptr &([1000 * [1000 * f32]]* @a)[i64 0][i32 %13];
    f32* %20 = getelementptr &([1000 * f32]* %mean)[i64 0][i32 %13];
    store f32* %20 with f32 0;
    ubr ^while.header6;
^while.header4:
    i32 %21 = phi [^while.header2, i32 0] [^b9, i32 %86];
    i1 %22 = scmp lt i32 %21, i32 1000;
    cbr i1 %22(prob = 0.97), ^while.body2, ^while.header7;
^while.header5:
    i32 %23 = phi [^while.header3, i32 0] [^while.body3, i32 %32];
    f32 %24 = phi [^while.header3, f32 %16] [^while.body3, f32 %31];
    i1 %25 = scmp lt i32 %23, i32 1000;
    cbr i1 %25(prob = 0.97), ^while.body3, ^b3;
^b2:
    call (i32) -> void @stoptime(i32 95);
    call (f32) -> void @putfloat(f32 %16);
    ret i32 0;
^while.body2:
    f32* %26 = getelementptr &([1000 * f32]* %mean)[i64 0][i32 %21];
    [1000 * f32]* %27 = getelementptr &([1000 * [1000 * f32]]* @a)[i64 0][i32 %21];
    f32* %28 = getelementptr &([1000 * f32]* %var)[i64 0][i32 %21];
    store f32* %28 with f32 0;
    ubr ^while.header8;
^while.body3:
    f32* %29 = getelementptr &([1000 * f32]* %18)[i64 0][i32 %23];
    f32 %30 = load f32* %29;
    f32 %31 = fadd f32 %24, f32 %30;
    i32 %32 = add i32 %23, i32 1;
    ubr ^while.header5;
^while.header6:
    i32 %33 = phi [^while.body4, i32 %46] [^while.body1, i32 0];
    i1 %34 = scmp lt i32 %33, i32 1000;
    cbr i1 %34(prob = 0.97), ^while.body4, ^b4;
^b3:
    i32 %35 = add i32 %15, i32 1;
    ubr ^while.header3;
^while.header7:
    i32 %36 = phi [^while.header4, i32 0] [^b7, i32 %76];
    f32 %37 = phi [^while.header4, f32 %11] [^b7, f32 %54];
    i1 %38 = scmp lt i32 %36, i32 1000;
    [1000 * f32]* %39 = getelementptr &([1000 * [1000 * f32]]* @a)[i64 0][i32 %36];
    f32* %40 = getelementptr &([1000 * f32]* %mean)[i64 0][i32 %36];
    f32* %41 = getelementptr &([1000 * f32]* %var)[i64 0][i32 %36];
    cbr i1 %38(prob = 0.97), ^while.header9, ^b5;
^while.body4:
    f32 %42 = load f32* %20;
    f32* %43 = getelementptr &([1000 * f32]* %19)[i64 0][i32 %33];
    f32 %44 = load f32* %43;
    f32 %45 = fadd f32 %42, f32 %44;
    store f32* %20 with f32 %45;
    i32 %46 = add i32 %33, i32 1;
    ubr ^while.header6;
^b4:
    f32 %47 = load f32* %20;
    f32 %48 = fdiv f32 %47, f32 1000;
    store f32* %20 with f32 %48;
    i32 %49 = add i32 %13, i32 1;
    ubr ^while.header2;
^while.header8:
    i32 %50 = phi [^while.body5, i32 %63] [^while.body2, i32 0];
    i1 %51 = scmp lt i32 %50, i32 1000;
    cbr i1 %51(prob = 0.97), ^while.body5, ^b6;
^b5:
    i32 %52 = add i32 %10, i32 1;
    ubr ^while.header1;
^while.header9:
    i32 %53 = phi [^while.header7, i32 0] [^while.body6, i32 %75];
    f32 %54 = phi [^while.header7, f32 %37] [^while.body6, f32 %74];
    i1 %55 = scmp lt i32 %53, i32 1000;
    cbr i1 %55(prob = 0.97), ^while.body6, ^b7;
^while.body5:
    f32 %56 = load f32* %28;
    f32* %57 = getelementptr &([1000 * f32]* %27)[i64 0][i32 %50];
    f32 %58 = load f32* %57;
    f32 %59 = load f32* %26;
    f32 %60 = fsub f32 %58, f32 %59;
    f32 %61 = fmul f32 %60, f32 %60;
    f32 %62 = fadd f32 %56, f32 %61;
    store f32* %28 with f32 %62;
    i32 %63 = add i32 %50, i32 1;
    ubr ^while.header8;
^b6:
    f32 %64 = load f32* %28;
    f32 %65 = fdiv f32 %64, f32 1000;
    f32 %66 = fadd f32 %65, f32 0.01;
    f32 %67 = fdiv f32 %66, f32 2;
    ubr ^while.header10;
^while.body6:
    f32* %68 = getelementptr &([1000 * f32]* %39)[i64 0][i32 %53];
    f32 %69 = load f32* %68;
    f32 %70 = load f32* %40;
    f32 %71 = fsub f32 %69, f32 %70;
    f32 %72 = load f32* %41;
    f32 %73 = fdiv f32 %71, f32 %72;
    store f32* %68 with f32 %73;
    f32 %74 = fadd f32 %54, f32 %73;
    i32 %75 = add i32 %53, i32 1;
    ubr ^while.header9;
^b7:
    i32 %76 = add i32 %36, i32 1;
    ubr ^while.header7;
^while.header10:
    f32 %77 = phi [^if.else, f32 %91] [^if.then2, f32 %89] [^b6, f32 %67];
    f32 %78 = phi [^if.else, f32 %78] [^if.then2, f32 %77] [^b6, f32 %66];
    f32 %79 = phi [^if.else, f32 %77] [^if.then2, f32 %79] [^b6, f32 0];
    f32 %80 = fmul f32 %77, f32 %77;
    f32 %81 = fsub f32 %80, f32 %66;
    i1 %82 = fcmp lt f32 %81, f32 0;
    cbr i1 %82(prob = 0.5), ^if.then1, ^b8;
^if.then1:
    f32 %83 = fneg f32 %81;
    ubr ^b8;
^b8:
    f32 %84 = phi [^while.header10, f32 %81] [^if.then1, f32 %83];
    i1 %85 = fcmp gt f32 %84, f32 0.001;
    cbr i1 %85(prob = 0.97), ^while.body7, ^b9;
^b9:
    store f32* %28 with f32 %77;
    i32 %86 = add i32 %21, i32 1;
    ubr ^while.header4;
^while.body7:
    i1 %87 = fcmp gt f32 %80, f32 %66;
    cbr i1 %87(prob = 0.5), ^if.then2, ^if.else;
^if.then2:
    f32 %88 = fadd f32 %77, f32 %79;
    f32 %89 = fdiv f32 %88, f32 2;
    ubr ^while.header10;
^if.else:
    f32 %90 = fadd f32 %77, f32 %78;
    f32 %91 = fdiv f32 %90, f32 2;
    ubr ^while.header10;
}
