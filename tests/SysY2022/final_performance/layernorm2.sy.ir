internal func @getint() -> i32 { NoMemoryRead NoMemoryWrite };
internal func @getch() -> i32 { NoMemoryRead NoMemoryWrite };
internal func @getarray() -> i32 { NoMemoryRead };
internal func @getfloat() -> f32 { NoMemoryRead NoMemoryWrite };
internal func @getfarray() -> i32 { NoMemoryRead };
internal func @putint() -> void { NoMemoryRead NoMemoryWrite };
internal func @putch() -> void { NoMemoryRead NoMemoryWrite };
internal func @putarray() -> void { NoMemoryWrite };
internal func @putfloat() -> void { NoMemoryRead NoMemoryWrite };
internal func @putfarray() -> void { NoMemoryWrite };
internal func @starttime() -> void { NoMemoryRead NoMemoryWrite };
internal func @stoptime() -> void { NoMemoryRead NoMemoryWrite };
internal func @myAbs(f32 %x) -> f32 {
^entry:
    f32* %x1 = alloc f32;
    store f32* %x1 with f32 %x;
    f32 %0 = load f32* %x1;
    i1 %1 = fcmp lt f32 %0, f32 0;
    i32 %2 = zext i1 %1 to i32;
    i1 %3 = scmp neq i32 %2, i32 0;
    cbr i1 %3(prob = 0.5), ^if.then, ^b;
^if.then:
    f32 %4 = load f32* %x1;
    f32 %5 = fneg f32 %4;
    store f32* %x1 with f32 %5;
    ubr ^b;
^b:
    f32 %6 = load f32* %x1;
    ret f32 %6;
}
internal func @sqrt(f32 %x) -> f32 {
^entry:
    f32* %mid = alloc f32;
    f32* %end = alloc f32;
    f32* %start = alloc f32;
    f32* %x1 = alloc f32;
    store f32* %x1 with f32 %x;
    store f32* %start with f32 0;
    f32 %0 = load f32* %x1;
    store f32* %end with f32 %0;
    f32 %1 = load f32* %start;
    f32 %2 = load f32* %end;
    f32 %3 = fadd f32 %1, f32 %2;
    f32 %4 = fdiv f32 %3, f32 2;
    store f32* %mid with f32 %4;
    ubr ^while.header;
^while.header:
    f32 %5 = load f32* %mid;
    f32 %6 = load f32* %mid;
    f32 %7 = fmul f32 %5, f32 %6;
    f32 %8 = load f32* %x1;
    f32 %9 = fsub f32 %7, f32 %8;
    f32 %10 = call (f32) -> f32 @myAbs(f32 %9);
    i1 %11 = fcmp gt f32 %10, f32 0.001;
    i32 %12 = zext i1 %11 to i32;
    i1 %13 = scmp neq i32 %12, i32 0;
    cbr i1 %13(prob = 0.97), ^while.body, ^b;
^while.body:
    f32 %14 = load f32* %mid;
    f32 %15 = load f32* %mid;
    f32 %16 = fmul f32 %14, f32 %15;
    f32 %17 = load f32* %x1;
    i1 %18 = fcmp gt f32 %16, f32 %17;
    i32 %19 = zext i1 %18 to i32;
    i1 %20 = scmp neq i32 %19, i32 0;
    cbr i1 %20(prob = 0.5), ^if.then, ^if.else;
^b:
    f32 %21 = load f32* %mid;
    ret f32 %21;
^if.then:
    f32 %22 = load f32* %mid;
    store f32* %end with f32 %22;
    f32 %23 = load f32* %mid;
    f32 %24 = load f32* %start;
    f32 %25 = fadd f32 %23, f32 %24;
    f32 %26 = fdiv f32 %25, f32 2;
    store f32* %mid with f32 %26;
    ubr ^b1;
^if.else:
    f32 %27 = load f32* %mid;
    store f32* %start with f32 %27;
    f32 %28 = load f32* %mid;
    f32 %29 = load f32* %end;
    f32 %30 = fadd f32 %28, f32 %29;
    f32 %31 = fdiv f32 %30, f32 2;
    store f32* %mid with f32 %31;
    ubr ^b1;
^b1:
    ubr ^while.header;
}
internal [1000 * [1000 * f32]]* @a;
func @main() -> i32 { Entry } {
^entry:
    [1000 * f32]* %var = alloc [1000 * f32];
    [1000 * f32]* %mean = alloc [1000 * f32];
    f32* %sum = alloc f32;
    i32* %k = alloc i32;
    i32* %j = alloc i32;
    i32* %i = alloc i32;
    i32* %n = alloc i32;
    store i32* %n with i32 0;
    store i32* %i with i32 0;
    store i32* %j with i32 0;
    store i32* %k with i32 0;
    store f32* %sum with f32 0;
    store i32* %i with i32 0;
    ubr ^while.header;
^while.header:
    i32 %0 = load i32* %i;
    i1 %1 = scmp lt i32 %0, i32 1000;
    i32 %2 = zext i1 %1 to i32;
    i1 %3 = scmp neq i32 %2, i32 0;
    cbr i1 %3(prob = 0.97), ^while.body, ^b;
^b:
    call (i32) -> void @starttime(i32 42);
    store i32* %k with i32 0;
    ubr ^while.header1;
^while.body:
    i32 %4 = load i32* %i;
    i64 %5 = sext i32 %4 to i64;
    [1000 * f32]* %6 = getelementptr &([1000 * [1000 * f32]]* @a)[i64 0][i64 %5];
    f32* %7 = getelementptr &([1000 * f32]* %6)[i64 0][i64 0];
    i32 %8 = call (f32*) -> i32 @getfarray(f32* %7);
    store i32* %n with i32 %8;
    i32 %9 = load i32* %n;
    i1 %10 = scmp neq i32 %9, i32 1000;
    i32 %11 = zext i1 %10 to i32;
    i1 %12 = scmp neq i32 %11, i32 0;
    cbr i1 %12(prob = 0.5), ^if.then, ^b1;
^b1:
    i32 %13 = load i32* %i;
    i32 %14 = add i32 %13, i32 1;
    store i32* %i with i32 %14;
    ubr ^while.header;
^while.header1:
    i32 %15 = load i32* %k;
    i1 %16 = scmp lt i32 %15, i32 100;
    i32 %17 = zext i1 %16 to i32;
    i1 %18 = scmp neq i32 %17, i32 0;
    cbr i1 %18(prob = 0.97), ^while.body1, ^b2;
^if.then:
    i32 %19 = load i32* %n;
    ret i32 %19;
^while.body1:
    store i32* %i with i32 0;
    ubr ^while.header2;
^b2:
    store i32* %i with i32 0;
    ubr ^while.header3;
^while.header2:
    i32 %20 = load i32* %i;
    i1 %21 = scmp lt i32 %20, i32 1000;
    i32 %22 = zext i1 %21 to i32;
    i1 %23 = scmp neq i32 %22, i32 0;
    cbr i1 %23(prob = 0.97), ^while.body2, ^b3;
^while.header3:
    i32 %24 = load i32* %i;
    i1 %25 = scmp lt i32 %24, i32 1000;
    i32 %26 = zext i1 %25 to i32;
    i1 %27 = scmp neq i32 %26, i32 0;
    cbr i1 %27(prob = 0.97), ^while.body3, ^b4;
^while.body2:
    store i32* %j with i32 0;
    i32 %28 = load i32* %i;
    i64 %29 = sext i32 %28 to i64;
    f32* %30 = getelementptr &([1000 * f32]* %mean)[i64 0][i64 %29];
    store f32* %30 with f32 0;
    ubr ^while.header4;
^b3:
    store i32* %i with i32 0;
    ubr ^while.header5;
^while.body3:
    store i32* %j with i32 0;
    ubr ^while.header6;
^b4:
    call (i32) -> void @stoptime(i32 95);
    f32 %31 = load f32* %sum;
    call (f32) -> void @putfloat(f32 %31);
    ret i32 0;
^while.header4:
    i32 %32 = load i32* %j;
    i1 %33 = scmp lt i32 %32, i32 1000;
    i32 %34 = zext i1 %33 to i32;
    i1 %35 = scmp neq i32 %34, i32 0;
    cbr i1 %35(prob = 0.97), ^while.body4, ^b5;
^while.header5:
    i32 %36 = load i32* %i;
    i1 %37 = scmp lt i32 %36, i32 1000;
    i32 %38 = zext i1 %37 to i32;
    i1 %39 = scmp neq i32 %38, i32 0;
    cbr i1 %39(prob = 0.97), ^while.body5, ^b6;
^while.header6:
    i32 %40 = load i32* %j;
    i1 %41 = scmp lt i32 %40, i32 1000;
    i32 %42 = zext i1 %41 to i32;
    i1 %43 = scmp neq i32 %42, i32 0;
    cbr i1 %43(prob = 0.97), ^while.body6, ^b7;
^while.body4:
    i32 %44 = load i32* %i;
    i64 %45 = sext i32 %44 to i64;
    f32* %46 = getelementptr &([1000 * f32]* %mean)[i64 0][i64 %45];
    i32 %47 = load i32* %i;
    i64 %48 = sext i32 %47 to i64;
    f32* %49 = getelementptr &([1000 * f32]* %mean)[i64 0][i64 %48];
    f32 %50 = load f32* %49;
    i32 %51 = load i32* %i;
    i64 %52 = sext i32 %51 to i64;
    [1000 * f32]* %53 = getelementptr &([1000 * [1000 * f32]]* @a)[i64 0][i64 %52];
    i32 %54 = load i32* %j;
    i64 %55 = sext i32 %54 to i64;
    f32* %56 = getelementptr &([1000 * f32]* %53)[i64 0][i64 %55];
    f32 %57 = load f32* %56;
    f32 %58 = fadd f32 %50, f32 %57;
    store f32* %46 with f32 %58;
    i32 %59 = load i32* %j;
    i32 %60 = add i32 %59, i32 1;
    store i32* %j with i32 %60;
    ubr ^while.header4;
^b5:
    i32 %61 = load i32* %i;
    i64 %62 = sext i32 %61 to i64;
    f32* %63 = getelementptr &([1000 * f32]* %mean)[i64 0][i64 %62];
    i32 %64 = load i32* %i;
    i64 %65 = sext i32 %64 to i64;
    f32* %66 = getelementptr &([1000 * f32]* %mean)[i64 0][i64 %65];
    f32 %67 = load f32* %66;
    f32 %68 = fdiv f32 %67, f32 1000;
    store f32* %63 with f32 %68;
    i32 %69 = load i32* %i;
    i32 %70 = add i32 %69, i32 1;
    store i32* %i with i32 %70;
    ubr ^while.header2;
^while.body5:
    store i32* %j with i32 0;
    i32 %71 = load i32* %i;
    i64 %72 = sext i32 %71 to i64;
    f32* %73 = getelementptr &([1000 * f32]* %var)[i64 0][i64 %72];
    store f32* %73 with f32 0;
    ubr ^while.header7;
^while.body6:
    f32 %74 = load f32* %sum;
    i32 %75 = load i32* %i;
    i64 %76 = sext i32 %75 to i64;
    [1000 * f32]* %77 = getelementptr &([1000 * [1000 * f32]]* @a)[i64 0][i64 %76];
    i32 %78 = load i32* %j;
    i64 %79 = sext i32 %78 to i64;
    f32* %80 = getelementptr &([1000 * f32]* %77)[i64 0][i64 %79];
    f32 %81 = load f32* %80;
    f32 %82 = fadd f32 %74, f32 %81;
    store f32* %sum with f32 %82;
    i32 %83 = load i32* %j;
    i32 %84 = add i32 %83, i32 1;
    store i32* %j with i32 %84;
    ubr ^while.header6;
^b6:
    store i32* %i with i32 0;
    ubr ^while.header8;
^b7:
    i32 %85 = load i32* %i;
    i32 %86 = add i32 %85, i32 1;
    store i32* %i with i32 %86;
    ubr ^while.header3;
^while.header7:
    i32 %87 = load i32* %j;
    i1 %88 = scmp lt i32 %87, i32 1000;
    i32 %89 = zext i1 %88 to i32;
    i1 %90 = scmp neq i32 %89, i32 0;
    cbr i1 %90(prob = 0.97), ^while.body7, ^b8;
^while.header8:
    i32 %91 = load i32* %i;
    i1 %92 = scmp lt i32 %91, i32 1000;
    i32 %93 = zext i1 %92 to i32;
    i1 %94 = scmp neq i32 %93, i32 0;
    cbr i1 %94(prob = 0.97), ^while.body8, ^b9;
^while.body7:
    i32 %95 = load i32* %i;
    i64 %96 = sext i32 %95 to i64;
    f32* %97 = getelementptr &([1000 * f32]* %var)[i64 0][i64 %96];
    i32 %98 = load i32* %i;
    i64 %99 = sext i32 %98 to i64;
    f32* %100 = getelementptr &([1000 * f32]* %var)[i64 0][i64 %99];
    f32 %101 = load f32* %100;
    i32 %102 = load i32* %i;
    i64 %103 = sext i32 %102 to i64;
    [1000 * f32]* %104 = getelementptr &([1000 * [1000 * f32]]* @a)[i64 0][i64 %103];
    i32 %105 = load i32* %j;
    i64 %106 = sext i32 %105 to i64;
    f32* %107 = getelementptr &([1000 * f32]* %104)[i64 0][i64 %106];
    f32 %108 = load f32* %107;
    i32 %109 = load i32* %i;
    i64 %110 = sext i32 %109 to i64;
    f32* %111 = getelementptr &([1000 * f32]* %mean)[i64 0][i64 %110];
    f32 %112 = load f32* %111;
    f32 %113 = fsub f32 %108, f32 %112;
    i32 %114 = load i32* %i;
    i64 %115 = sext i32 %114 to i64;
    [1000 * f32]* %116 = getelementptr &([1000 * [1000 * f32]]* @a)[i64 0][i64 %115];
    i32 %117 = load i32* %j;
    i64 %118 = sext i32 %117 to i64;
    f32* %119 = getelementptr &([1000 * f32]* %116)[i64 0][i64 %118];
    f32 %120 = load f32* %119;
    i32 %121 = load i32* %i;
    i64 %122 = sext i32 %121 to i64;
    f32* %123 = getelementptr &([1000 * f32]* %mean)[i64 0][i64 %122];
    f32 %124 = load f32* %123;
    f32 %125 = fsub f32 %120, f32 %124;
    f32 %126 = fmul f32 %113, f32 %125;
    f32 %127 = fadd f32 %101, f32 %126;
    store f32* %97 with f32 %127;
    i32 %128 = load i32* %j;
    i32 %129 = add i32 %128, i32 1;
    store i32* %j with i32 %129;
    ubr ^while.header7;
^b8:
    i32 %130 = load i32* %i;
    i64 %131 = sext i32 %130 to i64;
    f32* %132 = getelementptr &([1000 * f32]* %var)[i64 0][i64 %131];
    i32 %133 = load i32* %i;
    i64 %134 = sext i32 %133 to i64;
    f32* %135 = getelementptr &([1000 * f32]* %var)[i64 0][i64 %134];
    f32 %136 = load f32* %135;
    f32 %137 = fdiv f32 %136, f32 1000;
    store f32* %132 with f32 %137;
    i32 %138 = load i32* %i;
    i64 %139 = sext i32 %138 to i64;
    f32* %140 = getelementptr &([1000 * f32]* %var)[i64 0][i64 %139];
    i32 %141 = load i32* %i;
    i64 %142 = sext i32 %141 to i64;
    f32* %143 = getelementptr &([1000 * f32]* %var)[i64 0][i64 %142];
    f32 %144 = load f32* %143;
    f32 %145 = fadd f32 %144, f32 0.01;
    f32 %146 = call (f32) -> f32 @sqrt(f32 %145);
    store f32* %140 with f32 %146;
    i32 %147 = load i32* %i;
    i32 %148 = add i32 %147, i32 1;
    store i32* %i with i32 %148;
    ubr ^while.header5;
^while.body8:
    store i32* %j with i32 0;
    ubr ^while.header9;
^b9:
    i32 %149 = load i32* %k;
    i32 %150 = add i32 %149, i32 1;
    store i32* %k with i32 %150;
    ubr ^while.header1;
^while.header9:
    i32 %151 = load i32* %j;
    i1 %152 = scmp lt i32 %151, i32 1000;
    i32 %153 = zext i1 %152 to i32;
    i1 %154 = scmp neq i32 %153, i32 0;
    cbr i1 %154(prob = 0.97), ^while.body9, ^b10;
^while.body9:
    i32 %155 = load i32* %i;
    i64 %156 = sext i32 %155 to i64;
    [1000 * f32]* %157 = getelementptr &([1000 * [1000 * f32]]* @a)[i64 0][i64 %156];
    i32 %158 = load i32* %j;
    i64 %159 = sext i32 %158 to i64;
    f32* %160 = getelementptr &([1000 * f32]* %157)[i64 0][i64 %159];
    i32 %161 = load i32* %i;
    i64 %162 = sext i32 %161 to i64;
    [1000 * f32]* %163 = getelementptr &([1000 * [1000 * f32]]* @a)[i64 0][i64 %162];
    i32 %164 = load i32* %j;
    i64 %165 = sext i32 %164 to i64;
    f32* %166 = getelementptr &([1000 * f32]* %163)[i64 0][i64 %165];
    f32 %167 = load f32* %166;
    i32 %168 = load i32* %i;
    i64 %169 = sext i32 %168 to i64;
    f32* %170 = getelementptr &([1000 * f32]* %mean)[i64 0][i64 %169];
    f32 %171 = load f32* %170;
    f32 %172 = fsub f32 %167, f32 %171;
    i32 %173 = load i32* %i;
    i64 %174 = sext i32 %173 to i64;
    f32* %175 = getelementptr &([1000 * f32]* %var)[i64 0][i64 %174];
    f32 %176 = load f32* %175;
    f32 %177 = fdiv f32 %172, f32 %176;
    store f32* %160 with f32 %177;
    f32 %178 = load f32* %sum;
    i32 %179 = load i32* %i;
    i64 %180 = sext i32 %179 to i64;
    [1000 * f32]* %181 = getelementptr &([1000 * [1000 * f32]]* @a)[i64 0][i64 %180];
    i32 %182 = load i32* %j;
    i64 %183 = sext i32 %182 to i64;
    f32* %184 = getelementptr &([1000 * f32]* %181)[i64 0][i64 %183];
    f32 %185 = load f32* %184;
    f32 %186 = fadd f32 %178, f32 %185;
    store f32* %sum with f32 %186;
    i32 %187 = load i32* %j;
    i32 %188 = add i32 %187, i32 1;
    store i32* %j with i32 %188;
    ubr ^while.header9;
^b10:
    i32 %189 = load i32* %i;
    i32 %190 = add i32 %189, i32 1;
    store i32* %i with i32 %190;
    ubr ^while.header8;
}
