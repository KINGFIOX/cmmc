internal func @getint() -> i32 { NoMemoryRead NoMemoryWrite };
internal func @getch() -> i32 { NoMemoryRead NoMemoryWrite };
internal func @getarray() -> i32 { NoMemoryRead };
internal func @getfloat() -> f32 { NoMemoryRead NoMemoryWrite };
internal func @getfarray() -> i32 { NoMemoryRead };
internal func @putint() -> void { NoMemoryRead NoMemoryWrite };
internal func @putch() -> void { NoMemoryRead NoMemoryWrite };
internal func @putarray() -> void { NoMemoryWrite };
internal func @putfloat() -> void { NoMemoryRead NoMemoryWrite };
internal func @putfarray() -> void { NoMemoryWrite };
internal func @starttime() -> void { NoMemoryRead NoMemoryWrite };
internal func @stoptime() -> void { NoMemoryRead NoMemoryWrite };
internal i32* @COUNT = 100000;
internal func @loop(f32* %x, f32* %y, i32 %length) -> f32 {
^entry:
    f32* %accumula = alloc f32;
    i32* %i = alloc i32;
    i32* %length1 = alloc i32;
    f32** %y1 = alloc f32*;
    f32** %x1 = alloc f32*;
    store f32** %x1 with f32* %x;
    store f32** %y1 with f32* %y;
    store i32* %length1 with i32 %length;
    store i32* %i with i32 0;
    store f32* %accumula with f32 0;
    ubr ^while.header;
^while.header:
    i32 %0 = load i32* %i;
    i32 %1 = load i32* %length1;
    i1 %2 = scmp lt i32 %0, i32 %1;
    i32 %3 = zext i1 %2 to i32;
    i1 %4 = scmp neq i32 %3, i32 0;
    cbr i1 %4(prob = 0.97), ^while.body, ^b;
^while.body:
    f32 %5 = load f32* %accumula;
    i32 %6 = load i32* %i;
    i64 %7 = sext i32 %6 to i64;
    f32* %8 = load f32** %x1;
    f32* %9 = getelementptr &(f32* %8)[i64 %7];
    f32 %10 = load f32* %9;
    i32 %11 = load i32* %i;
    i64 %12 = sext i32 %11 to i64;
    f32* %13 = load f32** %y1;
    f32* %14 = getelementptr &(f32* %13)[i64 %12];
    f32 %15 = load f32* %14;
    f32 %16 = fmul f32 %10, f32 %15;
    f32 %17 = fadd f32 %5, f32 %16;
    store f32* %accumula with f32 %17;
    i32 %18 = load i32* %i;
    i32 %19 = add i32 %18, i32 1;
    store i32* %i with i32 %19;
    ubr ^while.header;
^b:
    f32 %20 = load f32* %accumula;
    ret f32 %20;
}
func @main() -> i32 { Entry } {
^entry:
    f32* %b = alloc f32;
    f32* %a = alloc f32;
    f32* %total = alloc f32;
    [8192 * f32]* %y = alloc [8192 * f32];
    [8192 * f32]* %x = alloc [8192 * f32];
    i32* %len = alloc i32;
    i32* %j = alloc i32;
    i32* %i = alloc i32;
    store i32* %i with i32 0;
    store i32* %j with i32 0;
    i32 %0 = call () -> i32 @getint();
    store i32* %len with i32 %0;
    store f32* %total with f32 0;
    store f32* %a with f32 0;
    store f32* %b with f32 1;
    call (i32) -> void @starttime(i32 22);
    ubr ^while.header;
^while.header:
    i32 %1 = load i32* %i;
    i32 %2 = load i32* @COUNT;
    i1 %3 = scmp lt i32 %1, i32 %2;
    i32 %4 = zext i1 %3 to i32;
    i1 %5 = scmp neq i32 %4, i32 0;
    cbr i1 %5(prob = 0.97), ^while.body, ^b1;
^while.body:
    i32 %6 = load i32* %i;
    i32 %7 = srem i32 %6, i32 10;
    i1 %8 = scmp neq i32 %7, i32 0;
    cbr i1 %8(prob = 0.5), ^if.then, ^if.else;
^b1:
    call (i32) -> void @stoptime(i32 39);
    f32 %9 = load f32* %total;
    f32 %10 = fsub f32 %9, f32 1.8338e+16;
    i1 %11 = fcmp le f32 %10, f32 1e-06;
    i32 %12 = zext i1 %11 to i32;
    i1 %13 = scmp neq i32 %12, i32 0;
    cbr i1 %13(prob = 0.5), ^b3, ^b2;
^if.then:
    store f32* %a with f32 0;
    store f32* %b with f32 1;
    ubr ^b4;
^if.else:
    f32 %14 = load f32* %a;
    f32 %15 = fadd f32 %14, f32 0.1;
    store f32* %a with f32 %15;
    f32 %16 = load f32* %b;
    f32 %17 = fadd f32 %16, f32 0.2;
    store f32* %b with f32 %17;
    ubr ^b4;
^b2:
    f32 %18 = load f32* %total;
    f32 %19 = fsub f32 %18, f32 1.8338e+16;
    i1 %20 = fcmp ge f32 %19, f32 -1e-06;
    i32 %21 = zext i1 %20 to i32;
    i1 %22 = scmp neq i32 %21, i32 0;
    ubr ^b3;
^b3:
    i1 %23 = phi [^b2, i1 %22] [^b1, i1 true];
    i32 %24 = zext i1 %23 to i32;
    i1 %25 = scmp neq i32 %24, i32 0;
    cbr i1 %25(prob = 0.5), ^if.then1, ^if.else1;
^b4:
    ubr ^while.header1;
^if.then1:
    call (i32) -> void @putint(i32 0);
    ret i32 0;
^if.else1:
    call (i32) -> void @putint(i32 1);
    ret i32 1;
^while.header1:
    i32 %26 = load i32* %j;
    i32 %27 = load i32* %len;
    i1 %28 = scmp lt i32 %26, i32 %27;
    i32 %29 = zext i1 %28 to i32;
    i1 %30 = scmp neq i32 %29, i32 0;
    cbr i1 %30(prob = 0.97), ^while.body1, ^b5;
^while.body1:
    i32 %31 = load i32* %j;
    i64 %32 = sext i32 %31 to i64;
    f32* %33 = getelementptr &([8192 * f32]* %x)[i64 0][i64 %32];
    f32 %34 = load f32* %a;
    i32 %35 = load i32* %j;
    f32 %36 = s2f i32 %35 to f32;
    f32 %37 = fadd f32 %34, f32 %36;
    store f32* %33 with f32 %37;
    i32 %38 = load i32* %j;
    i64 %39 = sext i32 %38 to i64;
    f32* %40 = getelementptr &([8192 * f32]* %y)[i64 0][i64 %39];
    f32 %41 = load f32* %b;
    i32 %42 = load i32* %j;
    f32 %43 = s2f i32 %42 to f32;
    f32 %44 = fadd f32 %41, f32 %43;
    store f32* %40 with f32 %44;
    i32 %45 = load i32* %j;
    i32 %46 = add i32 %45, i32 1;
    store i32* %j with i32 %46;
    ubr ^while.header1;
^b5:
    f32 %47 = load f32* %total;
    f32* %48 = getelementptr &([8192 * f32]* %x)[i64 0][i64 0];
    f32* %49 = getelementptr &([8192 * f32]* %y)[i64 0][i64 0];
    i32 %50 = load i32* %len;
    f32 %51 = call (f32*, f32*, i32) -> f32 @loop(f32* %48, f32* %49, i32 %50);
    f32 %52 = fadd f32 %47, f32 %51;
    store f32* %total with f32 %52;
    i32 %53 = load i32* %i;
    i32 %54 = add i32 %53, i32 1;
    store i32* %i with i32 %54;
    ubr ^while.header;
^b6:
    unreachable;
}
