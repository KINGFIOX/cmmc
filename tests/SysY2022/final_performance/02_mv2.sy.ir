internal func @getint() -> i32 { NoMemoryRead NoMemoryWrite };
internal func @getch() -> i32 { NoMemoryRead NoMemoryWrite };
internal func @getarray() -> i32 { NoMemoryRead };
internal func @getfloat() -> f32 { NoMemoryRead NoMemoryWrite };
internal func @getfarray() -> i32 { NoMemoryRead };
internal func @putint() -> void { NoMemoryRead NoMemoryWrite };
internal func @putch() -> void { NoMemoryRead NoMemoryWrite };
internal func @putarray() -> void { NoMemoryWrite };
internal func @putfloat() -> void { NoMemoryRead NoMemoryWrite };
internal func @putfarray() -> void { NoMemoryWrite };
internal func @starttime() -> void { NoMemoryRead NoMemoryWrite };
internal func @stoptime() -> void { NoMemoryRead NoMemoryWrite };
internal i32* @x;
internal i32* @N { ReadOnly } = 2010;
internal func @mv(i32 %n, [2010 * i32]* %A, i32* %b, i32* %res) -> void {
^entry:
    i32* %j = alloc i32;
    i32* %i = alloc i32;
    i32* %y = alloc i32;
    i32* %x = alloc i32;
    i32** %res1 = alloc i32*;
    i32** %b1 = alloc i32*;
    [2010 * i32]** %A1 = alloc [2010 * i32]*;
    i32* %n1 = alloc i32;
    store i32* %n1 with i32 %n;
    store [2010 * i32]** %A1 with [2010 * i32]* %A;
    store i32** %b1 with i32* %b;
    store i32** %res1 with i32* %res;
    store i32* %x with i32 0;
    store i32* %y with i32 0;
    store i32* %y with i32 0;
    store i32* %x with i32 11;
    store i32* %i with i32 0;
    store i32* %j with i32 0;
    store i32* %i with i32 0;
    ubr ^while.header;
^while.header:
    i32 %0 = load i32* %i;
    i32 %1 = load i32* %n1;
    i1 %2 = scmp lt i32 %0, i32 %1;
    i32 %3 = zext i1 %2 to i32;
    i1 %4 = scmp neq i32 %3, i32 0;
    cbr i1 %4(prob = 0.97), ^while.body, ^b2;
^while.body:
    i32 %5 = load i32* %i;
    i64 %6 = sext i32 %5 to i64;
    i32* %7 = load i32** %res1;
    i32* %8 = getelementptr &(i32* %7)[i64 %6];
    store i32* %8 with i32 0;
    i32 %9 = load i32* %i;
    i32 %10 = add i32 %9, i32 1;
    store i32* %i with i32 %10;
    ubr ^while.header;
^b2:
    store i32* %i with i32 0;
    store i32* %j with i32 0;
    ubr ^while.header1;
^while.header1:
    i32 %11 = load i32* %i;
    i32 %12 = load i32* %n1;
    i1 %13 = scmp lt i32 %11, i32 %12;
    i32 %14 = zext i1 %13 to i32;
    i1 %15 = scmp neq i32 %14, i32 0;
    cbr i1 %15(prob = 0.97), ^while.body1, ^b3;
^while.body1:
    store i32* %j with i32 0;
    ubr ^while.header2;
^b3:
    ret;
^while.header2:
    i32 %16 = load i32* %j;
    i32 %17 = load i32* %n1;
    i1 %18 = scmp lt i32 %16, i32 %17;
    i32 %19 = zext i1 %18 to i32;
    i1 %20 = scmp neq i32 %19, i32 0;
    cbr i1 %20(prob = 0.97), ^while.body2, ^b4;
^b4:
    i32 %21 = load i32* %i;
    i32 %22 = add i32 %21, i32 1;
    store i32* %i with i32 %22;
    ubr ^while.header1;
^while.body2:
    i32 %23 = load i32* %i;
    i64 %24 = sext i32 %23 to i64;
    [2010 * i32]* %25 = load [2010 * i32]** %A1;
    [2010 * i32]* %26 = getelementptr &([2010 * i32]* %25)[i64 %24];
    i32 %27 = load i32* %j;
    i64 %28 = sext i32 %27 to i64;
    i32* %29 = getelementptr &([2010 * i32]* %26)[i64 0][i64 %28];
    i32 %30 = load i32* %29;
    i1 %31 = scmp eq i32 %30, i32 0;
    i32 %32 = zext i1 %31 to i32;
    i1 %33 = scmp neq i32 %32, i32 0;
    cbr i1 %33(prob = 0.5), ^if.then, ^if.else;
^if.then:
    i32 %34 = load i32* %x;
    i32 %35 = load i32* %i;
    i64 %36 = sext i32 %35 to i64;
    i32* %37 = load i32** %b1;
    i32* %38 = getelementptr &(i32* %37)[i64 %36];
    i32 %39 = load i32* %38;
    i32 %40 = mul i32 %34, i32 %39;
    i32 %41 = load i32* %j;
    i64 %42 = sext i32 %41 to i64;
    i32* %43 = load i32** %b1;
    i32* %44 = getelementptr &(i32* %43)[i64 %42];
    i32 %45 = load i32* %44;
    i32 %46 = add i32 %40, i32 %45;
    store i32* %x with i32 %46;
    i32 %47 = load i32* %y;
    i32 %48 = load i32* %x;
    i32 %49 = sub i32 %47, i32 %48;
    store i32* %y with i32 %49;
    ubr ^b5;
^if.else:
    i32 %50 = load i32* %i;
    i64 %51 = sext i32 %50 to i64;
    i32* %52 = load i32** %res1;
    i32* %53 = getelementptr &(i32* %52)[i64 %51];
    i32 %54 = load i32* %i;
    i64 %55 = sext i32 %54 to i64;
    i32* %56 = load i32** %res1;
    i32* %57 = getelementptr &(i32* %56)[i64 %55];
    i32 %58 = load i32* %57;
    i32 %59 = load i32* %i;
    i64 %60 = sext i32 %59 to i64;
    [2010 * i32]* %61 = load [2010 * i32]** %A1;
    [2010 * i32]* %62 = getelementptr &([2010 * i32]* %61)[i64 %60];
    i32 %63 = load i32* %j;
    i64 %64 = sext i32 %63 to i64;
    i32* %65 = getelementptr &([2010 * i32]* %62)[i64 0][i64 %64];
    i32 %66 = load i32* %65;
    i32 %67 = load i32* %j;
    i64 %68 = sext i32 %67 to i64;
    i32* %69 = load i32** %b1;
    i32* %70 = getelementptr &(i32* %69)[i64 %68];
    i32 %71 = load i32* %70;
    i32 %72 = mul i32 %66, i32 %71;
    i32 %73 = add i32 %58, i32 %72;
    store i32* %53 with i32 %73;
    ubr ^b5;
^b5:
    i32 %74 = load i32* %j;
    i32 %75 = add i32 %74, i32 1;
    store i32* %j with i32 %75;
    ubr ^while.header2;
}
internal [2010 * [2010 * i32]]* @A;
internal [2010 * i32]* @B;
internal [2010 * i32]* @C;
func @main() -> i32 { Entry } {
^entry:
    i32* %j = alloc i32;
    i32* %i = alloc i32;
    i32* %n = alloc i32;
    i32 %0 = call () -> i32 @getint();
    store i32* %n with i32 %0;
    store i32* %i with i32 0;
    store i32* %j with i32 0;
    store i32* %i with i32 0;
    ubr ^while.header;
^while.header:
    i32 %1 = load i32* %i;
    i32 %2 = load i32* %n;
    i1 %3 = scmp lt i32 %1, i32 %2;
    i32 %4 = zext i1 %3 to i32;
    i1 %5 = scmp neq i32 %4, i32 0;
    cbr i1 %5(prob = 0.97), ^while.body, ^b;
^while.body:
    store i32* %j with i32 0;
    ubr ^while.header1;
^b:
    store i32* %i with i32 0;
    ubr ^while.header2;
^while.header1:
    i32 %6 = load i32* %j;
    i32 %7 = load i32* %n;
    i1 %8 = scmp lt i32 %6, i32 %7;
    i32 %9 = zext i1 %8 to i32;
    i1 %10 = scmp neq i32 %9, i32 0;
    cbr i1 %10(prob = 0.97), ^while.body1, ^b1;
^while.header2:
    i32 %11 = load i32* %i;
    i32 %12 = load i32* %n;
    i1 %13 = scmp lt i32 %11, i32 %12;
    i32 %14 = zext i1 %13 to i32;
    i1 %15 = scmp neq i32 %14, i32 0;
    cbr i1 %15(prob = 0.97), ^while.body2, ^b2;
^while.body1:
    i32 %16 = load i32* %i;
    i64 %17 = sext i32 %16 to i64;
    [2010 * i32]* %18 = getelementptr &([2010 * [2010 * i32]]* @A)[i64 0][i64 %17];
    i32 %19 = load i32* %j;
    i64 %20 = sext i32 %19 to i64;
    i32* %21 = getelementptr &([2010 * i32]* %18)[i64 0][i64 %20];
    i32 %22 = call () -> i32 @getint();
    store i32* %21 with i32 %22;
    i32 %23 = load i32* %j;
    i32 %24 = add i32 %23, i32 1;
    store i32* %j with i32 %24;
    ubr ^while.header1;
^b1:
    i32 %25 = load i32* %i;
    i32 %26 = add i32 %25, i32 1;
    store i32* %i with i32 %26;
    ubr ^while.header;
^while.body2:
    i32 %27 = load i32* %i;
    i64 %28 = sext i32 %27 to i64;
    i32* %29 = getelementptr &([2010 * i32]* @B)[i64 0][i64 %28];
    i32 %30 = call () -> i32 @getint();
    store i32* %29 with i32 %30;
    i32 %31 = load i32* %i;
    i32 %32 = add i32 %31, i32 1;
    store i32* %i with i32 %32;
    ubr ^while.header2;
^b2:
    call (i32) -> void @starttime(i32 59);
    store i32* %i with i32 0;
    ubr ^while.header3;
^while.header3:
    i32 %33 = load i32* %i;
    i1 %34 = scmp lt i32 %33, i32 50;
    i32 %35 = zext i1 %34 to i32;
    i1 %36 = scmp neq i32 %35, i32 0;
    cbr i1 %36(prob = 0.97), ^while.body3, ^b3;
^while.body3:
    i32 %37 = load i32* %n;
    [2010 * i32]* %38 = getelementptr &([2010 * [2010 * i32]]* @A)[i64 0][i64 0];
    i32* %39 = getelementptr &([2010 * i32]* @B)[i64 0][i64 0];
    i32* %40 = getelementptr &([2010 * i32]* @C)[i64 0][i64 0];
    call (i32, [2010 * i32]*, i32*, i32*) -> void @mv(i32 %37, [2010 * i32]* %38, i32* %39, i32* %40);
    i32 %41 = load i32* %n;
    [2010 * i32]* %42 = getelementptr &([2010 * [2010 * i32]]* @A)[i64 0][i64 0];
    i32* %43 = getelementptr &([2010 * i32]* @C)[i64 0][i64 0];
    i32* %44 = getelementptr &([2010 * i32]* @B)[i64 0][i64 0];
    call (i32, [2010 * i32]*, i32*, i32*) -> void @mv(i32 %41, [2010 * i32]* %42, i32* %43, i32* %44);
    i32 %45 = load i32* %i;
    i32 %46 = add i32 %45, i32 1;
    store i32* %i with i32 %46;
    ubr ^while.header3;
^b3:
    call (i32) -> void @stoptime(i32 67);
    i32 %47 = load i32* %n;
    i32* %48 = getelementptr &([2010 * i32]* @C)[i64 0][i64 0];
    call (i32, i32*) -> void @putarray(i32 %47, i32* %48);
    ret i32 0;
}
