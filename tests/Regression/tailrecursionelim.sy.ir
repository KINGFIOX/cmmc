internal func @getint() -> i32 { NoMemoryRead NoMemoryWrite };
internal func @getfloat() -> f32 { NoMemoryRead NoMemoryWrite };
internal func @putint() -> void { NoMemoryRead NoMemoryWrite };
internal func @putfloat() -> void { NoMemoryRead NoMemoryWrite };
func @fac(i32 %a) -> i32 { NoMemoryRead NoMemoryWrite NoSideEffect Stateless NoRecurse } {
^0:
    ubr ^entry;
^entry:
    i32 %1 = phi [^0, i32 1] [^if.else, i32 %5];
    i32 %2 = phi [^0, i32 %a] [^if.else, i32 %4];
    i1 %3 = scmp eq i32 %2, i32 1;
    cbr i1 %3(prob = 0.5), ^b, ^if.else;
^if.else:
    i32 %4 = add i32 %2, i32 -1;
    i32 %5 = mul i32 %2, i32 %1;
    ubr ^entry;
^b:
    ret i32 %1;
}
func @fib(i32 %a) -> i32 { NoMemoryRead NoMemoryWrite NoSideEffect Stateless } {
^0:
    ubr ^entry;
^entry:
    i32 %1 = phi [^0, i32 0] [^b, i32 %7];
    i32 %2 = phi [^0, i32 %a] [^b, i32 %6];
    i1 %3 = scmp lt i32 %2, i32 3;
    cbr i1 %3(prob = 0.5), ^b1, ^b;
^b:
    i32 %4 = add i32 %2, i32 -1;
    i32 %5 = call (i32) -> i32 @fib(i32 %4);
    i32 %6 = add i32 %2, i32 -2;
    i32 %7 = add i32 %1, i32 %5;
    ubr ^entry;
^b1:
    i32 %8 = add i32 %1, i32 1;
    ret i32 %8;
}
func @gcd(i32 %a, i32 %b) -> i32 { NoMemoryRead NoMemoryWrite NoSideEffect Stateless NoRecurse } {
^0:
    ubr ^entry;
^entry:
    i32 %1 = phi [^0, i32 %b] [^lhsBlock, i32 %4];
    i32 %2 = phi [^0, i32 %a] [^lhsBlock, i32 %1];
    i1 %3 = scmp neq i32 %1, i32 0;
    cbr i1 %3(prob = 0.5), ^lhsBlock, ^b1;
^lhsBlock:
    i32 %4 = srem i32 %2, i32 %1;
    ubr ^entry;
^b1:
    ret i32 %2;
}
i32* @g = 0;
func @test(i32 %n) -> void { NoRecurse } {
^0:
    ubr ^entry;
^entry:
    i32 %1 = phi [^0, i32 %n] [^b, i32 %5];
    i1 %2 = scmp eq i32 %1, i32 0;
    cbr i1 %2(prob = 0.5), ^b1, ^b;
^b:
    i32 %3 = load i32* @g;
    i32 %4 = add i32 %3, i32 1;
    store i32* @g with i32 %4;
    i32 %5 = add i32 %1, i32 -1;
    ubr ^entry;
^b1:
    ret;
}
f32* @eps { ReadOnly } = 1e-08;
func @f(f32 %x) -> f32 { NoMemoryRead NoMemoryWrite NoSideEffect Stateless NoRecurse } {
^entry:
    f32 %0 = fmul f32 %x, f32 %x;
    ret f32 %0;
}
func @my_fabs(f32 %x) -> f32 { NoMemoryRead NoMemoryWrite NoSideEffect Stateless NoRecurse } {
^entry:
    i1 %0 = fcmp ge f32 %x, f32 0;
    cbr i1 %0(prob = 0.5), ^b, ^rhsBlock;
^rhsBlock:
    f32 %1 = fneg f32 %x;
    ubr ^b;
^b:
    f32 %2 = phi [^entry, f32 %x] [^rhsBlock, f32 %1];
    ret f32 %2;
}
func @simpson(f32 %l, f32 %r, f32 %fl, f32 %fm, f32 %fr) -> f32 { NoMemoryRead NoMemoryWrite NoSideEffect Stateless NoRecurse } {
^entry:
    f32 %0 = fsub f32 %r, f32 %l;
    f32 %1 = fmul f32 4, f32 %fm;
    f32 %2 = fadd f32 %fl, f32 %1;
    f32 %3 = fadd f32 %2, f32 %fr;
    f32 %4 = fmul f32 %0, f32 %3;
    f32 %5 = fdiv f32 %4, f32 6;
    ret f32 %5;
}
func @SAAImpl(f32 %l, f32 %m, f32 %r, f32 %fl, f32 %fm, f32 %fr, f32 %sm) -> f32 { NoMemoryRead NoMemoryWrite NoSideEffect Stateless } {
^0:
    ubr ^entry;
^entry:
    f32 %1 = phi [^0, f32 -0] [^b1, f32 %32];
    f32 %2 = phi [^0, f32 %sm] [^b1, f32 %24];
    f32 %3 = phi [^0, f32 %fm] [^b1, f32 %18];
    f32 %4 = phi [^0, f32 %fl] [^b1, f32 %3];
    f32 %5 = phi [^0, f32 %m] [^b1, f32 %17];
    f32 %6 = phi [^0, f32 %l] [^b1, f32 %5];
    f32 %7 = fadd f32 %6, f32 %5;
    f32 %8 = fmul f32 %7, f32 0.5;
    f32 %9 = fmul f32 %8, f32 %8;
    f32 %10 = fsub f32 %5, f32 %6;
    f32 %11 = fmul f32 4, f32 %9;
    f32 %12 = fadd f32 %4, f32 %11;
    f32 %13 = fadd f32 %12, f32 %3;
    f32 %14 = fmul f32 %10, f32 %13;
    f32 %15 = fdiv f32 %14, f32 6;
    f32 %16 = fadd f32 %5, f32 %r;
    f32 %17 = fmul f32 %16, f32 0.5;
    f32 %18 = fmul f32 %17, f32 %17;
    f32 %19 = fsub f32 %r, f32 %5;
    f32 %20 = fmul f32 4, f32 %18;
    f32 %21 = fadd f32 %3, f32 %20;
    f32 %22 = fadd f32 %21, f32 %fr;
    f32 %23 = fmul f32 %19, f32 %22;
    f32 %24 = fdiv f32 %23, f32 6;
    f32 %25 = fadd f32 %15, f32 %24;
    f32 %26 = fsub f32 %2, f32 %25;
    i1 %27 = fcmp ge f32 %26, f32 -0;
    cbr i1 %27(prob = 0.5), ^b, ^rhsBlock;
^rhsBlock:
    f32 %28 = fneg f32 %26;
    ubr ^b;
^b:
    f32 %29 = phi [^entry, f32 %26] [^rhsBlock, f32 %28];
    i1 %30 = fcmp lt f32 %29, f32 1e-08;
    cbr i1 %30(prob = 0.5), ^b2, ^b1;
^b1:
    f32 %31 = call (f32, f32, f32, f32, f32, f32, f32) -> f32 @SAAImpl(f32 %6, f32 %8, f32 %5, f32 %4, f32 %9, f32 %3, f32 %15);
    f32 %32 = fadd f32 %31, f32 %1;
    ubr ^entry;
^b2:
    f32 %33 = fadd f32 %25, f32 %1;
    ret f32 %33;
}
func @SAA(f32 %l, f32 %r) -> f32 { NoMemoryRead NoMemoryWrite NoSideEffect Stateless NoRecurse } {
^entry:
    f32 %0 = fadd f32 %l, f32 %r;
    f32 %1 = fmul f32 %0, f32 0.5;
    f32 %2 = fmul f32 %l, f32 %l;
    f32 %3 = fmul f32 %1, f32 %1;
    f32 %4 = fmul f32 %r, f32 %r;
    f32 %5 = fsub f32 %r, f32 %l;
    f32 %6 = fmul f32 4, f32 %3;
    f32 %7 = fadd f32 %2, f32 %6;
    f32 %8 = fadd f32 %7, f32 %4;
    f32 %9 = fmul f32 %5, f32 %8;
    f32 %10 = fdiv f32 %9, f32 6;
    f32 %11 = call (f32, f32, f32, f32, f32, f32, f32) -> f32 @SAAImpl(f32 %l, f32 %1, f32 %r, f32 %2, f32 %3, f32 %4, f32 %10);
    ret f32 %11;
}
func @main() -> i32 { NoRecurse } {
^entry:
    i32 %0 = call () -> i32 @getint();
    f32 %1 = call () -> f32 @getfloat();
    f32 %2 = call () -> f32 @getfloat();
    store i32* @g with i32 %0;
    ubr ^entry1;
^entry1:
    i32 %3 = phi [^entry, i32 %0] [^b, i32 %7];
    i1 %4 = scmp eq i32 %3, i32 0;
    cbr i1 %4(prob = 0.5), ^entry2, ^b;
^b:
    i32 %5 = load i32* @g;
    i32 %6 = add i32 %5, i32 1;
    store i32* @g with i32 %6;
    i32 %7 = add i32 %3, i32 -1;
    ubr ^entry1;
^entry2:
    i32 %8 = phi [^entry1, i32 1] [^if.else, i32 %13];
    i32 %9 = phi [^entry1, i32 %0] [^if.else, i32 %12];
    i1 %10 = scmp eq i32 %9, i32 1;
    cbr i1 %10(prob = 0.5), ^entry3, ^if.else;
^entry3:
    call (i32) -> void @putint(i32 %8);
    i32 %11 = call (i32) -> i32 @fib(i32 %0);
    call (i32) -> void @putint(i32 %11);
    ubr ^entry4;
^if.else:
    i32 %12 = add i32 %9, i32 -1;
    i32 %13 = mul i32 %8, i32 %9;
    ubr ^entry2;
^entry4:
    i32 %14 = phi [^entry3, i32 %0] [^lhsBlock, i32 %17];
    i32 %15 = phi [^entry3, i32 %0] [^lhsBlock, i32 %14];
    i1 %16 = scmp neq i32 %14, i32 0;
    cbr i1 %16(prob = 0.5), ^lhsBlock, ^entry5;
^lhsBlock:
    i32 %17 = srem i32 %15, i32 %14;
    ubr ^entry4;
^entry5:
    call (i32) -> void @putint(i32 %15);
    i32 %18 = load i32* @g;
    call (i32) -> void @putint(i32 %18);
    f32 %19 = fadd f32 %1, f32 %2;
    f32 %20 = fmul f32 %19, f32 0.5;
    f32 %21 = fmul f32 %1, f32 %1;
    f32 %22 = fmul f32 %20, f32 %20;
    f32 %23 = fmul f32 %2, f32 %2;
    f32 %24 = fsub f32 %2, f32 %1;
    f32 %25 = fmul f32 4, f32 %22;
    f32 %26 = fadd f32 %21, f32 %25;
    f32 %27 = fadd f32 %26, f32 %23;
    f32 %28 = fmul f32 %24, f32 %27;
    f32 %29 = fdiv f32 %28, f32 6;
    f32 %30 = call (f32, f32, f32, f32, f32, f32, f32) -> f32 @SAAImpl(f32 %1, f32 %20, f32 %2, f32 %21, f32 %22, f32 %23, f32 %29);
    call (f32) -> void @putfloat(f32 %30);
    ret i32 0;
}
