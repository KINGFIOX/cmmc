// This file is automatically generated by llvm2c from llvm/test/Transforms/SCCP/ashr

// function declarations
uint8_t ashr_and(uint8_t var0);
uint8_t ashr_const(uint8_t var0);
uint8_t ashr_not_nonneg(uint8_t var0, uint8_t var1);
uint8_t ashr_zext(uint8_t var0, uint8_t var1);
uint32_t dominating_condition(uint32_t var0);
uint32_t dominating_condition_alt(uint32_t var0, uint32_t var1);

uint8_t ashr_and(uint8_t var0){
    block0:
    return (var0 & 127) >> ((uint8_t)1);
}

uint8_t ashr_const(uint8_t var0){
    block0:
    return 42 >> ((uint8_t)var0);
}

uint8_t ashr_not_nonneg(uint8_t var0, uint8_t var1){
    block0:
    return ((char)((char)var0)) >> ((uint8_t)var1);
}

uint8_t ashr_zext(uint8_t var0, uint8_t var1){
    block0:
    return ((uint8_t)var0) >> ((uint8_t)var1);
}

uint32_t dominating_condition(uint32_t var0){
    uint32_t var2_phi;
    uint32_t var1;
    block0:
    if (((int)var0) >= ((int)0)) {
        var1 = (var0 >> ((uint32_t)16));
        var2_phi = var1;
        return var2_phi;
    } else {
        var2_phi = 42;
        return var2_phi;
    }
}

uint32_t dominating_condition_alt(uint32_t var0, uint32_t var1){
    uint32_t var3_phi;
    uint32_t var2;
    block0:
    if (var0 > 2000000000) {
        var3_phi = -42;
        return var3_phi;
    } else {
        var2 = (var0 >> ((uint32_t)var1));
        var3_phi = var2;
        return var3_phi;
    }
}

