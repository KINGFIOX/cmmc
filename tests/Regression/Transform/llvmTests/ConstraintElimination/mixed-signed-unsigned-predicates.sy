// This file is automatically generated by llvm2c from llvm/test/Transforms/ConstraintElimination/mixed-signed-unsigned-predicates

// function declarations
uint32_t test_add_nsw(uint8_t var0, uint8_t var1, uint8_t var2);
uint32_t test_add_nuw(uint8_t var0, uint8_t var1, uint8_t var2);
uint32_t test_and_ule_sge(uint32_t var0, uint32_t var1, uint32_t var2, uint32_t var3);
uint32_t test_sub_nuw(uint8_t var0, uint8_t var1, uint8_t var2);

uint32_t test_add_nsw(uint8_t var0, uint8_t var1, uint8_t var2){
    uint8_t var3;
    uint8_t var4;
    uint8_t var5;
    uint8_t var6;
    uint8_t var7;
    uint8_t var8;
    block0:
    if ((((char)var0) + ((char)3)) >= ((char)var2)) {
        var3 = (var0 + 1);
        var4 = (var0 + 3);
        return (((((var0 > var2) ^ (var3 >= var2)) ^ (var4 >= var2)) ^ (var4 > var2)) ^ (((char)var3) >= ((char)var2))) ^ (((char)var4) >= ((char)var2));
    } else {
        var5 = (var0 + 1);
        var6 = (var0 + 2);
        var7 = (var0 + 3);
        var8 = (var0 + 4);
        return (((((((((((var0 > var2) ^ (var5 >= var2)) ^ (((char)var0) > ((char)var2))) ^ (((char)var5) >= ((char)var2))) ^ (var6 >= var2)) ^ (((char)var6) >= ((char)var2))) ^ (((char)var6) <= ((char)var5))) ^ (var7 >= var2)) ^ (((char)var7) >= ((char)var5))) ^ (var8 >= var2)) ^ (((char)var8) >= ((char)var5))) ^ (((char)var8) >= ((char)var2));
    }
}

uint32_t test_add_nuw(uint8_t var0, uint8_t var1, uint8_t var2){
    uint8_t var3;
    uint8_t var4;
    uint8_t var5;
    uint8_t var6;
    uint8_t var7;
    uint8_t var8;
    block0:
    if ((var0 + 3) >= var2) {
        var3 = (var0 + 1);
        var4 = (var0 + 3);
        return (((((var0 > var2) ^ (var3 >= var2)) ^ (var4 >= var2)) ^ (var4 > var2)) ^ (((char)var3) >= ((char)var2))) ^ (((char)var4) >= ((char)var2));
    } else {
        var5 = (var0 + 1);
        var6 = (var0 + 2);
        var7 = (var0 + 3);
        var8 = (var0 + 4);
        return (((((((((((var0 > var2) ^ (var5 >= var2)) ^ (((char)var0) > ((char)var2))) ^ (((char)var5) >= ((char)var2))) ^ (var6 >= var2)) ^ (((char)var6) >= ((char)var2))) ^ (((char)var6) <= ((char)var5))) ^ (var7 >= var2)) ^ (((char)var7) >= ((char)var5))) ^ (var8 >= var2)) ^ (((char)var8) >= ((char)var5))) ^ (((char)var8) >= ((char)var2));
    }
}

uint32_t test_and_ule_sge(uint32_t var0, uint32_t var1, uint32_t var2, uint32_t var3){
    block0:
    if ((var0 <= var1) && (((int)var1) <= ((int)var2))) {
        return (((((((var0 <= var2) ^ (var0 <= var1)) ^ (var1 <= var2)) ^ (var0 <= var3)) ^ (((int)var0) <= ((int)var2))) ^ (((int)var0) <= ((int)var1))) ^ (((int)var1) <= ((int)var2))) ^ (((int)var0) <= ((int)var3));
    } else {
        return (((((((var0 <= var2) ^ (var0 <= var3)) ^ (var0 <= var1)) ^ (var1 <= var2)) ^ (((int)var0) <= ((int)var2))) ^ (((int)var0) <= ((int)var3))) ^ (((int)var0) <= ((int)var1))) ^ (((int)var1) <= ((int)var2));
    }
}

uint32_t test_sub_nuw(uint8_t var0, uint8_t var1, uint8_t var2){
    uint8_t var3;
    uint8_t var4;
    uint8_t var5;
    uint8_t var6;
    uint8_t var7;
    uint8_t var8;
    block0:
    if ((var0 - 3) >= var2) {
        var3 = (var0 - 1);
        var4 = (var0 + 3);
        return (((((var0 > var2) ^ (var3 >= var2)) ^ (var4 >= var2)) ^ (var4 > var2)) ^ (((char)var3) >= ((char)var2))) ^ (((char)var4) >= ((char)var2));
    } else {
        var5 = (var0 - 1);
        var6 = (var0 - 2);
        var7 = (var0 - 3);
        var8 = (var0 - 4);
        return (((((((((((var0 > var2) ^ (var5 >= var2)) ^ (((char)var0) > ((char)var2))) ^ (((char)var5) >= ((char)var2))) ^ (var6 >= var2)) ^ (((char)var6) >= ((char)var2))) ^ (((char)var6) <= ((char)var5))) ^ (var7 >= var2)) ^ (((char)var7) >= ((char)var5))) ^ (var8 >= var2)) ^ (((char)var8) >= ((char)var5))) ^ (((char)var8) >= ((char)var2));
    }
}

