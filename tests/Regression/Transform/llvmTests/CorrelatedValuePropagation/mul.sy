// This file is automatically generated by llvm2c from llvm/test/Transforms/CorrelatedValuePropagation/mul

// function declarations
uint32_t nsw_range1(uint8_t var0);
uint32_t nuw_range1(uint8_t var0);
uint32_t nuw_range2(uint8_t var0);
uint32_t one_bit(uint32_t var0, uint32_t var1);
uint8_t test0(uint8_t var0);
uint8_t test1(uint8_t var0);
uint8_t test2(uint8_t var0);
uint8_t test3(uint8_t var0);
uint8_t test4(uint8_t var0);
uint8_t test5(uint8_t var0);
uint8_t test6(uint8_t var0);

uint32_t nsw_range1(uint8_t var0){
    char var1;
    block0:
    var1 = (((char)var0) + ((char)-3));
    return var1 < (((char)var1) * ((char)4));
}

uint32_t nuw_range1(uint8_t var0){
    block0:
    return ((((char)var0) + ((char)1)) * 4) == 0;
}

uint32_t nuw_range2(uint8_t var0){
    block0:
    return ((uint8_t)((((char)var0) + ((char)3)) * 4)) < 2;
}

uint32_t one_bit(uint32_t var0, uint32_t var1){
    block0:
    return var0 * var1;
}

uint8_t test0(uint8_t var0){
    block0:
    if (var0 < 3) {
        return var0 * 50;
    } else {
        return 0;
    }
}

uint8_t test1(uint8_t var0){
    block0:
    if (var0 < 4) {
        return var0 * 50;
    } else {
        return 0;
    }
}

uint8_t test2(uint8_t var0){
    block0:
    if (var0 < 6) {
        return var0 * 50;
    } else {
        return 0;
    }
}

uint8_t test3(uint8_t var0){
    block0:
    if (var0 < 7) {
        return var0 * 50;
    } else {
        return 0;
    }
}

uint8_t test4(uint8_t var0){
    block0:
    if ((((char)var0) < ((char)3)) && (((char)var0) > ((char)-3))) {
        return var0 * 50;
    } else {
        return 0;
    }
}

uint8_t test5(uint8_t var0){
    block0:
    if ((((char)var0) < ((char)3)) && (((char)var0) > ((char)-4))) {
        return var0 * 50;
    } else {
        return 0;
    }
}

uint8_t test6(uint8_t var0){
    block0:
    if ((((char)var0) < ((char)4)) && (((char)var0) > ((char)-3))) {
        return var0 * 50;
    } else {
        return 0;
    }
}

