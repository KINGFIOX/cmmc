InstInfo:
  IntegerBinaryWithOp2:
    Format: $Mnemonic:Template $Rd:GPR[Def], $Rn:GPR[Use], $Op2:Op2[Use]
    Instances:
      ADD:
        Mnemonic: add
      SUB:
        Mnemonic: sub
      AND:
        Mnemonic: and
      ORR:
        Mnemonic: orr
      EOR:
        Mnemonic: eor
      ORN:
        Mnemonic: orn
      BIC:
        Mnemonic: bic

  MUL:
    Format: mul $Rd:GPR[Def], $Rm:GPR[Use], $Rs:GPR[Use]

  IntegerBinary:
    Format: $Mnemonic:Template $Rd:GPR[Def], $Rn:GPR[Use], $Rm:GPR[Use]
    Instances:
      SDIV:
        Mnemonic: sdiv
      UDIV:
        Mnemonic: udiv
      SEL:
        Mnemonic: sel

  Move:
    Format: $Mnemonic:Template $Rd:GPR[Def], $Op2:Op2[Use]
    Instances:
      MOV:
        Mnemonic: mov
      MVN:
        Mnemonic: mvn

  MoveGPR:
    Format: mov $Rd:GPR[Def], $Rs:GPR[Use]
    Flag: [RegCopy]

  MoveCond:
    Format: "$Mnemonic:Template$CF:CondField[Metadata] $Rd:GPR[Def], $Op2:Op2[Use] @ Implicit Use: $CC:CC[Use]"
    Instances:
      MOV_Cond:
        Mnemonic: mov
      MVN_Cond:
        Mnemonic: mvn

  Shift:
    Format: $Mnemonic:Template $Rd:GPR[Def], $Rm:GPR[Use], $Sh:Shamt[Use]
    Instances:
      ASR:
        Mnemonic: asr
      LSL:
        Mnemonic: lsl
      LSR:
        Mnemonic: lsr
      ROR:
        Mnemonic: ror

  Comparing:
    Format: "$Mnemonic:Template $Rn:GPR[Use], $Op2:Op2[Use] @ Implicit Def: $CC:CC[Def]"
    Instances:
      CMP:
        Mnemonic: cmp
      CMN:
        Mnemonic: cmn

  B:
    Format: b $Tgt:Reloc[Metadata]
    Flag: [Terminator, Branch, NoFallthrough]

  B_Cond:
    Format: "b$CF:CondField[Metadata] $Tgt:Reloc[Metadata] @ Implicit Use: $CC:CC[Use], Branch Prob: $Prob:Prob[Metadata]"
    Flag: [Terminator, Branch]

  BL:
    Format: bl $Tgt:Reloc[Metadata]
    Flag: [Call]

  BX:
    Format: bx $Rm:GPR[Use]
    Flag: [Terminator, NoFallthrough, Return]

  VLDR:
    Format: $Mnemonic:Template $Fd:FPR[Def], [$Rn:BaseLike[Use], $Imm:AddrImmVFP[Metadata]]
    Flag: [Load]
    Instances:
      VLDR:
        Mnemonic: vldr

  Load:
    Format: $Mnemonic:Template $Rd:GPR[Def], [$Rn:BaseLike[Use], $Imm:AddrImm13[Metadata]]
    Flag: [Load]
    CustomVerifier: true
    Instances:
      LDR:
        Mnemonic: ldr
      LDRB:
        Mnemonic: ldrb
      LDRSB:
        Mnemonic: ldrsb
      LDRH:
        Mnemonic: ldrh
      LDRSH:
        Mnemonic: ldrsh

  VSTR:
    Format: $Mnemonic:Template $Fd:FPR[Use], [$Rn:BaseLike[Use], $Imm:AddrImmVFP[Metadata]]
    Flag: [Store]
    Instances:
      VSTR:
        Mnemonic: vstr

  Store:
    Format: $Mnemonic:Template $Rd:GPR[Use], [$Rn:BaseLike[Use], $Imm:AddrImm13[Metadata]]
    Flag: [Store]
    CustomVerifier: true
    Instances:
      STR:
        Mnemonic: str
      STRB:
        Mnemonic: strb
      STRH:
        Mnemonic: strh

  MOVW:
    Format: movw $Rd:GPR[Def], $Imm:UImm16[Metadata]
  MOVW_Cond:
    Format: "movw$CF:CondField[Metadata] $Rd:GPR[Def], $Imm:UImm16[Metadata] @ Implicit Use: $CC:CC[Use]"
  MOVT:
    Format: "movt $Rd:GPR[Def], $Imm:UImm16[Metadata] @ Implicit Use: $Rs:GPR[Use]"
    CustomVerifier: true

  FloatingBinary:
    Format: $Mnemonic:Template $Fd:FPR[Def], $Fn:FPR[Use], $Fm:FPR[Use]
    Instances:
      VADD_F32:
        Mnemonic: vadd.f32
      VSUB_F32:
        Mnemonic: vsub.f32
      VMUL_F32:
        Mnemonic: vmul.f32
      VDIV_F32:
        Mnemonic: vdiv.f32

  FloatingUnary:
    Format: $Mnemonic:Template $Fd:FPR[Def], $Fm:FPR[Use]
    Instances:
      VNEG_F32:
        Mnemonic: vneg.f32
      VABS_F32:
        Mnemonic: vabs.f32

  VCMP_F32:
    Format: "vcmp.f32 $Fd:FPR[Use], $Fm:FPR[Use] @ Implicit Def: $CC:FCC[Def]"

  VCMP_F32_WithZero:
    Format: "vcmp.f32 $Fd:FPR[Use], #0.0 @ Implicit Def: $CC:FCC[Def]"

  TRANSFER_FPSCR_FLAG:
    Format: vmrs $CC:CC[Def], $FCC:FCC[Use]

  VCVT_F32_S32:
    Format: vcvt.f32.s32 $Fd:FPR[Def], $Rm:FPR[Use]

  VCVT_S32_F32:
    Format: vcvt.s32.f32 $Rd:FPR[Def], $Fm:FPR[Use]

  VMOV:
    Format: vmov.f32 $Fd:FPR[Def], $Fm:FPR[Use]
    Flag: [RegCopy]

  VMOV_Cond:
    Format: "vmov$CF:CondField[Metadata].f32 $Fd:FPR[Def], $Fm:FPR[Use] @ Implicit Use: $CC:CC[Use]"

  VMOV_GPR2FPR:
    Format: vmov $Sn:FPR[Def], $Rd:GPR[Use]

  VMOV_FPR2GPR:
    Format: vmov $Rd:GPR[Def], $Sn:FPR[Use]

  VMOV_Constant:
    Format: vmov.f32 $Fd:FPR[Def], $Imm:FP32[Metadata]
    Flag: [LoadConstant]

  PUSH:
    Format: push $List:RegList[Metadata]
    Flag: [Store]

  POP:
    Format: pop $List:RegList[Metadata]
    Flag: [Load]

  MOVT_MOVW_PAIR:
    Format: movt_movw_pair $Rd:GPR[Def], $Hi:UImm16[Metadata], $Lo:UImm16[Metadata]
    Flag: [LegalizePreRA]

  NZCVFlag2GPR:
    Format: nzcvflag2gpr $Rd:GPR[Def], $CC:CC[Use], $CF:CondField[Metadata]
    Flag: [LegalizePreRA]

  Select_GPR:
    Format: select_gpr $Rd:GPR[Def], $Rn:GPR[Use], $Rm:GPR[Use], $CC:CC[Use], $CF:CondField[Metadata]
    Flag: [LegalizePreRA]

  Select_FPR:
    Format: select_fpr $Rd:FPR[Def], $Rn:FPR[Use], $Rm:FPR[Use], $CC:CC[Use], $CF:CondField[Metadata]
    Flag: [LegalizePreRA]

  LoadGlobalAddr:
    Format: load_global_address $Rd:GPR[Def], $Reloc:Reloc[Metadata]
    Flag: [LoadConstant, LegalizePreRA]

  UNIMP:
    Format: .inst 0xdeff
    Flag: [Terminator, NoFallthrough]

InstSelection:
  - Pattern:
      InstLoadImmToReg:
        Dst: $Dst
        Imm: $Imm
        $Predicate: isOperandOp2Constant($Imm)
    Replace:
      MOV:
        Rd: $Dst
        Op2: $Imm

  - Pattern:
      InstLoadImm:
        Dst: $Dst
        Imm: $Imm
        $Predicate: isOperandOp2Constant($Imm)
    Replace:
      MOV:
        Rd: $Dst
        Op2: $Imm

  - Pattern:
      InstLoadImmToReg:
        Dst: $Dst
        Imm: $Imm
        $Predicate: selectInvertedOp2Constant($Imm, [$InvertedImm])
    Replace:
      MVN:
        Rd: $Dst
        Op2: $InvertedImm

  - Pattern:
      InstLoadImm:
        Dst: $Dst
        Imm: $Imm
        $Predicate: selectInvertedOp2Constant($Imm, [$InvertedImm])
    Replace:
      MVN:
        Rd: $Dst
        Op2: $InvertedImm

  - Pattern:
      InstLoadImmToReg:
        Dst: $Dst
        Imm: $Imm
        $Predicate: selectGenericImm32($Imm, [$Hi], [$Lo])
    Replace:
      MOVT_MOVW_PAIR:
        Rd: $Dst
        Hi: $Hi
        Lo: $Lo

  - Pattern:
      InstLoadImm:
        Dst: $Dst
        Imm: $Imm
        $Predicate: selectGenericImm32($Imm, [$Hi], [$Lo])
    Replace:
      MOVT_MOVW_PAIR:
        Rd: $Dst
        Hi: $Hi
        Lo: $Lo

  - Pattern:
      InstAdd:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        $Predicate: isOperandIReg($Lhs) && isOperandOp2($Rhs)
    Replace:
      ADD:
        Rd: $Dst
        Rn: $Lhs
        Op2: $Rhs

  - Pattern:
      InstSub:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        $Predicate: isOperandIReg($Lhs) && isOperandOp2($Rhs)
    Replace:
      SUB:
        Rd: $Dst
        Rn: $Lhs
        Op2: $Rhs

  - Pattern:
      InstAnd:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        $Predicate: isOperandIReg($Lhs) && isOperandOp2($Rhs)
    Replace:
      AND:
        Rd: $Dst
        Rn: $Lhs
        Op2: $Rhs

  - Pattern:
      InstOr:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        $Predicate: isOperandIReg($Lhs) && isOperandOp2($Rhs)
    Replace:
      ORR:
        Rd: $Dst
        Rn: $Lhs
        Op2: $Rhs

  - Pattern:
      InstXor:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        $Predicate: isOperandIReg($Lhs) && isOperandOp2($Rhs)
    Replace:
      EOR:
        Rd: $Dst
        Rn: $Lhs
        Op2: $Rhs

  - Pattern:
      InstMul:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        $Predicate: isOperandIReg($Lhs) && isOperandIReg($Rhs)
    Replace:
      MUL:
        Rd: $Dst
        Rm: $Lhs
        Rs: $Rhs

  - Pattern:
      InstShl:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        $Predicate: isOperandIReg($Lhs) && isOperandShamt($Rhs)
    Replace:
      LSL:
        Rd: $Dst
        Rm: $Lhs
        Sh: $Rhs

  - Pattern:
      InstLShr:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        $Predicate: isOperandIReg($Lhs) && isOperandShamt($Rhs)
    Replace:
      LSR:
        Rd: $Dst
        Rm: $Lhs
        Sh: $Rhs

  - Pattern:
      InstAShr:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        $Predicate: isOperandIReg($Lhs) && isOperandShamt($Rhs)
    Replace:
      ASR:
        Rd: $Dst
        Rm: $Lhs
        Sh: $Rhs

  - Pattern:
      InstS2F:
        Dst: $Dst
        Src: $Src
        $Predicate: isOperandFPR($Dst) && isOperandIReg($Src)
    Replace:
      VCVT_F32_S32:
        Fd: $Dst
        Rm:
          VMOV_GPR2FPR:
            Sn: getVRegAs(ctx, $Dst)
            Rd: $Src

  - Pattern:
      InstF2S:
        Dst: $Dst
        Src: $Src
        $Predicate: isOperandIReg($Dst) && isOperandFPR($Src)
    Replace:
      VMOV_FPR2GPR:
        Rd: $Dst
        Sn:
          VCVT_S32_F32:
            Rd: getVRegAs(ctx, $Src)
            Fm: $Src

  - Pattern:
      InstFAdd:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        $Predicate: isOperandFPR($Lhs) && isOperandFPR($Rhs)
    Replace:
      VADD_F32:
        Fd: $Dst
        Fn: $Lhs
        Fm: $Rhs

  - Pattern:
      InstFSub:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        $Predicate: isOperandFPR($Lhs) && isOperandFPR($Rhs)
    Replace:
      VSUB_F32:
        Fd: $Dst
        Fn: $Lhs
        Fm: $Rhs

  - Pattern:
      InstFMul:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        $Predicate: isOperandFPR($Lhs) && isOperandFPR($Rhs)
    Replace:
      VMUL_F32:
        Fd: $Dst
        Fn: $Lhs
        Fm: $Rhs

  - Pattern:
      InstFDiv:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        $Predicate: isOperandFPR($Lhs) && isOperandFPR($Rhs)
    Replace:
      VDIV_F32:
        Fd: $Dst
        Fn: $Lhs
        Fm: $Rhs

  - Pattern:
      InstFNeg:
        Dst: $Dst
        Src: $Src
        $Predicate: isOperandFPR($Dst) && isOperandFPR($Src)
    Replace:
      VNEG_F32:
        Fd: $Dst
        Fm: $Src

  - Pattern:
      VMOV_FPR2GPR:
        Rd: $Dst
        Sn:
          VMOV_GPR2FPR:
            Rd: $Src
            Sn: $Intermediate
            $Predicate: "!ctx.isDefinedAfter($Intermediate, *ctx.lookupDef($Intermediate))"
    Replace:
      InstCopyToReg:
        Dst: $Dst
        Src: $Src

  - Pattern:
      VMOV_GPR2FPR:
        Sn: $Dst
        Rd:
          VMOV_FPR2GPR:
            Sn: $Src
            Rd: $Intermediate
            $Predicate: "!ctx.isDefinedAfter($Intermediate, *ctx.lookupDef($Intermediate))"
    Replace:
      VMOV:
        Fd: $Dst
        Fm: $Src

  - Pattern:
      InstZExt:
        Dst: $Dst
        Src: $Src
        $Predicate: isOperandBoolReg($Src)
    Replace:
      InstCopy:
        Dst: $Dst
        Src: $Src

  - Pattern:
      InstZExt:
        Dst: $Dst
        Src: $Src
        $Predicate: isOperandIReg($Src)
    Replace:
      InstAnd:
        Dst: $Dst
        Lhs: $Src
        Rhs: getZExtMask(($Dst).type(), ($Src).type())

  - Pattern:
      InstSExt:
        Dst: $Dst
        Src: $Src
        $Predicate: isOperandIReg($Src)
    Replace:
      InstCopy:
        Dst: $Dst
        Src: $Src

  - Pattern:
      InstLoadGlobalAddress:
        Dst: $Dst
        Addr: $Addr
    Replace:
      LoadGlobalAddr:
        Rd: $Dst
        Reloc: $Addr

  - Pattern:
      InstJump:
        Tgt: $Tgt
    Replace:
      B:
        Tgt: $Tgt

  - Pattern:
      InstBranch:
        Cond:
          NZCVFlag2GPR:
            Rd: $Cond
            CC: $CC
            CF: $CF
            $Predicate: "!ctx.isDefinedAfter($CC, *ctx.lookupDef($Cond))"
        Tgt: $Reloc
        Prob: $Prob
        $Predicate: isOperandIReg($Cond)
    Replace:
      B_Cond:
        CC: $CC
        CF: $CF
        Tgt: $Reloc
        Prob: $Prob

  - Pattern:
      InstSelect:
        Dst: $Dst
        Cond:
          NZCVFlag2GPR:
            Rd: $Cond
            CC: $CC
            CF: $CF
            $Predicate: "!ctx.isDefinedAfter($CC, *ctx.lookupDef($Cond))"
        Lhs: $Lhs
        Rhs: $Rhs
        $Predicate: isOperandIReg($Dst)
    Replace:
      Select_GPR:
        Rd: $Dst
        Rn: $Lhs
        Rm: $Rhs
        CC: $CC
        CF: $CF

  - Pattern:
      InstSelect:
        Dst: $Dst
        Cond:
          NZCVFlag2GPR:
            Rd: $Cond
            CC: $CC
            CF: $CF
            $Predicate: "!ctx.isDefinedAfter($CC, *ctx.lookupDef($Cond))"
        Lhs: $Lhs
        Rhs: $Rhs
        $Predicate: isOperandFPR($Dst)
    Replace:
      Select_FPR:
        Rd: $Dst
        Rn: $Lhs
        Rm: $Rhs
        CC: $CC
        CF: $CF

  # Fallbacks for cmp/branch/select
  - Pattern:
      InstSCmp:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        Op: $Op
        $Predicate: isOperandIReg($Lhs) && isOperandOp2($Rhs)
    Replace:
      NZCVFlag2GPR:
        Rd: $Dst
        CC:
          CMP:
            Rn: $Lhs
            Op2: $Rhs
            CC: getCC()
        CF: getCondFieldSCmp($Op)
  - Pattern:
      InstUCmp:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        Op: $Op
        $Predicate: isOperandIReg($Lhs) && isOperandOp2($Rhs)
    Replace:
      NZCVFlag2GPR:
        Rd: $Dst
        CC:
          CMP:
            Rn: $Lhs
            Op2: $Rhs
            CC: getCC()
        CF: getCondFieldUCmp($Op)

  - Pattern:
      InstFCmp:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        Op: $Op
        $Predicate: isOperandFPR($Lhs) && isOperandFPR($Rhs)
    Replace:
      NZCVFlag2GPR:
        Rd: $Dst
        CC:
          TRANSFER_FPSCR_FLAG:
            CC: getCC()
            FCC:
              VCMP_F32:
                Fd: $Lhs
                Fm: $Rhs
                CC: getFCC()
        CF: getCondFieldFCmp($Op)

  - Pattern:
      InstBranch:
        Cond: $Cond
        Tgt: $Reloc
        Prob: $Prob
        $Predicate: isOperandIReg($Cond) && isNotCmp(ctx, $Cond)
    Replace:
      B_Cond:
        Tgt: $Reloc
        Prob: $Prob
        CC:
          CMP:
            CC: getCC()
            Rn: $Cond
            Op2: getZero($Cond)
        CF: MIROperand::asImm(CondField::NE, OperandType::CondField)

  - Pattern:
      InstSelect:
        Dst: $Dst
        Cond: $Cond
        Lhs: $Lhs
        Rhs: $Rhs
        $Predicate: isOperandIReg($Dst) && isOperandIReg($Lhs) && isOperandIReg($Rhs) && isNotCmp(ctx, $Cond)
    Replace:
      Select_GPR:
        Rd: $Dst
        Rn: $Lhs
        Rm: $Rhs
        CC:
          CMP:
            Rn: $Cond
            Op2: getZero($Cond)
            CC: getCC()
        CF: MIROperand::asImm(CondField::EQ, OperandType::CondField)

  - Pattern:
      InstSelect:
        Dst: $Dst
        Cond: $Cond
        Lhs: $Lhs
        Rhs: $Rhs
        $Predicate: isOperandFPR($Dst) && isNotCmp(ctx, $Cond)
    Replace:
      Select_FPR:
        Rd: $Dst
        Rn: $Lhs
        Rm: $Rhs
        CC:
          CMP:
            Rn: $Cond
            Op2: getZero($Cond)
            CC: getCC()
        CF: MIROperand::asImm(CondField::EQ, OperandType::CondField)

  # Load/Store
  - Pattern:
      InstLoad:
        Dst: $Dst
        Addr: $Addr
        $Predicate: selectAddrOffset($Addr, ctx, [$Base], [$Offset], getLoadOpcode($Dst))
    Replace:
      Load:
        $Opcode: getLoadOpcode($Dst)
        $Template: LDR
        Rd: $Dst
        Rn: $Base
        Imm: $Offset

  - Pattern:
      InstZExt:
        Dst: $Dst
        Src:
          InstLoad:
            Dst: $Val
            Addr: $Addr
            $Predicate: selectAddrOffset($Addr, ctx, [$Base], [$Offset], getZExtLoadOpcode($Val))
    Replace:
      Load:
        $Opcode: getZExtLoadOpcode($Val)
        $Template: LDRB
        Rd: $Dst
        Rn: $Base
        Imm: $Offset

  - Pattern:
      InstStore:
        Src:
          InstTrunc:
            Dst: $Dst
            Src: $Src
        Addr: $Addr
        $Predicate: isOperandVRegOrISAReg($Src) && selectAddrOffset($Addr, ctx, [$Base], [$Offset], getStoreOpcode($Dst))
    Replace:
      Store:
        $Opcode: getStoreOpcode($Dst)
        $Template: STR
        Rd: $Src
        Rn: $Base
        Imm: $Offset

  - Pattern:
      InstStore:
        Src: $Src
        Addr: $Addr
        $Predicate: isOperandVRegOrISAReg($Src) && selectAddrOffset($Addr, ctx, [$Base], [$Offset], getStoreOpcode($Src))
    Replace:
      Store:
        $Opcode: getStoreOpcode($Src)
        $Template: STR
        Rd: $Src
        Rn: $Base
        Imm: $Offset

  - Pattern:
      InstUnreachable:
    Replace:
      UNIMP:

  # For csmith
  - Pattern:
      InstZExt:
        Dst: $Dst
        Src: $Src
        $Predicate: isOperandIReg($Src) && ($Dst).type() == OperandType::Int32
    Replace:
      AND:
        Rd: $Dst
        Rn: $Src
        Op2:
          InstLoadImm:
            Dst: getVRegAs(ctx, $Src)
            Imm: getZExtMask(($Dst).type(), ($Src).type())

  - Pattern:
      InstTrunc:
        Dst: $Dst
        Src: $Src
        $Predicate: isOperandIReg($Src) && ($Dst).type() == OperandType::Int16
    Replace:
      AND:
        Rd: $Dst
        Rn: $Src
        Op2:
          InstLoadImm:
            Dst: getVRegAs(ctx, $Src)
            Imm: getTruncMask(($Dst).type(), ($Src).type())

  - Pattern:
      InstTrunc:
        Dst: $Dst
        Src: $Src
        $Predicate: isOperandIReg($Src) && ($Dst).type() == OperandType::Int8
    Replace:
      AND:
        Rd: $Dst
        Rn: $Src
        Op2: getTruncMask(($Dst).type(), ($Src).type())

ScheduleModel:
  cortex_a72:
    CustomPeepholeOpt: true
