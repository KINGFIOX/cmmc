InstInfo:
  IntegerBinaryWithOp2:
    Format: $Mnemonic:Template $Rd:GPR[Def], $Rn:GPR[Use], $Op2:Op2[Use]
    Instances:
      ADD:
        Mnemonic: add
      SUB:
        Mnemonic: sub
      AND:
        Mnemonic: and
      ORR:
        Mnemonic: orr
      EOR:
        Mnemonic: eor
      ORN:
        Mnemonic: orn
      BIC:
        Mnemonic: bic

  MUL:
    Format: mul $Rd:GPR[Def], $Rm:GPR[Use], $Rs:GPR[Use]

  IntegerBinary:
    Format: $Mnemonic:Template $Rd:GPR[Def], $Rn:GPR[Use], $Rm:GPR[Use]
    Instances:
      SDIV:
        Mnemonic: sdiv
      UDIV:
        Mnemonic: udiv
      SEL:
        Mnemonic: sel

  Move:
    Format: $Mnemonic:Template $Rd:GPR[Def], $Op2:Op2[Use]
    Instances:
      MOV:
        Mnemonic: mov
      MVN:
        Mnemonic: mvn

  Shift:
    Format: $Mnemonic:Template $Rd:GPR[Def], $Rm:GPR[Use], $Sh:Shamt[Use]
    Instances:
      ASR:
        Mnemonic: asr
      LSL:
        Mnemonic: lsl
      LSR:
        Mnemonic: lsr
      ROR:
        Mnemonic: ror

  Comparing:
    Format: $Mnemonic:Template $Rn:GPR[Use], $Op2:Op2[Use]
    Instances:
      CMP:
        Mnemonic: cmp
      CMN:
        Mnemonic: cmn
      TST:
        Mnemonic: tst
      TEQ:
        Mnemonic: teq

  B:
    Format: b $Tgt:Reloc[Metadata]
    Flag: [Terminator, Branch, NoFallthrough]
  
  BL:
    Format: bl $Tgt:Reloc[Metadata]
    Flag: [Call]
  
  BX:
    Format: bx $Rm:GPR[Use]
    Flag: [Terminator, NoFallthrough, Return]

  BranchCompare:
    Format: "$Mnemonic:Template $Rn:GPR[Use], $Tgt:Reloc[Metadata] @ Branch Prob: $Prob:Prob[Metadata]"
    Flag: [Terminator, Branch]
    Instances:
      CBZ:
        Mnemonic: cbz
      CBNZ:
        Mnemonic: cbnz

  VLDR:
    Format: $Mnemonic:Template $Fd:FPR[Def], [$Rn:GPR[Use], $Imm:Imm13[Metadata]]
    Flag: [Load]
    Instances:
      VLDR:
        Mnemonic: vldr

  Load:
    Format: $Mnemonic:Template $Rd:GPR[Def], [$Rn:GPR[Use], $Imm:Imm13[Metadata]]
    Flag: [Load]
    Instances:
      LDR:
        Mnemonic: ldr
      LDRB:
        Mnemonic: ldrb
      LDRSB:
        Mnemonic: ldrsb

  VSTR:
    Format: $Mnemonic:Template $Fd:FPR[Use] [$Rn:GPR[Use], $Imm:Imm13[Metadata]]
    Flag: [Store]
    Instances:
      VSTR:
        Mnemonic: vstr

  Store:
    Format: $Mnemonic:Template $Rd:GPR[Use] [$Rn:GPR[Use], $Imm:Imm13[Metadata]]
    Flag: [Store]
    Instances:
      STR:
        Mnemonic: str
      STRB:
        Mnemonic: strb

  MoveImmediate:
    Format: $Mnemonic:Template $Rd:GPR[Def], $Imm:UImm16[Metadata]
    Instances:
      MOVW:
        Mnemonic: movw
      MOVT:
        Mnemonic: movt

  FloatingBinary:
    Format: $Mnemonic:Template $Fd:FPR[Def], $Fn:FPR[Use], $Fm:FPR[Use]
    Instances:
      VADD:
        Mnemonic: vadd
      VSUB:
        Mnemonic: vsub
      VMUL:
        Mnemonic: vmul
      VDIV:
        Mnemonic: vdiv
      VNEG:
        Mnemonic: vneg
      VABS:
        Mnemonic: vabs

  VCMP:
    Format: vcmp $Fd:FPR[Use], $Fm:FPR[Use]

  VCMP_WithZero:
    Format: vcmp $Fd:FPR[Use], #0.0

  VCVT_F32_S32:
    Format: vcvt.f32.s32 $Fd:FPR[Def], $Rm:GPR[Use]

  VCVT_S32_F32:
    Format: vcvt.s32.f32 $Rd:GPR[Def], $Fm:FPR[Use]

  VMOV:
    Format: vmov.f32 $Fd:FPR[Def], $Fm:FPR[Use]
  
  VMOV_Constant:
    Format: vmov.f32 $Fd:FPR[Def], $Imm:FP32[Metadata]

InstSelection:
  - Pattern:
      InstLoadImmToReg:
        Dst: $Dst
        Imm: $Imm
        $Predicate: isOperandOp2Constant($Imm)
    Replace:
      MOV:
        Rd: $Dst
        Op2: $Imm

  - Pattern:
      InstLoadImm:
        Dst: $Dst
        Imm: $Imm
        $Predicate: isOperandOp2Constant($Imm)
    Replace:
      MOV:
        Rd: $Dst
        Op2: $Imm

  - Pattern:
      InstLoadImmToReg:
        Dst: $Dst
        Imm: $Imm
        $Predicate: selectInvertedOp2Constant($Imm, [$InvertedImm])
    Replace:
      MVN:
        Rd: $Dst
        Op2: $InvertedImm

  - Pattern:
      InstAdd:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        $Predicate: isOperandIReg($Lhs) && isOperandOp2($Rhs)
    Replace:
      ADD:
        Rd: $Dst
        Rn: $Lhs
        Op2: $Rhs

  - Pattern:
      InstSub:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        $Predicate: isOperandIReg($Lhs) && isOperandOp2($Rhs)
    Replace:
      SUB:
        Rd: $Dst
        Rn: $Lhs
        Op2: $Rhs

  - Pattern:
      InstAnd:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        $Predicate: isOperandIReg($Lhs) && isOperandOp2($Rhs)
    Replace:
      AND:
        Rd: $Dst
        Rn: $Lhs
        Op2: $Rhs

  - Pattern:
      InstOr:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        $Predicate: isOperandIReg($Lhs) && isOperandOp2($Rhs)
    Replace:
      ORR:
        Rd: $Dst
        Rn: $Lhs
        Op2: $Rhs

  - Pattern:
      InstXor:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        $Predicate: isOperandIReg($Lhs) && isOperandOp2($Rhs)
    Replace:
      EOR:
        Rd: $Dst
        Rn: $Lhs
        Op2: $Rhs

  - Pattern:
      InstMul:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        $Predicate: isOperandIReg($Lhs) && isOperandIReg($Rhs)
    Replace:
      MUL:
        Rd: $Dst
        Rm: $Lhs
        Rs: $Rhs

  - Pattern:
      InstSDiv:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        $Predicate: isOperandIReg($Lhs) && isOperandIReg($Rhs)
    Replace:
      SDIV:
        Rd: $Dst
        Rn: $Lhs
        Rm: $Rhs
  
  - Pattern:
      InstUDiv:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        $Predicate: isOperandIReg($Lhs) && isOperandIReg($Rhs)
    Replace:
      UDIV:
        Rd: $Dst
        Rn: $Lhs
        Rm: $Rhs

ScheduleModel:
  cortex_a72:
    CustomPeepholeOpt: true
 