InstInfo:
  # RV32I Base Integer Instruction Set
  RType:
    Format: $Mnemonic:Template $Rd:GPR[Def], $Rs1:GPR[Use], $Rs2:GPR[Use]
  IType:
    Format: $Mnemonic:Template $Rd:GPR[Def], $Rs1:GPR[Use], $Imm:Imm12[Metadata]
  UType:
    Format: $Mnemonic:Template $Rd:GPR[Def], $Imm:UImm20[Metadata]

  ## 2.4 Integer Computational Instructions
  InstanceRII:
    Template: IType
    ADDI:
      Mnemonic: addi
    SLTI:
      Mnemonic: slti
    SLTIU:
      Mnemonic: sltiu
    ANDI:
      Mnemonic: andi
    ORI:
      Mnemonic: ori
    XORI:
      Mnemonic: xori
  ShiftImm:
    Format: $Mnemonic:Template $Rd:GPR[Def], $Rs1:GPR[Use], $Imm:UImm6[Metadata]
    Instances:
      SLLI:
        Mnemonic: slli
      SRLI:
        Mnemonic: srli
      SRAI:
        Mnemonic: srai
  InstanceRIU:
    Template: UType
    LUI:
      Mnemonic: lui
    AUIPC:
      Mnemonic: auipc
  InstanceRRR:
    Template: RType
    ADD:
      Mnemonic: add
    SLT:
      Mnemonic: slt
    SLTU:
      Mnemonic: sltu
    AND:
      Mnemonic: and
    OR:
      Mnemonic: or
    XOR:
      Mnemonic: xor
    SLL:
      Mnemonic: sll
    SRL:
      Mnemonic: srl
    SUB:
      Mnemonic: sub
    SRA:
      Mnemonic: sra
  ## 2.5 Control Transfer Instructions
  JAL:
    Format: jal $Tgt:Reloc[Use]
    Flag: [Call]
  RET:
    Format: ret
    Flag: [Terminator, Return, NoFallthrough]
  Branches:
    Format: "$Mnemonic:Template $Rs1:GPR[Use], $Rs2:GPR[Use], $Tgt:Reloc[Use] # $Prob:Prob[Metadata]"
    Flag: [Terminator, Branch]
    Instances:
      BEQ:
        Mnemonic: beq
      BNE:
        Mnemonic: bne
      BLT:
        Mnemonic: blt
      BLE:
        Mnemonic: ble
      BGT:
        Mnemonic: bgt
      BGE:
        Mnemonic: bge
      BLTU:
        Mnemonic: bltu
      BLEU:
        Mnemonic: bleu
      BGTU:
        Mnemonic: bgtu
      BGEU:
        Mnemonic: bgeu
  J:
    Format: j $Tgt:Reloc[Metadata]
    Flag: [Terminator, Branch, NoFallthrough]
  UNIMP:
    Format: unimp
    Flag: [Terminator, NoFallthrough]
  ## 2.6 Load and Store Instructions
  Load:
    Format: $Mnemonic:Template $Rd:GPR[Def], $Imm:Imm12[Metadata]($Rs1:BaseLike[Use])
    Flag: [Load]
  InstanceLoad:
    Template: Load
    LB:
      Mnemonic: lb
    LH:
      Mnemonic: lh
    LW:
      Mnemonic: lw
    LBU:
      Mnemonic: lbu
    LHU:
      Mnemonic: lhu
  Store:
    Format: $Mnemonic:Template $Rs2:GPR[Use], $Imm:Imm12[Metadata]($Rs1:BaseLike[Use])
    Flag: [Store]
  InstanceStore:
    Template: Store
    SB:
      Mnemonic: sb
    SH:
      Mnemonic: sh
    SW:
      Mnemonic: sw
  # RV64I Base Integer Instruction Set
  ## 5.2 Integer Computational Instructions
  InstanceRIW:
    Template: IType
    ADDIW:
      Mnemonic: addiw
  ShiftImmW:
    Format: $Mnemonic:Template $Rd:GPR[Def], $Rs1:GPR[Use], $Imm:UImm5[Metadata]
    Instances:
      SLLIW:
        Mnemonic: slliw
      SRLIW:
        Mnemonic: srliw
      SRAIW:
        Mnemonic: sraiw
  InstanceRRW:
    Template: RType
    ADDW:
      Mnemonic: addw
    SUBW:
      Mnemonic: subw
    SLLW:
      Mnemonic: sllw
    SRLW:
      Mnemonic: srlw
    SRAW:
      Mnemonic: sraw
  ## 5.3 Load and Store Instructions
  InstanceLoad64:
    Template: Load
    LD:
      Mnemonic: ld
    LWU:
      Mnemonic: lwu
  InstanceStore64:
    Template: Store
    SD:
      Mnemonic: sd
  # "M" Standard Extension for Integer Multiplication and Division
  ## 6.2 Integer Multiplication Instructions
  InstanceMRR:
    Template: RType
    MUL:
      Mnemonic: mul
    MULH:
      Mnemonic: mulh
    MULHSU:
      Mnemonic: mulhsu
    MULHU:
      Mnemonic: mulhu
    MULW:
      Mnemonic: mulw
    DIV:
      Mnemonic: div
    DIVU:
      Mnemonic: divu
    REM:
      Mnemonic: rem
    REMU:
      Mnemonic: remu
    DIVW:
      Mnemonic: divw
    DIVUW:
      Mnemonic: divuw
    REMW:
      Mnemonic: remw
    REMUW:
      Mnemonic: remuw
  # "F" Standard Extension for Single-Precision Floating-Point
  FRType:
    Format: $Mnemonic:Template $Rd:FPR[Def], $Rs1:FPR[Use], $Rs2:FPR[Use]
  FFType:
    Format: $Mnemonic:Template $Rd:FPR[Def], $Rs1:FPR[Use]
  FIFType:
    Format: $Mnemonic:Template $Rd:GPR[Def], $Rs1:FPR[Use]
  FIFRTZType:
    Format: $Mnemonic:Template $Rd:GPR[Def], $Rs1:FPR[Use], rtz
  FIFFType:
    Format: $Mnemonic:Template $Rd:GPR[Def], $Rs1:FPR[Use], $Rs2:FPR[Use]
  FFIType:
    Format: $Mnemonic:Template $Rd:FPR[Def], $Rs1:GPR[Use]

  ## 11.5 Single-Precision Load and Store Instructions
  FLW:
    Format: flw $Rd:FPR[Def], $Imm:Imm12[Metadata]($Rs1:BaseLike[Use])
    Flag: [Load]
  FSW:
    Format: fsw $Rs2:FPR[Use], $Imm:Imm12[Metadata]($Rs1:BaseLike[Use])
    Flag: [Store]
  ## 11.6 Single-Precision Floating-Point Computational Instructions
  ## 11.7 Single-Precision Floating-Point Conversion and Move Instructions
  ## 11.8 Single-Precision Floating-Point Compare Instructions
  ## 11.9 Single-Precision Floating-Point Classify Instruction
  InstanceFRR:
    Template: FRType
    FADD_S:
      Mnemonic: fadd.s
    FSUB_S:
      Mnemonic: fsub.s
    FMUL_S:
      Mnemonic: fmul.s
    FDIV_S:
      Mnemonic: fdiv.s
    FMIN_S:
      Mnemonic: fmin.s
    FMAX_S:
      Mnemonic: fmax.s
  InstanceFF:
    Template: FFType
    FNEG_S:
      Mnemonic: fneg.s
    FSGNJ_S:
      Mnemonic: fsgnj.s
    FMV_S:
      Mnemonic: fmv.s
      Flag: [RegCopy]
  InstanceFIFRTZ:
    Template: FIFRTZType
    FCVT_W_S:
      Mnemonic: fcvt.w.s
    FCVT_WU_S:
      Mnemonic: fcvt.wu.s
  InstanceFIF:
    Template: FIFType
    FMV_W_X:
      Mnemonic: fmv.w.x
    FCLASS_S:
      Mnemonic: fclass.s
  InstanceFIFF:
    Template: FIFFType
    FEQ_S:
      Mnemonic: feq.s
    FLT_S:
      Mnemonic: flt.s
    FLE_S:
      Mnemonic: fle.s
  InstanceFFI:
    Template: FFIType
    FCVT_S_W:
      Mnemonic: fcvt.s.w
    FCVT_S_WU:
      Mnemonic: fcvt.s.wu
    FMV_X_W:
      Mnemonic: fmv.x.w

  # Pseudo Instructions
  LoadImm12:
    Format: "li $Rd:GPR[Def], $Imm:NonZeroImm12[Metadata]" # addiu
    Flag: [LoadConstant]

  # TODO: expand to LUI+ADDI?
  LoadImm32:
    Format: "li $Rd:GPR[Def], $Imm:NonZeroImm32[Metadata]" # lui + addi
    Flag: [LoadConstant]

  MoveGPR:
    Format: "mv $Rd:GPR[Def], $Rs1:GPR[Use]"
    Flag: [RegDef, RegCopy]

InstSelection:
  # Constants
  - Pattern:
      InstLoadGlobalAddress:
        Dst: $Dst
        Addr: $Addr
    Replace:
      ADDI:
        Rd: $Dst
        Rs1:
          AUIPC:
            Rd: getVRegAs(ctx, $Dst)
            Imm: getHighBits($Addr)
        Imm: getLowBits($Addr)

  - Pattern:
      InstLoadImmToReg:
        Dst: $Dst
        Imm: $Imm
        $Predicate: isZero($Imm)
    Replace:
      # TODO: using ResetToZero -> InstFlagLoadConstant
      MoveGPR:
        Rd: $Dst
        Rs1: getZero($Dst)

  - Pattern:
      InstLoadImm:
        Dst: $Dst
        Imm: $Imm
        $Predicate: isZero($Imm)
    Replace:
      # TODO: using InstResetToZero with flag InstFlagLoadConstant
      InstCopyFromReg:
        Dst: $Dst
        Src: getZero($Dst)

  - Pattern:
      InstLoadImmToReg:
        Dst: $Dst
        Imm: $Imm
        $Predicate: isOperandNonZeroImm12($Imm)
    Replace:
      LoadImm12:
        Rd: $Dst
        Imm: $Imm

  - Pattern:
      InstLoadImmToReg:
        Dst: $Dst
        Imm: $Imm
        $Predicate: isOperandNonZeroImm32($Imm)
    Replace:
      LoadImm32:
        Rd: $Dst
        Imm: $Imm

  - Pattern:
      InstLoadImm:
        Dst: $Dst
        Imm: $Imm
        $Predicate: isOperandNonZeroImm12($Imm)
    Replace:
      LoadImm12:
        Rd: $Dst
        Imm: $Imm

  - Pattern:
      InstLoadImm:
        Dst: $Dst
        Imm: $Imm
        $Predicate: isOperandNonZeroImm32($Imm)
    Replace:
      LoadImm32:
        Rd: $Dst
        Imm: $Imm

  # Integer Instructions
  - Pattern:
      InstAdd:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        $Predicate: isOperandI64($Dst) && isOperandIReg($Lhs) && isOperandImm12($Rhs)
    Replace:
      ADDI:
        Rd: $Dst
        Rs1: $Lhs
        Imm: $Rhs

  - Pattern:
      InstAdd:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        $Predicate: isOperandI64($Dst) && isOperandIReg($Lhs) && isOperandIReg($Rhs)
    Replace:
      ADD:
        Rd: $Dst
        Rs1: $Lhs
        Rs2: $Rhs

  - Pattern:
      InstAdd:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        $Predicate: isOperandI32($Dst) && isOperandIReg($Lhs) && isOperandImm12($Rhs)
    Replace:
      ADDIW:
        Rd: $Dst
        Rs1: $Lhs
        Imm: $Rhs

  - Pattern:
      InstAdd:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        $Predicate: isOperandI32($Dst) && isOperandIReg($Lhs) && isOperandIReg($Rhs)
    Replace:
      ADDW:
        Rd: $Dst
        Rs1: $Lhs
        Rs2: $Rhs

  - Pattern:
      $Template:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        $Predicate: isOperandIReg($Lhs) && isOperandImm12($Rhs)
      $Instances: [InstAnd, InstOr, InstXor]
    Replace:
      IntegerBinaryImm:
        $Opcode: getIntegerBinaryImmOpcode(rootOpcode)
        $Template: ANDI
        Rd: $Dst
        Rs1: $Lhs
        Imm: $Rhs

  - Pattern:
      $Template:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        $Predicate: isOperandIReg($Lhs) && isOperandIReg($Rhs)
      $Instances: [InstAnd, InstOr, InstXor]
    Replace:
      IntegerBinaryReg:
        $Opcode: getIntegerBinaryRegOpcode(rootOpcode)
        $Template: AND
        Rd: $Dst
        Rs1: $Lhs
        Rs2: $Rhs

  - Pattern:
      InstSub:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        $Predicate: isOperandI64($Dst) && isOperandIReg($Lhs) && isOperandIReg($Rhs)
    Replace:
      SUB:
        Rd: $Dst
        Rs1: $Lhs
        Rs2: $Rhs

  - Pattern:
      InstSub:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        $Predicate: isOperandI32($Dst) && isOperandIReg($Lhs) && isOperandIReg($Rhs)
    Replace:
      SUBW:
        Rd: $Dst
        Rs1: $Lhs
        Rs2: $Rhs

  - Pattern:
      InstShl:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        $Predicate: isOperandI64($Dst) && isOperandIReg($Lhs) && isOperandUImm6($Rhs)
    Replace:
      SLLI:
        Rd: $Dst
        Rs1: $Lhs
        Imm: $Rhs

  - Pattern:
      InstShl:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        $Predicate: isOperandI32($Dst) && isOperandIReg($Lhs) && isOperandUImm6($Rhs)
    Replace:
      SLLIW:
        Rd: $Dst
        Rs1: $Lhs
        Imm: $Rhs

  - Pattern:
      InstAShr:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        $Predicate: isOperandI64($Dst) && isOperandIReg($Lhs) && isOperandUImm6($Rhs)
    Replace:
      SRAI:
        Rd: $Dst
        Rs1: $Lhs
        Imm: $Rhs

  - Pattern:
      InstAShr:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        $Predicate: isOperandI32($Dst) && isOperandIReg($Lhs) && isOperandUImm6($Rhs)
    Replace:
      SRAIW:
        Rd: $Dst
        Rs1: $Lhs
        Imm: $Rhs

  - Pattern:
      InstLShr:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        $Predicate: isOperandI64($Dst) && isOperandIReg($Lhs) && isOperandUImm6($Rhs)
    Replace:
      SRLI:
        Rd: $Dst
        Rs1: $Lhs
        Imm: $Rhs

  - Pattern:
      InstLShr:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        $Predicate: isOperandI32($Dst) && isOperandIReg($Lhs) && isOperandUImm6($Rhs)
    Replace:
      SRLIW:
        Rd: $Dst
        Rs1: $Lhs
        Imm: $Rhs

  - Pattern:
      InstShl:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        $Predicate: isOperandI64($Dst) && isOperandIReg($Lhs) && isOperandIReg($Rhs)
    Replace:
      SLL:
        Rd: $Dst
        Rs1: $Lhs
        Rs2: $Rhs

  - Pattern:
      InstShl:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        $Predicate: isOperandI32($Dst) && isOperandIReg($Lhs) && isOperandIReg($Rhs)
    Replace:
      SLLW:
        Rd: $Dst
        Rs1: $Lhs
        Rs2: $Rhs

  - Pattern:
      InstAShr:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        $Predicate: isOperandI64($Dst) && isOperandIReg($Lhs) && isOperandIReg($Rhs)
    Replace:
      SRA:
        Rd: $Dst
        Rs1: $Lhs
        Rs2: $Rhs

  - Pattern:
      InstAShr:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        $Predicate: isOperandI32($Dst) && isOperandIReg($Lhs) && isOperandIReg($Rhs)
    Replace:
      SRAW:
        Rd: $Dst
        Rs1: $Lhs
        Rs2: $Rhs

  - Pattern:
      InstLShr:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        $Predicate: isOperandI64($Dst) && isOperandIReg($Lhs) && isOperandIReg($Rhs)
    Replace:
      SRL:
        Rd: $Dst
        Rs1: $Lhs
        Rs2: $Rhs

  - Pattern:
      InstLShr:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        $Predicate: isOperandI32($Dst) && isOperandIReg($Lhs) && isOperandIReg($Rhs)
    Replace:
      SRLW:
        Rd: $Dst
        Rs1: $Lhs
        Rs2: $Rhs

  - Pattern:
      InstMul:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        $Predicate: isOperandI64($Dst) && isOperandIReg($Lhs) && isOperandIReg($Rhs)
    Replace:
      MUL:
        Rd: $Dst
        Rs1: $Lhs
        Rs2: $Rhs

  - Pattern:
      InstMul:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        $Predicate: isOperandI32($Dst) && isOperandIReg($Lhs) && isOperandIReg($Rhs)
    Replace:
      MULW:
        Rd: $Dst
        Rs1: $Lhs
        Rs2: $Rhs

  - Pattern:
      InstSDiv:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        $Predicate: isOperandI32($Dst) && isOperandIReg($Lhs) && isOperandIReg($Rhs)
    Replace:
      DIVW:
        Rd: $Dst
        Rs1: $Lhs
        Rs2: $Rhs

  - Pattern:
      InstSRem:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        $Predicate: isOperandI32($Dst) && isOperandIReg($Lhs) && isOperandIReg($Rhs)
    Replace:
      REMW:
        Rd: $Dst
        Rs1: $Lhs
        Rs2: $Rhs

  - Pattern:
      InstUDiv:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        $Predicate: isOperandI32($Dst) && isOperandIReg($Lhs) && isOperandIReg($Rhs)
    Replace:
      DIVUW:
        Rd: $Dst
        Rs1: $Lhs
        Rs2: $Rhs

  - Pattern:
      InstURem:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        $Predicate: isOperandI32($Dst) && isOperandIReg($Lhs) && isOperandIReg($Rhs)
    Replace:
      REMUW:
        Rd: $Dst
        Rs1: $Lhs
        Rs2: $Rhs

  # Integer Compare
  - Pattern:
      InstSCmp:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        Op: $Op
        $Predicate: isOperandIReg($Lhs) && isOperandIReg($Rhs) && isLessThanOp($Op)
    Replace:
      SLT:
        Rd: $Dst
        Rs1: $Lhs
        Rs2: $Rhs

  - Pattern:
      InstUCmp:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        Op: $Op
        $Predicate: isOperandIReg($Lhs) && isOperandIReg($Rhs) && isLessThanOp($Op)
    Replace:
      SLTU:
        Rd: $Dst
        Rs1: $Lhs
        Rs2: $Rhs

  - Pattern:
      InstSCmp:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        Op: $Op
        $Predicate: isOperandIReg($Lhs) && isOperandIReg($Rhs) && isGreaterThanOp($Op)
    Replace:
      SLT:
        Rd: $Dst
        Rs1: $Rhs
        Rs2: $Lhs

  - Pattern:
      InstUCmp:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        Op: $Op
        $Predicate: isOperandIReg($Lhs) && isOperandIReg($Rhs) && isGreaterThanOp($Op)
    Replace:
      SLTU:
        Rd: $Dst
        Rs1: $Rhs
        Rs2: $Lhs

  - Pattern:
      InstSCmp:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        Op: $Op
        $Predicate: isOperandIReg($Lhs) && isOperandImm12($Rhs) && isLessThanOp($Op)
    Replace:
      SLTI:
        Rd: $Dst
        Rs1: $Lhs
        Imm: $Rhs

  - Pattern:
      InstUCmp:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        Op: $Op
        $Predicate: isOperandIReg($Lhs) && isOperandImm12($Rhs) && isLessThanOp($Op)
    Replace:
      SLTIU:
        Rd: $Dst
        Rs1: $Lhs
        Imm: $Rhs

  - Pattern:
      InstSCmp:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        Op: $Op
        $Predicate: isOperandIReg($Lhs) && isZero($Rhs) && isEqualOp($Op)
    Replace:
      SLTIU:
        Rd: $Dst
        Rs1: $Lhs
        Imm: getOne($Lhs)

  - Pattern:
      InstUCmp:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        Op: $Op
        $Predicate: isOperandIReg($Lhs) && isZero($Rhs) && isEqualOp($Op)
    Replace:
      SLTIU:
        Rd: $Dst
        Rs1: $Lhs
        Imm: getOne($Lhs)

  - Pattern:
      InstSCmp:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        Op: $Op
        $Predicate: isOperandIReg($Lhs) && isZero($Rhs) && isNotEqualOp($Op)
    Replace:
      SLTU:
        Rd: $Dst
        Rs1: getZero($Rhs)
        Rs2: $Lhs

  - Pattern:
      InstUCmp:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        Op: $Op
        $Predicate: isOperandIReg($Lhs) && isZero($Rhs) && isNotEqualOp($Op)
    Replace:
      SLTU:
        Rd: $Dst
        Rs1: getZero($Rhs)
        Rs2: $Lhs

  # x<=y -> !(y<x)
  - Pattern:
      InstSCmp:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        Op: $Op
        $Predicate: isOperandIReg($Lhs) && isOperandIReg($Rhs) && isLessEqualOp($Op)
    Replace:
      XORI:
        Rd: $Dst
        Rs1:
          SLT:
            Rd: getVRegAs(ctx, $Dst)
            Rs1: $Rhs
            Rs2: $Lhs
        Imm: getOne($Dst)

  - Pattern:
      InstUCmp:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        Op: $Op
        $Predicate: isOperandIReg($Lhs) && isOperandIReg($Rhs) && isLessEqualOp($Op)
    Replace:
      XORI:
        Rd: $Dst
        Rs1:
          SLTU:
            Rd: getVRegAs(ctx, $Dst)
            Rs1: $Rhs
            Rs2: $Lhs
        Imm: getOne($Dst)

  # SExt/ZExt/Trunc
  - Pattern:
      InstZExt:
        Dst: $Dst
        Src: $Src
        $Predicate: isOperandBoolReg($Src)
    Replace:
      InstCopy:
        Dst: $Dst
        Src: $Src

  - Pattern:
      InstZExt:
        Dst: $Dst
        Src: $Src
        $Predicate: isOperandIReg($Src) && ($Src).type() == OperandType::Int8
    Replace:
      ANDI:
        Rd: $Dst
        Rs1: $Src
        Imm: getZExtMask(($Dst).type(), ($Src).type())

  - Pattern:
      InstSExt:
        Dst: $Dst
        Src: $Src
        $Predicate: isOperandIReg($Src)
    Replace:
      InstCopy:
        Dst: $Dst
        Src: $Src

  # Control Flow
  # See also https://github.com/riscv-non-isa/riscv-asm-manual/blob/master/riscv-asm.md
  - Pattern:
      InstUnreachable:
    Replace:
      UNIMP:
  - Pattern:
      InstJump:
        Tgt: $Tgt
    Replace:
      J:
        Tgt: $Tgt

  - Pattern:
      InstBranch:
        Cond:
          InstSCmp:
            Lhs: $Lhs
            Rhs: $Rhs
            Op: $Op
            $Predicate: isOperandIReg($Lhs) && isZero($Rhs)
        Tgt: $Reloc
        Prob: $Prob
    Replace:
      Branch:
        $Opcode: getSignedBranchOpcode($Op)
        $Template: BLT
        Rs1: $Lhs
        Rs2: getZero($Lhs)
        Tgt: $Reloc
        Prob: $Prob

  # a >= 1 -> a > 0
  - Pattern:
      InstBranch:
        Cond:
          InstSCmp:
            Lhs: $Lhs
            Rhs: $Rhs
            Op: $Op
            $Predicate: isOperandIReg($Lhs) && isOne($Rhs) && isGreaterEqualOp($Op)
        Tgt: $Reloc
        Prob: $Prob
    Replace:
      BGT:
        Rs1: $Lhs
        Rs2: getZero($Lhs)
        Tgt: $Reloc
        Prob: $Prob

  # a > -1 -> a >= 0
  - Pattern:
      InstBranch:
        Cond:
          InstSCmp:
            Lhs: $Lhs
            Rhs: $Rhs
            Op: $Op
            $Predicate: isOperandIReg($Lhs) && isNegativeOne($Rhs) && isGreaterThanOp($Op)
        Tgt: $Reloc
        Prob: $Prob
    Replace:
      BGE:
        Rs1: $Lhs
        Rs2: getZero($Lhs)
        Tgt: $Reloc
        Prob: $Prob

  # a < 1 -> a <= 0
  - Pattern:
      InstBranch:
        Cond:
          InstSCmp:
            Lhs: $Lhs
            Rhs: $Rhs
            Op: $Op
            $Predicate: isOperandIReg($Lhs) && isOne($Rhs) && isLessThanOp($Op)
        Tgt: $Reloc
        Prob: $Prob
    Replace:
      BLE:
        Rs1: $Lhs
        Rs2: getZero($Lhs)
        Tgt: $Reloc
        Prob: $Prob

  # a <= -1 -> a < 0
  - Pattern:
      InstBranch:
        Cond:
          InstSCmp:
            Lhs: $Lhs
            Rhs: $Rhs
            Op: $Op
            $Predicate: isOperandIReg($Lhs) && isNegativeOne($Rhs) && isLessEqualOp($Op)
        Tgt: $Reloc
        Prob: $Prob
    Replace:
      BLT:
        Rs1: $Lhs
        Rs2: getZero($Lhs)
        Tgt: $Reloc
        Prob: $Prob

  - Pattern:
      InstBranch:
        Cond:
          InstSCmp:
            Lhs: $Lhs
            Rhs: $Rhs
            Op: $Op
            $Predicate: isOperandIReg($Lhs) && isOperandImm($Rhs)
        Tgt: $Reloc
        Prob: $Prob
    Replace:
      Branch:
        $Opcode: getSignedBranchOpcode($Op)
        $Template: BLT
        Rs1: $Lhs
        Rs2:
          InstLoadImm:
            Dst: getVRegAs(ctx, $Lhs)
            Imm: $Rhs
        Tgt: $Reloc
        Prob: $Prob

  - Pattern:
      InstBranch:
        Cond:
          InstSCmp:
            Lhs: $Lhs
            Rhs: $Rhs
            Op: $Op
            $Predicate: isOperandIReg($Lhs) && isOperandIReg($Rhs)
        Tgt: $Reloc
        Prob: $Prob
    Replace:
      Branch:
        $Opcode: getSignedBranchOpcode($Op)
        $Template: BLT
        Rs1: $Lhs
        Rs2: $Rhs
        Tgt: $Reloc
        Prob: $Prob

  # a != b -> (a == b) == 0
  - Pattern:
      InstBranch:
        Cond:
          InstFCmp:
            Dst: $Dst
            Lhs: $Lhs
            Rhs: $Rhs
            Op: $Op
            $Predicate: isNotEqualOp($Op)
        Tgt: $Reloc
        Prob: $Prob
    Replace:
      BEQ:
        Rs1:
          InstFCmp:
            Dst: getVRegAs(ctx, $Dst)
            Lhs: $Lhs
            Rhs: $Rhs
            Op: getEqualOp()
        Rs2: getZero($Dst)
        Tgt: $Reloc
        Prob: $Prob

  - Pattern:
      InstBranch:
        Cond: $Cond
        Tgt: $Reloc
        Prob: $Prob
        $Predicate: isOperandIReg($Cond)
    Replace:
      BNE:
        Rs1: $Cond
        Rs2: getZero($Cond)
        Tgt: $Reloc
        Prob: $Prob

  # Load/Store
  - Pattern:
      InstLoad:
        Dst: $Dst
        Addr: $Addr
        $Predicate: selectAddrOffset($Addr, ctx, [$Base], [$Offset])
    Replace:
      Load:
        $Opcode: getLoadOpcode($Dst)
        $Template: LW
        Rd: $Dst
        Rs1: $Base
        Imm: $Offset

  - Pattern:
      InstZExt:
        Dst: $Dst
        Src:
          InstLoad:
            Dst: $Val
            Addr: $Addr
            $Predicate: selectAddrOffset($Addr, ctx, [$Base], [$Offset])
    Replace:
      Load:
        $Opcode: getZExtLoadOpcode($Val)
        $Template: LBU
        Rd: $Dst
        Rs1: $Base
        Imm: $Offset

  - Pattern:
      InstStore:
        Src:
          InstTrunc:
            Dst: $Dst
            Src: $Src
        Addr: $Addr
        $Predicate: isOperandVRegOrISAReg($Src) && selectAddrOffset($Addr, ctx, [$Base], [$Offset])
    Replace:
      Store:
        $Opcode: getStoreOpcode($Dst)
        $Template: SW
        Rs2: $Src
        Rs1: $Base
        Imm: $Offset

  - Pattern:
      InstStore:
        Src: $Src
        Addr: $Addr
        $Predicate: isOperandVRegOrISAReg($Src) && selectAddrOffset($Addr, ctx, [$Base], [$Offset])
    Replace:
      Store:
        $Opcode: getStoreOpcode($Src)
        $Template: SW
        Rs2: $Src
        Rs1: $Base
        Imm: $Offset

  # Floating Point
  - Pattern:
      InstF2S:
        Dst: $Dst
        Src: $Src
    Replace:
      FCVT_W_S:
        Rd: $Dst
        Rs1: $Src

  - Pattern:
      InstS2F:
        Dst: $Dst
        Src: $Src
    Replace:
      FCVT_S_W:
        Rd: $Dst
        Rs1: $Src

  - Pattern:
      $Template:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
      $Instances: [InstFAdd, InstFSub, InstFMul, InstFDiv]
    Replace:
      FloatingPointBinary:
        $Opcode: getFloatingPointBinaryOpcode(rootOpcode)
        $Template: FADD_S
        Rd: $Dst
        Rs1: $Lhs
        Rs2: $Rhs

  - Pattern:
      InstFNeg:
        Dst: $Dst
        Src: $Src
    Replace:
      FNEG_S:
        Rd: $Dst
        Rs1: $Src

  - Pattern:
      InstFCmp:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        Op: $Op
        $Predicate: selectFCmpOpcode($Op, $Lhs, $Rhs, [$OutLhs], [$OutRhs], [$CmpOpcode])
    Replace:
      FCmp:
        $Opcode: static_cast<uint32_t>(($CmpOpcode).imm())
        $Template: FLT_S
        Rd: $Dst
        Rs1: $OutLhs
        Rs2: $OutRhs

  - Pattern:
      InstFCmp:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        Op: $Op
        $Predicate: isNotEqualOp($Op)
    Replace:
      XORI:
        Rd: $Dst
        Rs1:
          InstFCmp:
            Dst: $Dst
            Lhs: $Lhs
            Rhs: $Rhs
            Op: getEqualOp()
        Imm: getOne($Dst)

  # For csmith
  - Pattern:
      InstZExt:
        Dst: $Dst
        Src:
          ANDI:
            Rd: $Val
            Rs1: $Src
            Imm: $Imm
        $Predicate: ($Val).type() == OperandType::Int32 && ($Dst).type() == OperandType::Int64
    Replace:
      InstCopy:
        Dst: $Dst
        Src: $Val

  - Pattern:
      InstZExt:
        Dst: $Dst
        Src: $Src
        $Predicate: isOperandIReg($Src) && (($Dst).type() == OperandType::Int32 || ($Dst).type() == OperandType::Int64)
    Replace:
      AND:
        Rd: $Dst
        Rs1: $Src
        Rs2:
          LoadImm32:
            Rd: getVRegAs(ctx, $Src)
            Imm: getZExtMask(($Dst).type(), ($Src).type())

  - Pattern:
      InstTrunc:
        Dst: $Dst
        Src: $Src
        $Predicate: isOperandIReg($Src) && (($Dst).type() == OperandType::Int32 && ($Src).type() == OperandType::Int32)
    Replace:
      InstCopy:
        Dst: $Dst
        Src: $Src

  - Pattern:
      InstTrunc:
        Dst: $Dst
        Src: $Src
        $Predicate: isOperandIReg($Src)
    Replace:
      SRAI:
        Rd: $Dst
        Rs1:
          SLLI:
            Rd: getVRegAs(ctx, $Src)
            Rs1: $Src
            Imm: getTruncShift(($Dst).type())
        Imm: getTruncShift(($Dst).type())

ScheduleModel:
  sifive-u74:
    CustomPeepholeOpt: true
