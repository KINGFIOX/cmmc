InstInfo:
  IntegerBinary:
    Format: $Mnemonic:Template $Rd:GPR[Def], $Rs:GPR[Use], $Rt:GPR[Use]
    Instances:
      ADDU:
        Mnemonic: addu
      AND:
        Mnemonic: and
      NOR:
        Mnemonic: nor
      OR:
        Mnemonic: or
      SLLV:
        Mnemonic: sllv
      SRAV:
        Mnemonic: srav
      SRLV:
        Mnemonic: srlv
      SUBU:
        Mnemonic: subu
      XOR:
        Mnemonic: xor

  ADDIU:
    Format: addiu $Rd:GPR[Def], $Rs:GPR[Use], $Imm:Imm16[Metadata]
  IntegerBitwiseOps:
    Format: $Mnemonic:Template $Rd:GPR[Def], $Rs:GPR[Use], $Imm:UImm16[Metadata]
    Instances:
      ANDI:
        Mnemonic: andi
      ORI:
        Mnemonic: ori
      XORI:
        Mnemonic: xori
  IntegerShiftOps:
    Format: $Mnemonic:Template $Rd:GPR[Def], $Rs:GPR[Use], $Imm:UImm5[Metadata]
    Instances:
      SLL:
        Mnemonic: sll
      SRA:
        Mnemonic: sra
      SRL:
        Mnemonic: srl

  FloatingPointBinary:
    Format: $Mnemonic:Template $Rd:FPR[Def], $Rs:FPR[Use], $Rt:FPR[Use]
    Instances:
      ADD_S:
        Mnemonic: add.s
      SUB_S:
        Mnemonic: sub.s
      MUL_S:
        Mnemonic: mul.s
      DIV_S:
        Mnemonic: div.s

  FloatingPointUnary:
    Format: $Mnemonic:Template $Rd:FPR[Def], $Rs:FPR[Use]
    Instances:
      ABS_S:
        Mnemonic: abs.s
      NEG_S:
        Mnemonic: neg.s

  B:
    Format: b $Tgt:Reloc[Metadata]
    Flag: [Terminator, Branch, NoFallthrough]
  BC1F:
    Format: "bc1f $Tgt:Reloc[Metadata] # Implicit Use: $Rs:CC[Use] Branch Prob: $Prob:Prob[Metadata]"
    Flag: [Terminator, Branch]
  BC1T:
    Format: "bc1t $Tgt:Reloc[Metadata] # Implicit Use: $Rs:CC[Use] Branch Prob: $Prob:Prob[Metadata]"
    Flag: [Terminator, Branch]
  BranchCompare:
    Format: "$Mnemonic:Template $Rs:GPR[Use], $Rt:GPR[Use], $Tgt:Reloc[Metadata] # Branch Prob: $Prob:Prob[Metadata]"
    Flag: [Terminator, Branch]
    Instances:
      BEQ:
        Mnemonic: beq
      BNE:
        Mnemonic: bne
  BranchCompareZero:
    Format: "$Mnemonic:Template $Rs:GPR[Use], $Tgt:Reloc[Metadata] # Branch Prob: $Prob:Prob[Metadata]"
    Flag: [Terminator, Branch]
    Instances:
      BGEZ:
        Mnemonic: bgez
      BGTZ:
        Mnemonic: bgtz
      BLEZ:
        Mnemonic: blez
      BLTZ:
        Mnemonic: bltz

  FloatingPointCompare:
    Format: "$Mnemonic:Template $Rs:FPR[Use], $Rt:FPR[Use] # Implicit Def: $Rd:CC[Def]"
    Instances:
      C_EQ_S:
        Mnemonic: c.eq.s
      C_LT_S:
        Mnemonic: c.lt.s
      C_LE_S:
        Mnemonic: c.le.s

  FloatingPointConvert:
    Format: "$Mnemonic:Template $Rd:FPR[Def], $Rs:FPR[Use]"
    Instances:
      CVT_S_W:
        Mnemonic: cvt.s.w
      #CVT_W_S:
      #  Mnemonic: cvt.w.s
      TRUNC_W_S:
        Mnemonic: trunc.w.s

  MulDiv:
    Format: "$Mnemonic:Template $Rs:GPR[Use], $Rt:GPR[Use] # Implicit Def: $Rd:HILO[Def]"
    Instances:
      DIV:
        Mnemonic: div
      DIVU:
        Mnemonic: divu
      MULT:
        Mnemonic: mult

  JAL:
    Format: "jal $Tgt:Reloc[Metadata]"
    Flag: [Call]
  JR:
    Format: jr $Rs:GPR[Use]
    Flag: [Terminator, NoFallthrough, Return]

  Load:
    Format: $Mnemonic:Template $Rd:GPR[Def], $Imm:Imm16[Metadata]($Rs:BaseLike[Use])
    Flag: [Load]
    Instances:
      LB:
        Mnemonic: lb
      LBU:
        Mnemonic: lbu
      LH:
        Mnemonic: lh
      LHU:
        Mnemonic: lhu
      LW:
        Mnemonic: lw
  Store:
    Format: $Mnemonic:Template $Rd:GPR[Use], $Imm:Imm16[Metadata]($Rs:BaseLike[Use])
    Flag: [Store]
    Instances:
      SB:
        Mnemonic: sb
      SH:
        Mnemonic: sh
      SW:
        Mnemonic: sw

  LWC1:
    Format: lwc1 $Rd:FPR[Def], $Imm:Imm16[Metadata]($Rs:BaseLike[Use])
    Flag: [Load]

  SWC1:
    Format: swc1 $Rd:FPR[Use], $Imm:Imm16[Metadata]($Rs:BaseLike[Use])
    Flag: [Store]

  MFC1:
    Format: mfc1 $Rd:GPR[Def], $Rs:FPR[Use]
  MTC1:
    Format: mtc1 $Rd:FPR[Def], $Rs:GPR[Use]
  MFHI:
    Format: "mfhi $Rd:GPR[Def] # Implicit Use: $Rs:HILO[Use]"
  MFLO:
    Format: "mflo $Rd:GPR[Def] # Implicit Use: $Rs:HILO[Use]"
  MOV_S:
    Format: mov.s $Rd:FPR[Def], $Rs:FPR[Use]

  Compare:
    Format: $Mnemonic:Template $Rd:GPR[Def], $Rs:GPR[Use], $Rt:GPR[Use]
    Instances:
      SLT:
        Mnemonic: slt
      SLTU:
        Mnemonic: sltu

  CompareImm:
    Format: $Mnemonic:Template $Rd:GPR[Def], $Rs:GPR[Use], $Imm:Imm16[Metadata]
    Instances:
      SLTI:
        Mnemonic: slti
      SLTIU:
        Mnemonic: sltiu

  LUI:
    Format: "lui $Rd:GPR[Def], $Imm:UImm16[Metadata]"
    Flag: [LoadConstant]

  # Pseudo Instrucitons
  LoadAddress:
    Format: "la $Rd:GPR[Def], $Addr:Reloc[Metadata]"
    Flag: [LoadConstant]

  LoadImm16:
    Format: "li $Rd:GPR[Def], $Imm:NonZeroImm16[Metadata]" # addiu
    Flag: [LoadConstant]

  # TODO: expand to LUI+ADDIU?
  LoadImm32:
    Format: "li $Rd:GPR[Def], $Imm:NonZeroImm32[Metadata]" # lui + addiu
    Flag: [LoadConstant]

  MoveGPR:
    Format: "move $Rd:GPR[Def], $Rs:GPR[Use]"
    Flag: [RegCopy]

  # Conditional Move Instructions
  MOVN:
    Format: "movn $Rd:GPR[Def], $Rs:GPR[Use], $Rt:GPR[Use]"
  MOVZ:
    Format: "movz $Rd:GPR[Def], $Rs:GPR[Use], $Rt:GPR[Use]"

  # Illegal Pseudo Instrucitons
  # select[CC][Val]
  Select_GPR_GPR: # => Copy + MOVN
    Format: "select_gpr_gpr $Rd:GPR[Def], $Rs:GPR[Use], $Rt:IRegOrImm[Use], $Cond:GPR[Use]"
    Flag: [LegalizePreRA]

InstSelection:
  - Pattern:
      InstLoadImmToReg:
        Dst: $Dst
        Imm: $Imm
        $Predicate: isZero($Imm)
    Replace:
      # TODO: using ResetToZero -> InstFlagLoadConstant
      MoveGPR:
        Rd: $Dst
        Rs: getZero($Dst)

  - Pattern:
      InstLoadImm:
        Dst: $Dst
        Imm: $Imm
        $Predicate: isZero($Imm)
    Replace:
      # TODO: using InstResetToZero -> InstFlagLoadConstant
      InstCopyFromReg:
        Dst: $Dst
        Src: getZero($Dst)

  - Pattern:
      InstLoadImmToReg:
        Dst: $Dst
        Imm: $Imm
        $Predicate: isOperandNonZeroImm16($Imm)
    Replace:
      LoadImm16:
        Rd: $Dst
        Imm: $Imm

  - Pattern:
      InstLoadImmToReg:
        Dst: $Dst
        Imm: $Imm
        $Predicate: isOperandNonZeroImm32($Imm)
    Replace:
      LoadImm32:
        Rd: $Dst
        Imm: $Imm

  - Pattern:
      InstLoadImm:
        Dst: $Dst
        Imm: $Imm
        $Predicate: isOperandNonZeroImm16($Imm)
    Replace:
      LoadImm16:
        Rd: $Dst
        Imm: $Imm

  - Pattern:
      InstLoadImm:
        Dst: $Dst
        Imm: $Imm
        $Predicate: isOperandNonZeroImm32($Imm)
    Replace:
      LoadImm32:
        Rd: $Dst
        Imm: $Imm

  - Pattern:
      InstJump:
        Tgt: $Tgt
    Replace:
      B:
        Tgt: $Tgt

  # Integer Arithmetic
  - Pattern:
      InstAdd:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        $Predicate: isOperandIReg($Lhs) && isOperandIReg($Rhs)
    Replace:
      ADDU:
        Rd: $Dst
        Rs: $Lhs
        Rt: $Rhs

  - Pattern:
      InstAdd:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        $Predicate: isOperandIReg($Lhs) && isOperandImm16($Rhs)
    Replace:
      ADDIU:
        Rd: $Dst
        Rs: $Lhs
        Imm: $Rhs

  - Pattern:
      InstSub:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        $Predicate: isOperandIReg($Lhs) && isOperandIReg($Rhs)
    Replace:
      SUBU:
        Rd: $Dst
        Rs: $Lhs
        Rt: $Rhs

  - Pattern:
      InstAnd:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        $Predicate: isOperandIReg($Lhs) && isOperandUImm16($Rhs)
    Replace:
      ANDI:
        Rd: $Dst
        Rs: $Lhs
        Imm: $Rhs

  - Pattern:
      InstAnd:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        $Predicate: isOperandIReg($Lhs) && isOperandIReg($Rhs)
    Replace:
      AND:
        Rd: $Dst
        Rs: $Lhs
        Rt: $Rhs

  - Pattern:
      InstOr:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        $Predicate: isOperandIReg($Lhs) && isOperandUImm16($Rhs)
    Replace:
      ORI:
        Rd: $Dst
        Rs: $Lhs
        Imm: $Rhs

  - Pattern:
      InstOr:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        $Predicate: isOperandIReg($Lhs) && isOperandIReg($Rhs)
    Replace:
      OR:
        Rd: $Dst
        Rs: $Lhs
        Rt: $Rhs

  - Pattern:
      InstXor:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        $Predicate: isOperandIReg($Lhs) && isOperandUImm16($Rhs)
    Replace:
      XORI:
        Rd: $Dst
        Rs: $Lhs
        Imm: $Rhs

  - Pattern:
      InstXor:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        $Predicate: isOperandIReg($Lhs) && isOperandIReg($Rhs)
    Replace:
      XOR:
        Rd: $Dst
        Rs: $Lhs
        Rt: $Rhs

  # Branches
  # BLEZ BLTZ BGEZ BGTZ
  - Pattern:
      InstBranch:
        Cond:
          InstSCmp:
            Lhs: $Lhs
            Rhs: $Rhs
            Op: $Op
            $Predicate: isOperandIReg($Lhs) && isZero($Rhs) && isRationalOp($Op)
        Tgt: $Reloc
        Prob: $Prob
    Replace:
      Branch:
        $Opcode: getBranchWithZeroOpcode($Op)
        $Template: BLTZ
        Rs: $Lhs
        Tgt: $Reloc
        Prob: $Prob

  - Pattern:
      InstBranch:
        Cond:
          InstSCmp:
            Lhs: $Lhs
            Rhs: $Rhs
            Op: $Op
            $Predicate: isOperandIReg($Lhs) && isOperandImm($Rhs) && isOperandImm16(getNeg($Rhs)) && isRationalOp($Op)
        Tgt: $Reloc
        Prob: $Prob
    Replace:
      Branch:
        $Opcode: getBranchWithZeroOpcode($Op)
        $Template: BLTZ
        Rs:
          ADDIU:
            Rd: getVRegAs(ctx, $Lhs)
            Rs: $Lhs
            Imm: getNeg($Rhs)
        Tgt: $Reloc
        Prob: $Prob

  - Pattern:
      InstBranch:
        Cond:
          InstSCmp:
            Lhs: $Lhs
            Rhs: $Rhs
            Op: $Op
            $Predicate: isOperandIReg($Lhs) && isOperandImm32($Rhs) && isRationalOp($Op)
        Tgt: $Reloc
        Prob: $Prob
    Replace:
      Branch:
        $Opcode: getBranchWithZeroOpcode($Op)
        $Template: BLTZ
        Rs:
          ADDU:
            Rd: getVRegAs(ctx, $Lhs)
            Rs: $Lhs
            Rt:
              LoadImm32:
                Rd: getVRegAs(ctx, $Rhs)
                Imm: getNeg($Rhs)
        Tgt: $Reloc
        Prob: $Prob

  - Pattern:
      InstBranch:
        Cond:
          InstSCmp:
            Lhs: $Lhs
            Rhs: $Rhs
            Op: $Op
            $Predicate: isOperandIReg($Lhs) && isOperandIReg($Rhs) && isRationalOp($Op)
        Tgt: $Reloc
        Prob: $Prob
    Replace:
      Branch:
        $Opcode: getBranchWithZeroOpcode($Op)
        $Template: BLTZ
        Rs:
          SUBU:
            Rd: getVRegAs(ctx, $Lhs)
            Rs: $Lhs
            Rt: $Rhs
        Tgt: $Reloc
        Prob: $Prob

  - Pattern:
      InstBranch:
        Cond:
          InstSCmp:
            Lhs: $Lhs
            Rhs: $Rhs
            Op: $Op
            $Predicate: isOperandIReg($Lhs) && isOperandIRegOrImm($Rhs) && isEqualityOp($Op)
        Tgt: $Reloc
        Prob: $Prob
    Replace:
      Branch:
        $Opcode: getBranchEqualityOpcode($Op)
        $Template: BEQ
        Rs: $Lhs
        Rt: getIReg(ctx, $Rhs)
        Tgt: $Reloc
        Prob: $Prob

  - Pattern:
      InstSCmp:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        Op: $Op
        $Predicate: isOperandIReg($Lhs) && isOperandIReg($Rhs) && isLessThanOp($Op)
    Replace:
      SLT:
        Rd: $Dst
        Rs: $Lhs
        Rt: $Rhs

  - Pattern:
      InstUCmp:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        Op: $Op
        $Predicate: isOperandIReg($Lhs) && isOperandIReg($Rhs) && isLessThanOp($Op)
    Replace:
      SLTU:
        Rd: $Dst
        Rs: $Lhs
        Rt: $Rhs

  - Pattern:
      InstSCmp:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        Op: $Op
        $Predicate: isOperandIReg($Lhs) && isOperandIReg($Rhs) && isGreaterThanOp($Op)
    Replace:
      SLT:
        Rd: $Dst
        Rs: $Rhs
        Rt: $Lhs

  - Pattern:
      InstUCmp:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        Op: $Op
        $Predicate: isOperandIReg($Lhs) && isOperandIReg($Rhs) && isGreaterThanOp($Op)
    Replace:
      SLTU:
        Rd: $Dst
        Rs: $Rhs
        Rt: $Lhs

  - Pattern:
      InstSCmp:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        Op: $Op
        $Predicate: isOperandIReg($Lhs) && isOperandImm16($Rhs) && isLessThanOrLessEqualOp($Op)
    Replace:
      SLTI:
        Rd: $Dst
        Rs: $Lhs
        Imm: $Rhs

  - Pattern:
      InstUCmp:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        Op: $Op
        $Predicate: isOperandIReg($Lhs) && isOperandImm16($Rhs) && isLessThanOrLessEqualOp($Op)
    Replace:
      SLTIU:
        Rd: $Dst
        Rs: $Lhs
        Imm: $Rhs

  - Pattern:
      InstSCmp:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        Op: $Op
        $Predicate: isOperandIReg($Lhs) && isZero($Rhs) && isEqualOp($Op)
    Replace:
      SLTIU:
        Rd: $Dst
        Rs: $Lhs
        Imm: getOne($Lhs)

  - Pattern:
      InstSCmp:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        Op: $Op
        $Predicate: isOperandIReg($Lhs) && isZero($Rhs) && isNotEqualOp($Op)
    Replace:
      XORI:
        Rd: $Dst
        Rs:
          SLTIU:
            Rd: getVRegAs(ctx, $Dst)
            Rs: $Lhs
            Imm: getOne($Lhs)
        Imm: getOne($Dst)

  # x<=y -> !(y<x)
  - Pattern:
      InstSCmp:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        Op: $Op
        $Predicate: isOperandIReg($Lhs) && isOperandIReg($Rhs) && isLessEqualOp($Op)
    Replace:
      XORI:
        Rd: $Dst
        Rs:
          SLT:
            Rd: getVRegAs(ctx, $Dst)
            Rs: $Rhs
            Rt: $Lhs
        Imm: getOne($Dst)

  # MUL/DIV/DIVU
  - Pattern:
      InstMul:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        $Predicate: isOperandIReg($Lhs) && isOperandIReg($Rhs)
    Replace:
      MFLO:
        Rd: $Dst
        Rs:
          MULT:
            Rd: getHILO()
            Rs: $Lhs
            Rt: $Rhs

  - Pattern:
      InstSDiv:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        $Predicate: isOperandIReg($Lhs) && isOperandIReg($Rhs)
    Replace:
      MFLO:
        Rd: $Dst
        Rs:
          DIV:
            Rd: getHILO()
            Rs: $Lhs
            Rt: $Rhs

  - Pattern:
      InstSRem:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        $Predicate: isOperandIReg($Lhs) && isOperandIReg($Rhs)
    Replace:
      MFHI:
        Rd: $Dst
        Rs:
          DIV:
            Rd: getHILO()
            Rs: $Lhs
            Rt: $Rhs

  - Pattern:
      InstUDiv:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        $Predicate: isOperandIReg($Lhs) && isOperandIReg($Rhs)
    Replace:
      MFLO:
        Rd: $Dst
        Rs:
          DIVU:
            Rd: getHILO()
            Rs: $Lhs
            Rt: $Rhs

  - Pattern:
      InstURem:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        $Predicate: isOperandIReg($Lhs) && isOperandIReg($Rhs)
    Replace:
      MFHI:
        Rd: $Dst
        Rs:
          DIVU:
            Rd: getHILO()
            Rs: $Lhs
            Rt: $Rhs

  # Load/Store
  - Pattern:
      InstLoad:
        Dst: $Dst
        Addr: $Addr
        $Predicate: selectAddrOffset($Addr, ctx, [$Base], [$Offset])
    Replace:
      Load:
        $Opcode: getLoadOpcode($Dst)
        $Template: LW
        Rd: $Dst
        Rs: $Base
        Imm: $Offset

  - Pattern:
      InstStore:
        Src: $Src
        Addr: $Addr
        $Predicate: isOperandVRegOrISAReg($Src) && selectAddrOffset($Addr, ctx, [$Base], [$Offset])
    Replace:
      Store:
        $Opcode: getStoreOpcode($Src)
        $Template: SW
        Rd: $Src
        Rs: $Base
        Imm: $Offset

  # Select
  - Pattern:
      InstSelect:
        Dst: $Dst
        Cond: $Cond
        Lhs: $Lhs
        Rhs: $Rhs
        $Predicate: isOperandIReg($Lhs) && isOperandIRegOrImm($Rhs) && isOperandIReg($Cond)
    Replace:
      Select_GPR_GPR:
        Rd: $Dst
        Rs: $Lhs
        Rt: $Rhs
        Cond: $Cond

  - Pattern:
      InstLoadGlobalAddress:
        Dst: $Dst
        Addr: $Addr
    Replace:
      LoadAddress:
        Rd: $Dst
        Addr: $Addr

  # Floating Point
  - Pattern:
      InstF2S:
        Dst: $Dst
        Src: $Src
    Replace:
      MFC1:
        Rd: $Dst
        Rs:
          TRUNC_W_S:
            Rd: getVRegAs(ctx, $Src)
            Rs: $Src

  - Pattern:
      InstS2F:
        Dst: $Dst
        Src: $Src
    Replace:
      CVT_S_W:
        Rd: $Dst
        Rs:
          MTC1:
            Rd: getVRegAs(ctx, $Dst)
            Rs: $Src

  - Pattern:
      InstFAdd:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
    Replace:
      ADD_S:
        Rd: $Dst
        Rs: $Lhs
        Rt: $Rhs

  - Pattern:
      InstFSub:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
    Replace:
      SUB_S:
        Rd: $Dst
        Rs: $Lhs
        Rt: $Rhs

  - Pattern:
      InstFMul:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
    Replace:
      MUL_S:
        Rd: $Dst
        Rs: $Lhs
        Rt: $Rhs

  - Pattern:
      InstFDiv:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
    Replace:
      DIV_S:
        Rd: $Dst
        Rs: $Lhs
        Rt: $Rhs

ScheduleModel:
  emulator:
    CustomPeepholeOpt: true
