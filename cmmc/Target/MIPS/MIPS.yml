InstInfo:
  IntegerBinary:
    Format: $Mnemonic:Template $Rd:GPR[Def], $Rs:GPR[Use], $Rt:GPR[Use]
    Instances:
      ADDU:
        Mnemonic: addu
      AND:
        Mnemonic: and
      NOR:
        Mnemonic: nor
      OR:
        Mnemonic: or
      SLLV:
        Mnemonic: sllv
      SRAV:
        Mnemonic: srav
      SRLV:
        Mnemonic: srlv
      SUBU:
        Mnemonic: subu
      XOR:
        Mnemonic: xor

  IntegerBinaryImm:
    Format: $Mnemonic:Template $Rd:GPR[Def], $Rs:GPR[Use], $Imm:Imm16[Metadata]
    Instances:
      ADDIU:
        Mnemonic: addiu
      ANDI:
        Mnemonic: andi
      ORI:
        Mnemonic: ori
      SLL:
        Mnemonic: sll
        CustomVerifier: true
      SRA:
        Mnemonic: sra
        CustomVerifier: true
      SRL:
        Mnemonic: srl
        CustomVerifier: true
      XORI:
        Mnemonic: xori

  FloatingPointBinary:
    Format: $Mnemonic:Template $Rd:FPR[Def], $Rs:FPR[Use], $Rt:FPR[Use]
    Instances:
      ADD_S:
        Mnemonic: add.s

  FloatingPointUnary:
    Format: $Mnemonic:Template $Rd:FPR[Def], $Rs:FPR[Use]
    Instances:
      ABS_S:
        Mnemonic: abs.s
      NEG_S:
        Mnemonic: neg.s

  B:
    Format: b $Tgt:Reloc[Metadata]
    Flag: [Terminator, Branch, NoFallthrough]
  BC1F:
    Format: "bc1f $Tgt:Reloc[Metadata] # Implicit Use: $Rs:CC[Use] Branch Prob: $Prob:Prob[Metadata]"
    Flag: [Terminator, Branch]
  BC1T:
    Format: "bc1t $Tgt:Reloc[Metadata] # Implicit Use: $Rs:CC[Use] Branch Prob: $Prob:Prob[Metadata]"
    Flag: [Terminator, Branch]
  BranchCompare:
    Format: "$Mnemonic:Template $Rs:GPR[Use], $Rt:GPR[Use], $Tgt:Reloc[Metadata] # Branch Prob: $Prob:Prob[Metadata]"
    Flag: [Terminator, Branch]
    Instances:
      BEQ:
        Mnemonic: beq
      BNE:
        Mnemonic: bne
  BranchCompareZero:
    Format: "$Mnemonic:Template $Rs:GPR[Use], $Tgt:Reloc[Metadata] # Branch Prob: $Prob:Prob[Metadata]"
    Flag: [Terminator, Branch]
    Instances:
      BGEZ:
        Mnemonic: bgez
      BGTZ:
        Mnemonic: bgtz
      BLEZ:
        Mnemonic: blez
      BLTZ:
        Mnemonic: bltz

  FloatingPointCompare:
    Format: "$Mnemonic:Template $Rs:FPR[Use], $Rt:FPR[Use] # Implicit Def: $Rd:CC[Def]"
    Instances:
      C_EQ_S:
        Mnemonic: c.eq.s
      C_LT_S:
        Mnemonic: c.lt.s
      C_LE_S:
        Mnemonic: c.le.s

  FloatingPointConvert:
    Format: "$Mnemonic:Template $Rd:FPR[Def], $Rs:FPR[Use]"
    Instances:
      CVT_S_W:
        Mnemonic: cvt.s.w
      #CVT_W_S:
      #  Mnemonic: cvt.w.s
      TRUNC_W_S:
        Mnemonic: trunc.w.s

  MulDiv:
    Format: "$Mnemonic:Template $Rs:GPR[Use], $Rt:GPR[Use] # Implicit Def: $Rd:HILO[Def]"
    Instances:
      DIV:
        Mnemonic: div
      DIVU:
        Mnemonic: divu
      MULT:
        Mnemonic: mult

  JAL:
    Format: "jal $Tgt:Reloc[Metadata]"
    Flag: [Call]
  JR:
    Format: jr $Rs:GPR[Use]
    Flag: [Terminator, NoFallthrough, Return]

  Load:
    Format: $Mnemonic:Template $Rd:GPR[Def], $Imm:Imm16[Metadata]($Rs:BaseLike[Use])
    Flag: [Load]
    Instances:
      LB:
        Mnemonic: lb
      LBU:
        Mnemonic: lbu
      LH:
        Mnemonic: lh
      LHU:
        Mnemonic: lhu
      LW:
        Mnemonic: lw
  Store:
    Format: $Mnemonic:Template $Rd:GPR[Use], $Imm:Imm16[Metadata]($Rs:BaseLike[Use])
    Flag: [Store]
    Instances:
      SB:
        Mnemonic: sb
      SH:
        Mnemonic: sh
      SW:
        Mnemonic: sw

  MFC1:
    Format: mfc1 $Rd:GPR[Def], $Rs:FPR[Use]
  MTC1:
    Format: mtc1 $Rd:FPR[Def], $Rs:GPR[Use]
  MFHI:
    Format: "mfhi $Rd:GPR[Def] # Implicit Use: $Rs:HILO[Use]"
  MFLO:
    Format: "mflo $Rd:GPR[Def] # Implicit Use: $Rs:HILO[Use]"
  MOV_S:
    Format: mov.s $Rd:FPR[Def], $Rs:FPR[Use]

  Compare:
    Format: $Mnemonic:Template $Rd:GPR[Def], $Rs:GPR[Use], $Rt:GPR[Use]
    Instances:
      SLT:
        Mnemonic: slt
      SLTU:
        Mnemonic: sltu

  CompareImm:
    Format: $Mnemonic:Template $Rd:GPR[Def], $Rs:GPR[Use], $Imm:Imm16[Metadata]
    Instances:
      SLTI:
        Mnemonic: slti
      SLTIU:
        Mnemonic: sltiu

  # Pseudo instructions
  LoadAddress:
    Format: "la $Rd:GPR[Def], $Addr:Reloc[Metadata]"
    Flag: [LoadConstant]

  LoadImm16:
    Format: "li $Rd:GPR[Def], $Imm:Imm16[Metadata]" # addiu
    Flag: [LoadConstant]

  LoadImm32:
    Format: "li $Rd:GPR[Def], $Imm:Imm32[Metadata]" # lui + addiu
    Flag: [LoadConstant]

  # TODO: Conditional Move Instructions

InstSelection:
  - Pattern:
      InstLoadImmToReg:
        Dst: $Dst
        Imm: $Imm
        $Predicate: isOperandImm16($Imm)
    Replace:
      LoadImm16:
        Rd: $Dst
        Imm: $Imm

  - Pattern:
      InstLoadImmToReg:
        Dst: $Dst
        Imm: $Imm
    Replace:
      LoadImm32:
        Rd: $Dst
        Imm: $Imm

  - Pattern:
      InstLoadImm:
        Dst: $Dst
        Imm: $Imm
        $Predicate: isOperandImm16($Imm)
    Replace:
      LoadImm16:
        Rd: $Dst
        Imm: $Imm

  - Pattern:
      InstLoadImm:
        Dst: $Dst
        Imm: $Imm
    Replace:
      LoadImm32:
        Rd: $Dst
        Imm: $Imm

  - Pattern:
      InstJump:
        Tgt: $Tgt
    Replace:
      B:
        Tgt: $Tgt

  # Integer Arithmetic
  - Pattern:
      InstAdd:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        $Predicate: isOperandIReg($Lhs) && isOperandIReg($Rhs)
    Replace:
      ADDU:
        Rd: $Dst
        Rs: $Lhs
        Rt: $Rhs

  - Pattern:
      InstAdd:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        $Predicate: isOperandIReg($Lhs) && isOperandImm16($Rhs)
    Replace:
      ADDIU:
        Rd: $Dst
        Rs: $Lhs
        Imm: $Rhs

  - Pattern:
      InstSub:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        $Predicate: isOperandIReg($Lhs) && isOperandIReg($Rhs)
    Replace:
      SUBU:
        Rd: $Dst
        Rs: $Lhs
        Rt: $Rhs

  - Pattern:
      InstAnd:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        $Predicate: isOperandIReg($Lhs) && isOperandImm16($Rhs)
    Replace:
      ANDI:
        Rd: $Dst
        Rs: $Lhs
        Imm: $Rhs

  - Pattern:
      InstAnd:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        $Predicate: isOperandIReg($Lhs) && isOperandIReg($Rhs)
    Replace:
      AND:
        Rd: $Dst
        Rs: $Lhs
        Rt: $Rhs

  - Pattern:
      InstOr:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        $Predicate: isOperandIReg($Lhs) && isOperandImm16($Rhs)
    Replace:
      ORI:
        Rd: $Dst
        Rs: $Lhs
        Imm: $Rhs

  - Pattern:
      InstOr:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        $Predicate: isOperandIReg($Lhs) && isOperandIReg($Rhs)
    Replace:
      OR:
        Rd: $Dst
        Rs: $Lhs
        Rt: $Rhs

  - Pattern:
      InstXor:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        $Predicate: isOperandIReg($Lhs) && isOperandImm16($Rhs)
    Replace:
      XORI:
        Rd: $Dst
        Rs: $Lhs
        Imm: $Rhs

  - Pattern:
      InstXor:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        $Predicate: isOperandIReg($Lhs) && isOperandIReg($Rhs)
    Replace:
      XOR:
        Rd: $Dst
        Rs: $Lhs
        Rt: $Rhs

  # Branches
  # BLEZ BLTZ BGEZ BGTZ
  - Pattern:
      InstBranch:
        Cond:
          InstSCmp:
            Lhs: $Lhs
            Rhs: $Rhs
            Op: $Op
            $Predicate: isOperandIReg($Lhs) && isZero($Rhs) && isRationalOp($Op)
        Tgt: $Reloc
        Prob: $Prob
    Replace:
      Branch:
        $Opcode: getBranchWithZeroOpcode($Op)
        $Template: BLTZ
        Rs: $Lhs
        Tgt: $Reloc
        Prob: $Prob

  - Pattern:
      InstBranch:
        Cond:
          InstSCmp:
            Lhs: $Lhs
            Rhs: $Rhs
            Op: $Op
            $Predicate: isOperandIReg($Lhs) && isOperandImm($Rhs) && isOperandImm16(getNeg($Rhs)) && isRationalOp($Op)
        Tgt: $Reloc
        Prob: $Prob
    Replace:
      Branch:
        $Opcode: getBranchWithZeroOpcode($Op)
        $Template: BLTZ
        Rs:
          ADDIU:
            Rd: getVRegAs(ctx, $Lhs)
            Rs: $Lhs
            Imm: getNeg($Rhs)
        Tgt: $Reloc
        Prob: $Prob

  - Pattern:
      InstBranch:
        Cond:
          InstSCmp:
            Lhs: $Lhs
            Rhs: $Rhs
            Op: $Op
            $Predicate: isOperandIReg($Lhs) && isOperandIReg($Rhs) && isEqualityOp($Op)
        Tgt: $Reloc
        Prob: $Prob
    Replace:
      Branch:
        $Opcode: getBranchEqualityOpcode($Op)
        $Template: BEQ
        Rs: $Lhs
        Rt: $Rhs
        Tgt: $Reloc
        Prob: $Prob

  - Pattern:
      InstSCmp:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        Op: $Op
        $Predicate: isOperandIReg($Lhs) && isOperandIReg($Rhs) && isLessThanOrLessEqualOp($Op)
    Replace:
      SLT:
        Rd: $Dst
        Rs: $Lhs
        Rt: $Rhs

  - Pattern:
      InstUCmp:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        Op: $Op
        $Predicate: isOperandIReg($Lhs) && isOperandIReg($Rhs) && isLessThanOrLessEqualOp($Op)
    Replace:
      SLTU:
        Rd: $Dst
        Rs: $Lhs
        Rt: $Rhs

  - Pattern:
      InstSCmp:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        Op: $Op
        $Predicate: isOperandIReg($Lhs) && isOperandImm16($Rhs) && isLessThanOrLessEqualOp($Op)
    Replace:
      SLTI:
        Rd: $Dst
        Rs: $Lhs
        Imm: $Rhs

  - Pattern:
      InstUCmp:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        Op: $Op
        $Predicate: isOperandIReg($Lhs) && isOperandImm16($Rhs) && isLessThanOrLessEqualOp($Op)
    Replace:
      SLTIU:
        Rd: $Dst
        Rs: $Lhs
        Imm: $Rhs

  # MUL/DIV/DIVU
  - Pattern:
      InstMul:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        $Predicate: isOperandIReg($Lhs) && isOperandIReg($Rhs)
    Replace:
      MFLO:
        Rd: $Dst
        Rs:
          MULT:
            Rd: getHILO()
            Rs: $Lhs
            Rt: $Rhs

  - Pattern:
      InstSDiv:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        $Predicate: isOperandIReg($Lhs) && isOperandIReg($Rhs)
    Replace:
      MFLO:
        Rd: $Dst
        Rs:
          DIV:
            Rd: getHILO()
            Rs: $Lhs
            Rt: $Rhs

  - Pattern:
      InstSRem:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        $Predicate: isOperandIReg($Lhs) && isOperandIReg($Rhs)
    Replace:
      MFHI:
        Rd: $Dst
        Rs:
          DIV:
            Rd: getHILO()
            Rs: $Lhs
            Rt: $Rhs

  - Pattern:
      InstUDiv:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        $Predicate: isOperandIReg($Lhs) && isOperandIReg($Rhs)
    Replace:
      MFLO:
        Rd: $Dst
        Rs:
          DIVU:
            Rd: getHILO()
            Rs: $Lhs
            Rt: $Rhs

  - Pattern:
      InstURem:
        Dst: $Dst
        Lhs: $Lhs
        Rhs: $Rhs
        $Predicate: isOperandIReg($Lhs) && isOperandIReg($Rhs)
    Replace:
      MFHI:
        Rd: $Dst
        Rs:
          DIVU:
            Rd: getHILO()
            Rs: $Lhs
            Rt: $Rhs

ScheduleModel:
  emulator:
    CustomPeepholeOpt: true
